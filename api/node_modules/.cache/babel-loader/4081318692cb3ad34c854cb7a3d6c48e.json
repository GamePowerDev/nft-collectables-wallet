{"ast":null,"code":"import _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n// Copyright 2019-2021 @polkadot/wasm-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// MIT License\n//\n// Copyright (c) 2020 Arjun Barrett\n//\n// Copied from https://github.com/101arrowz/fflate/blob/73c737941ec89d85cdf0ad39ee6f26c5fdc95fd7/src/index.ts\n// This only contains the unzlibSync function, no compression, no async, no workers\n//\n// These 2 issues are addressed as a short-term, stop-gap solution\n//   - https://github.com/polkadot-js/api/issues/2963\n//   - https://github.com/101arrowz/fflate/issues/17\n//\n// Only tweaks make here are some TS adjustments (we use strict null checks), the code is otherwise as-is with\n// only the single required function provided (compression is still being done in the build with fflate)\n\n/* eslint-disable */\n// inflate state\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array,\n    u16 = Uint16Array,\n    u32 = Uint32Array; // code length index map\n\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]); // fixed length extra bits\n\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0,\n/* unused */\n0, 0,\n/* impossible */\n0]); // fixed distance extra bits\n// see fleb note\n\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13,\n/* unused */\n0, 0]); // get base, reverse index map from extra bits\n\nvar freb = function freb(eb, start) {\n  var b = new u16(31);\n\n  for (var i = 0; i < 31; ++i) {\n    b[i] = start += 1 << eb[i - 1];\n  } // numbers here are at max 18 bits\n\n\n  var r = new u32(b[30]);\n\n  for (var _i = 1; _i < 30; ++_i) {\n    for (var j = b[_i]; j < b[_i + 1]; ++j) {\n      r[j] = j - b[_i] << 5 | _i;\n    }\n  }\n\n  return [b, r];\n};\n\nvar _freb = freb(fleb, 2),\n    _freb2 = _slicedToArray(_freb, 2),\n    fl = _freb2[0],\n    revfl = _freb2[1]; // we can ignore the fact that the other numbers are wrong; they never happen anyway\n\n\nfl[28] = 258, revfl[258] = 28;\n\nvar _freb3 = freb(fdeb, 0),\n    _freb4 = _slicedToArray(_freb3, 1),\n    fd = _freb4[0]; // map of value to reverse (assuming 16 bits)\n\n\nvar rev = new u16(32768);\n\nfor (var i = 0; i < 32768; ++i) {\n  // reverse table algorithm from SO\n  var x = (i & 0xAAAA) >>> 1 | (i & 0x5555) << 1;\n  x = (x & 0xCCCC) >>> 2 | (x & 0x3333) << 2;\n  x = (x & 0xF0F0) >>> 4 | (x & 0x0F0F) << 4;\n  rev[i] = ((x & 0xFF00) >>> 8 | (x & 0x00FF) << 8) >>> 1;\n} // create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\n\n\nvar hMap = function hMap(cd, mb, r) {\n  var s = cd.length; // index\n\n  var i = 0; // u16 \"map\": index -> # of codes with bit length = index\n\n  var l = new u16(mb); // length of cd must be 288 (total # of codes)\n\n  for (; i < s; ++i) {\n    ++l[cd[i] - 1];\n  } // u16 \"map\": index -> minimum code for bit length = index\n\n\n  var le = new u16(mb);\n\n  for (i = 0; i < mb; ++i) {\n    le[i] = le[i - 1] + l[i - 1] << 1;\n  }\n\n  var co;\n\n  if (r) {\n    // u16 \"map\": index -> number of actual bits, symbol for code\n    co = new u16(1 << mb); // bits to remove for reverser\n\n    var rvb = 15 - mb;\n\n    for (i = 0; i < s; ++i) {\n      // ignore 0 lengths\n      if (cd[i]) {\n        // num encoding both symbol and bits read\n        var sv = i << 4 | cd[i]; // free bits\n\n        var _r = mb - cd[i]; // start value\n\n\n        var v = le[cd[i] - 1]++ << _r; // m is end value\n\n        for (var m = v | (1 << _r) - 1; v <= m; ++v) {\n          // every 16 bit value starting with the code yields the same result\n          co[rev[v] >>> rvb] = sv;\n        }\n      }\n    }\n  } else {\n    co = new u16(s);\n\n    for (i = 0; i < s; ++i) {\n      co[i] = rev[le[cd[i] - 1]++] >>> 15 - cd[i];\n    }\n  }\n\n  return co;\n}; // fixed length tree\n\n\nvar flt = new u8(288);\n\nfor (var _i2 = 0; _i2 < 144; ++_i2) {\n  flt[_i2] = 8;\n}\n\nfor (var _i3 = 144; _i3 < 256; ++_i3) {\n  flt[_i3] = 9;\n}\n\nfor (var _i4 = 256; _i4 < 280; ++_i4) {\n  flt[_i4] = 7;\n}\n\nfor (var _i5 = 280; _i5 < 288; ++_i5) {\n  flt[_i5] = 8;\n} // fixed distance tree\n\n\nvar fdt = new u8(32);\n\nfor (var _i6 = 0; _i6 < 32; ++_i6) {\n  fdt[_i6] = 5;\n} // fixed length map\n\n\nvar flrm = hMap(flt, 9, 1); // fixed distance map\n\nvar fdrm = hMap(fdt, 5, 1); // read d, starting at bit p and mask with m\n\nvar bits = function bits(d, p, m) {\n  var o = p >>> 3;\n  return (d[o] | d[o + 1] << 8) >>> (p & 7) & m;\n}; // read d, starting at bit p continuing for at least 16 bits\n\n\nvar bits16 = function bits16(d, p) {\n  var o = p >>> 3;\n  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >>> (p & 7);\n}; // get end of byte\n\n\nvar shft = function shft(p) {\n  return (p >>> 3) + (p & 7 && 1);\n}; // typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\n\n\nvar slc = function slc(v, s, e) {\n  if (s == null || s < 0) s = 0;\n  if (e == null || e > v.length) e = v.length; // can't use .constructor in case user-supplied\n\n  var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);\n  n.set(v.subarray(s, e));\n  return n;\n}; // find max of array\n\n\nvar max = function max(a) {\n  var m = a[0];\n\n  for (var _i7 = 1; _i7 < a.length; ++_i7) {\n    if (a[_i7] > m) m = a[_i7];\n  }\n\n  return m;\n}; // expands raw DEFLATE data\n\n\nvar inflt = function inflt(dat, buf, st) {\n  var noSt = !st || st.i;\n  if (!st) st = {}; // source length\n\n  var sl = dat.length; // have to estimate size\n\n  var noBuf = !buf || !noSt; // Assumes roughly 33% compression ratio average\n\n  if (!buf) buf = new u8(sl * 3); // ensure buffer can fit at least l elements\n\n  var cbuf = function cbuf(l) {\n    var bl = buf.length; // need to increase size to fit\n\n    if (l > bl) {\n      // Double or set to necessary, whichever is greater\n      var nbuf = new u8(Math.max(bl << 1, l));\n      nbuf.set(buf);\n      buf = nbuf;\n    }\n  }; //  last chunk         bitpos           bytes\n\n\n  var final = st.f || 0,\n      pos = st.p || 0,\n      bt = st.b || 0,\n      lm = st.l,\n      dm = st.d,\n      lbt = st.m,\n      dbt = st.n;\n  if (final && !lm) return buf; // total bits\n\n  var tbts = sl << 3;\n\n  do {\n    if (!lm) {\n      // BFINAL - this is only 1 when last chunk is next\n      st.f = final = bits(dat, pos, 1); // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n\n      var type = bits(dat, pos + 1, 3);\n      pos += 3;\n\n      if (!type) {\n        // go to end of byte boundary\n        var s = shft(pos) + 4,\n            l = dat[s - 4] | dat[s - 3] << 8,\n            t = s + l;\n\n        if (t > sl) {\n          if (noSt) throw 'unexpected EOF';\n          break;\n        } // ensure size\n\n\n        if (noBuf) cbuf(bt + l); // Copy over uncompressed data\n\n        buf.set(dat.subarray(s, t), bt); // Get new bitpos, update byte count\n\n        st.b = bt += l, st.p = pos = t << 3;\n        continue;\n      } else if (type == 1) lm = flrm, dm = fdrm, lbt = 9, dbt = 5;else if (type == 2) {\n        //  literal                            lengths\n        var hLit = bits(dat, pos, 31) + 257,\n            hcLen = bits(dat, pos + 10, 15) + 4;\n        var tl = hLit + bits(dat, pos + 5, 31) + 1;\n        pos += 14; // length+distance tree\n\n        var ldt = new u8(tl); // code length tree\n\n        var clt = new u8(19);\n\n        for (var _i8 = 0; _i8 < hcLen; ++_i8) {\n          // use index map to get real code\n          clt[clim[_i8]] = bits(dat, pos + _i8 * 3, 7);\n        }\n\n        pos += hcLen * 3; // code lengths bits\n\n        var clb = max(clt),\n            clbmsk = (1 << clb) - 1;\n        if (!noSt && pos + tl * (clb + 7) > tbts) break; // code lengths map\n\n        var clm = hMap(clt, clb, 1);\n\n        for (var _i9 = 0; _i9 < tl;) {\n          var r = clm[bits(dat, pos, clbmsk)]; // bits read\n\n          pos += r & 15; // symbol\n\n          var _s = r >>> 4; // code length to copy\n\n\n          if (_s < 16) {\n            ldt[_i9++] = _s;\n          } else {\n            //  copy   count\n            var c = 0,\n                n = 0;\n            if (_s == 16) n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[_i9 - 1];else if (_s == 17) n = 3 + bits(dat, pos, 7), pos += 3;else if (_s == 18) n = 11 + bits(dat, pos, 127), pos += 7;\n\n            while (n--) {\n              ldt[_i9++] = c;\n            }\n          }\n        } //    length tree                 distance tree\n\n\n        var lt = ldt.subarray(0, hLit),\n            dt = ldt.subarray(hLit); // max length bits\n\n        lbt = max(lt); // max dist bits\n\n        dbt = max(dt);\n        lm = hMap(lt, lbt, 1);\n        dm = hMap(dt, dbt, 1);\n      } else throw 'invalid block type';\n\n      if (pos > tbts) throw 'unexpected EOF';\n    } // Make sure the buffer can hold this + the largest possible addition\n    // maximum chunk size (practically, theoretically infinite) is 2^17;\n\n\n    if (noBuf) cbuf(bt + 131072);\n    var lms = (1 << lbt) - 1,\n        dms = (1 << dbt) - 1;\n    var mxa = lbt + dbt + 18;\n\n    while (noSt || pos + mxa < tbts) {\n      // bits read, code\n      var _c = lm[bits16(dat, pos) & lms],\n          sym = _c >>> 4;\n      pos += _c & 15;\n      if (pos > tbts) throw 'unexpected EOF';\n      if (!_c) throw 'invalid length/literal';\n      if (sym < 256) buf[bt++] = sym;else if (sym == 256) {\n        lm = undefined;\n        break;\n      } else {\n        var add = sym - 254; // no extra bits needed if less\n\n        if (sym > 264) {\n          // index\n          var _i10 = sym - 257,\n              b = fleb[_i10];\n\n          add = bits(dat, pos, (1 << b) - 1) + fl[_i10];\n          pos += b;\n        } // dist\n\n\n        var d = dm[bits16(dat, pos) & dms],\n            dsym = d >>> 4;\n        if (!d) throw 'invalid distance';\n        pos += d & 15;\n        var _dt = fd[dsym];\n\n        if (dsym > 3) {\n          var _b = fdeb[dsym];\n          _dt += bits16(dat, pos) & (1 << _b) - 1, pos += _b;\n        }\n\n        if (pos > tbts) throw 'unexpected EOF';\n        if (noBuf) cbuf(bt + 131072);\n        var end = bt + add;\n\n        for (; bt < end; bt += 4) {\n          buf[bt] = buf[bt - _dt];\n          buf[bt + 1] = buf[bt + 1 - _dt];\n          buf[bt + 2] = buf[bt + 2 - _dt];\n          buf[bt + 3] = buf[bt + 3 - _dt];\n        }\n\n        bt = end;\n      }\n    }\n\n    st.l = lm, st.p = pos, st.b = bt;\n    if (lm) final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n  } while (!final);\n\n  return bt == buf.length ? buf : slc(buf, 0, bt);\n}; // zlib valid\n\n\nvar zlv = function zlv(d) {\n  if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31) throw 'invalid zlib data';\n  if (d[1] & 32) throw 'invalid zlib data: preset dictionaries not supported';\n};\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\n\n\nexport function unzlibSync(data, out) {\n  return inflt((zlv(data), data.subarray(2, -4)), out);\n}","map":null,"metadata":{},"sourceType":"module"}
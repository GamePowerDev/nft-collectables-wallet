{"ast":null,"code":"import _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { isFunction, stringToHex } from '@polkadot/util';\nimport { combineLatest, of } from '@polkadot/x-rxjs';\nimport { map, switchMap } from '@polkadot/x-rxjs/operators';\nimport { memo } from \"../util/index.js\";\nvar DEMOCRACY_ID = stringToHex('democrac');\n\nfunction queryQueue(api) {\n  return api.query.democracy.dispatchQueue().pipe(switchMap(function (dispatches) {\n    return combineLatest([of(dispatches), api.derive.democracy.preimages(dispatches.map(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          hash = _ref2[1];\n\n      return hash;\n    }))]);\n  }), map(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        dispatches = _ref4[0],\n        images = _ref4[1];\n\n    return dispatches.map(function (_ref5, dispatchIndex) {\n      var _ref6 = _slicedToArray(_ref5, 3),\n          at = _ref6[0],\n          imageHash = _ref6[1],\n          index = _ref6[2];\n\n      return {\n        at: at,\n        image: images[dispatchIndex],\n        imageHash: imageHash,\n        index: index\n      };\n    });\n  }));\n}\n\nfunction schedulerEntries(api) {\n  // We don't get entries, but rather we get the keys (triggered via finished referendums) and\n  // the subscribe to those keys - this means we pickup when the schedulers actually executes\n  // at a block, the entry for that block will become empty\n  return api.derive.democracy.referendumsFinished().pipe(switchMap(function () {\n    return api.query.scheduler.agenda.keys();\n  }), switchMap(function (keys) {\n    var blockNumbers = keys.map(function (_ref7) {\n      var _ref7$args = _slicedToArray(_ref7.args, 1),\n          blockNumber = _ref7$args[0];\n\n      return blockNumber;\n    });\n    return combineLatest([of(blockNumbers), api.query.scheduler.agenda.multi(blockNumbers)]);\n  }));\n}\n\nfunction queryScheduler(api) {\n  return schedulerEntries(api).pipe(switchMap(function (_ref8) {\n    var _ref9 = _slicedToArray(_ref8, 2),\n        blockNumbers = _ref9[0],\n        agendas = _ref9[1];\n\n    var result = [];\n    blockNumbers.forEach(function (at, index) {\n      agendas[index].filter(function (optScheduled) {\n        return optScheduled.isSome;\n      }).forEach(function (optScheduled) {\n        var scheduled = optScheduled.unwrap();\n\n        if (scheduled.maybeId.isSome) {\n          var id = scheduled.maybeId.unwrap().toHex();\n\n          if (id.startsWith(DEMOCRACY_ID)) {\n            var _api$registry$createT = api.registry.createType('(u64, ReferendumIndex)', id),\n                _api$registry$createT2 = _slicedToArray(_api$registry$createT, 2),\n                _index = _api$registry$createT2[1];\n\n            var imageHash = scheduled.call.args[0];\n            result.push({\n              at: at,\n              imageHash: imageHash,\n              index: _index\n            });\n          }\n        }\n      });\n    });\n    return combineLatest([of(result), api.derive.democracy.preimages(result.map(function (_ref10) {\n      var imageHash = _ref10.imageHash;\n      return imageHash;\n    }))]);\n  }), map(function (_ref11) {\n    var _ref12 = _slicedToArray(_ref11, 2),\n        infos = _ref12[0],\n        images = _ref12[1];\n\n    return infos.map(function (info, index) {\n      return _objectSpread(_objectSpread({}, info), {}, {\n        image: images[index]\n      });\n    });\n  }));\n}\n\nexport function dispatchQueue(instanceId, api) {\n  return memo(instanceId, function () {\n    var _api$query$scheduler;\n\n    return isFunction((_api$query$scheduler = api.query.scheduler) === null || _api$query$scheduler === void 0 ? void 0 : _api$query$scheduler.agenda) ? queryScheduler(api) : api.query.democracy.dispatchQueue ? queryQueue(api) : of([]);\n  });\n}","map":null,"metadata":{},"sourceType":"module"}
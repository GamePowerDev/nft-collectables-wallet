{"ast":null,"code":"import _classCallCheck from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _toConsumableArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _toArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toArray\";\nimport _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isFunction, isString, isU8a } from '@polkadot/util';\nimport { Bytes } from \"./Bytes.js\";\nvar HASHER_MAP = {\n  // opaque\n  Blake2_128: [16, false],\n  // eslint-disable-line camelcase\n  Blake2_128Concat: [16, true],\n  // eslint-disable-line camelcase\n  Blake2_256: [32, false],\n  // eslint-disable-line camelcase\n  Identity: [0, true],\n  Twox128: [16, false],\n  Twox256: [32, false],\n  Twox64Concat: [8, true]\n};\n\nfunction getStorageType(type) {\n  if (type.isPlain) {\n    return [false, type.asPlain.toString()];\n  } else if (type.isDoubleMap) {\n    return [false, type.asDoubleMap.value.toString()];\n  }\n\n  return [false, type.asMap.value.toString()];\n} // we unwrap the type here, turning into an output usable for createType\n\n/** @internal */\n\n\nexport function unwrapStorageType(type, isOptional) {\n  var _getStorageType = getStorageType(type),\n      _getStorageType2 = _slicedToArray(_getStorageType, 2),\n      hasWrapper = _getStorageType2[0],\n      outputType = _getStorageType2[1];\n\n  return isOptional && !hasWrapper ? \"Option<\".concat(outputType, \">\") : outputType;\n}\n/** @internal */\n\nfunction decodeStorageKey(value) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  if (value instanceof StorageKey) {\n    return {\n      key: value,\n      method: value.method,\n      section: value.section\n    };\n  } else if (!value || isString(value) || isU8a(value)) {\n    // let Bytes handle these inputs\n    return {\n      key: value\n    };\n  } else if (isFunction(value)) {\n    return {\n      key: value(),\n      method: value.method,\n      section: value.section\n    };\n  } else if (Array.isArray(value)) {\n    var _value = _toArray(value),\n        fn = _value[0],\n        arg = _value.slice(1);\n\n    assert(isFunction(fn), 'Expected function input for key construction');\n    return {\n      key: fn.apply(void 0, _toConsumableArray(arg)),\n      method: fn.method,\n      section: fn.section\n    };\n  }\n\n  throw new Error(\"Unable to convert input \".concat(value, \" to StorageKey\"));\n}\n/** @internal */\n\n\nfunction decodeHashers(registry, value, hashers) {\n  // the storage entry is xxhashAsU8a(prefix, 128) + xxhashAsU8a(method, 128), 256 bits total\n  var offset = 32;\n  return hashers.reduce(function (result, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        hasher = _ref2[0],\n        type = _ref2[1];\n\n    var _HASHER_MAP$hasher$ty = _slicedToArray(HASHER_MAP[hasher.type], 2),\n        hashLen = _HASHER_MAP$hasher$ty[0],\n        canDecode = _HASHER_MAP$hasher$ty[1];\n\n    var decoded = canDecode ? registry.createType(type, value.subarray(offset + hashLen)) : registry.createType('Raw', value.subarray(offset, offset + hashLen));\n    offset += hashLen + (canDecode ? decoded.encodedLength : 0);\n    result.push(decoded);\n    return result;\n  }, []);\n}\n/** @internal */\n\n\nfunction decodeArgsFromMeta(registry, value, meta) {\n  if (!meta || !(meta.type.isDoubleMap || meta.type.isMap)) {\n    return [];\n  }\n\n  if (meta.type.isMap) {\n    var _mapInfo = meta.type.asMap;\n    return decodeHashers(registry, value, [[_mapInfo.hasher, _mapInfo.key.toString()]]);\n  }\n\n  var mapInfo = meta.type.asDoubleMap;\n  return decodeHashers(registry, value, [[mapInfo.hasher, mapInfo.key1.toString()], [mapInfo.key2Hasher, mapInfo.key2.toString()]]);\n}\n/** @internal */\n\n\nfunction getMeta(value) {\n  if (value instanceof StorageKey) {\n    return value.meta;\n  } else if (isFunction(value)) {\n    return value.meta;\n  } else if (Array.isArray(value)) {\n    var _value2 = _slicedToArray(value, 1),\n        fn = _value2[0];\n\n    return fn.meta;\n  }\n\n  return undefined;\n}\n/** @internal */\n\n\nfunction getType(value) {\n  if (value instanceof StorageKey) {\n    return value.outputType;\n  } else if (isFunction(value)) {\n    return unwrapStorageType(value.meta.type);\n  } else if (Array.isArray(value)) {\n    var _value3 = _slicedToArray(value, 1),\n        fn = _value3[0];\n\n    if (fn.meta) {\n      return unwrapStorageType(fn.meta.type);\n    }\n  } // If we have no type set, default to Raw\n\n\n  return 'Raw';\n}\n/**\n * @name StorageKey\n * @description\n * A representation of a storage key (typically hashed) in the system. It can be\n * constructed by passing in a raw key or a StorageEntry with (optional) arguments.\n */\n\n\nexport var StorageKey = /*#__PURE__*/function (_Bytes) {\n  _inherits(StorageKey, _Bytes);\n\n  var _super = _createSuper(StorageKey);\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore This is assigned via this.decodeArgsFromMeta()\n  function StorageKey(registry, value) {\n    var _this;\n\n    var override = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, StorageKey);\n\n    var _decodeStorageKey = decodeStorageKey(value),\n        key = _decodeStorageKey.key,\n        method = _decodeStorageKey.method,\n        section = _decodeStorageKey.section;\n\n    _this = _super.call(this, registry, key);\n    _this._args = void 0;\n    _this._meta = void 0;\n    _this._outputType = void 0;\n    _this._method = void 0;\n    _this._section = void 0;\n    _this._outputType = getType(value); // decode the args (as applicable based on the key and the hashers, after all init)\n\n    _this.setMeta(getMeta(value), override.section || section, override.method || method);\n\n    return _this;\n  }\n  /**\n   * @description Return the decoded arguments (applicable to map/doublemap with decodable values)\n   */\n\n\n  _createClass(StorageKey, [{\n    key: \"args\",\n    get: function get() {\n      return this._args;\n    }\n    /**\n     * @description The metadata or `undefined` when not available\n     */\n\n  }, {\n    key: \"meta\",\n    get: function get() {\n      return this._meta;\n    }\n    /**\n     * @description The key method or `undefined` when not specified\n     */\n\n  }, {\n    key: \"method\",\n    get: function get() {\n      return this._method;\n    }\n    /**\n     * @description The output type\n     */\n\n  }, {\n    key: \"outputType\",\n    get: function get() {\n      return this._outputType;\n    }\n    /**\n     * @description The key section or `undefined` when not specified\n     */\n\n  }, {\n    key: \"section\",\n    get: function get() {\n      return this._section;\n    }\n  }, {\n    key: \"is\",\n    value: function is(key) {\n      return key.section === this.section && key.method === this.method;\n    }\n    /**\n     * @description Sets the meta for this key\n     */\n\n  }, {\n    key: \"setMeta\",\n    value: function setMeta(meta, section, method) {\n      this._meta = meta;\n      this._method = method || this._method;\n      this._section = section || this._section;\n\n      if (meta) {\n        this._outputType = unwrapStorageType(meta.type);\n      }\n\n      try {\n        this._args = decodeArgsFromMeta(this.registry, this.toU8a(true), this.meta);\n      } catch (error) {// ignore...\n      }\n\n      return this;\n    }\n    /**\n     * @description Returns the Human representation for this type\n     */\n\n  }, {\n    key: \"toHuman\",\n    value: function toHuman() {\n      return this._args.length ? this._args.map(function (arg) {\n        return arg.toHuman();\n      }) : _get(_getPrototypeOf(StorageKey.prototype), \"toHuman\", this).call(this);\n    }\n    /**\n     * @description Returns the raw type for this\n     */\n\n  }, {\n    key: \"toRawType\",\n    value: function toRawType() {\n      return 'StorageKey';\n    }\n  }]);\n\n  return StorageKey;\n}(Bytes);","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/keyring authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { assert, u8aConcat, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { blake2AsU8a, ethereumEncode, keccakAsU8a, keyExtractPath, keyFromPath, naclKeypairFromSeed as naclFromSeed, naclSign, schnorrkelKeypairFromSeed as schnorrkelFromSeed, schnorrkelSign, schnorrkelVrfSign, schnorrkelVrfVerify, secp256k1Compress, secp256k1Expand, secp256k1KeypairFromSeed as secp256k1FromSeed, secp256k1Sign, signatureVerify } from '@polkadot/util-crypto';\nimport { decodePair } from \"./decode.js\";\nimport { encodePair } from \"./encode.js\";\nimport { pairToJson } from \"./toJson.js\";\nvar SIG_TYPE_NONE = new Uint8Array();\nvar TYPE_FROM_SEED = {\n  ecdsa: secp256k1FromSeed,\n  ed25519: naclFromSeed,\n  ethereum: secp256k1FromSeed,\n  sr25519: schnorrkelFromSeed\n};\nvar TYPE_PREFIX = {\n  ecdsa: new Uint8Array([2]),\n  ed25519: new Uint8Array([0]),\n  ethereum: new Uint8Array([2]),\n  sr25519: new Uint8Array([1])\n};\nvar TYPE_SIGNATURE = {\n  ecdsa: function ecdsa(m, p) {\n    return secp256k1Sign(m, p, 'blake2');\n  },\n  ed25519: naclSign,\n  ethereum: function ethereum(m, p) {\n    return secp256k1Sign(m, p, 'keccak');\n  },\n  sr25519: schnorrkelSign\n};\nvar TYPE_ADDRESS = {\n  ecdsa: function ecdsa(p) {\n    return p.length > 32 ? blake2AsU8a(p) : p;\n  },\n  ed25519: function ed25519(p) {\n    return p;\n  },\n  ethereum: function ethereum(p) {\n    return keccakAsU8a(secp256k1Expand(p));\n  },\n  sr25519: function sr25519(p) {\n    return p;\n  }\n}; // Not 100% correct, since it can be a Uint8Array, but an invalid one - just say \"undefined\" is anything non-valid\n\nfunction isLocked(secretKey) {\n  return !secretKey || secretKey.length === 0 || secretKey.every(function (b) {\n    return b === 0;\n  });\n}\n\nfunction vrfHash(proof, context, extra) {\n  return blake2AsU8a(u8aConcat(context || '', extra || '', proof));\n}\n/**\n * @name createPair\n * @summary Creates a keyring pair object\n * @description Creates a keyring pair object with provided account public key, metadata, and encoded arguments.\n * The keyring pair stores the account state including the encoded address and associated metadata.\n *\n * It has properties whose values are functions that may be called to perform account actions:\n *\n * - `address` function retrieves the address associated with the account.\n * - `decodedPkcs8` function is called with the account passphrase and account encoded public key.\n * It decodes the encoded public key using the passphrase provided to obtain the decoded account public key\n * and associated secret key that are then available in memory, and changes the account address stored in the\n * state of the pair to correspond to the address of the decoded public key.\n * - `encodePkcs8` function when provided with the correct passphrase associated with the account pair\n * and when the secret key is in memory (when the account pair is not locked) it returns an encoded\n * public key of the account.\n * - `meta` is the metadata that is stored in the state of the pair, either when it was originally\n * created or set via `setMeta`.\n * - `publicKey` returns the public key stored in memory for the pair.\n * - `sign` may be used to return a signature by signing a provided message with the secret\n * key (if it is in memory) using Nacl.\n * - `toJson` calls another `toJson` function and provides the state of the pair,\n * it generates arguments to be passed to the other `toJson` function including an encoded public key of the account\n * that it generates using the secret key from memory (if it has been made available in memory)\n * and the optionally provided passphrase argument. It passes a third boolean argument to `toJson`\n * indicating whether the public key has been encoded or not (if a passphrase argument was provided then it is encoded).\n * The `toJson` function that it calls returns a JSON object with properties including the `address`\n * and `meta` that are assigned with the values stored in the corresponding state variables of the account pair,\n * an `encoded` property that is assigned with the encoded public key in hex format, and an `encoding`\n * property that indicates whether the public key value of the `encoded` property is encoded or not.\n */\n\n\nexport function createPair(_ref, _ref2) {\n  var toSS58 = _ref.toSS58,\n      type = _ref.type;\n  var publicKey = _ref2.publicKey,\n      secretKey = _ref2.secretKey;\n  var meta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var encoded = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var encTypes = arguments.length > 4 ? arguments[4] : undefined;\n\n  var decodePkcs8 = function decodePkcs8(passphrase, userEncoded) {\n    var decoded = decodePair(passphrase, userEncoded || encoded, encTypes);\n\n    if (decoded.secretKey.length === 64) {\n      publicKey = decoded.publicKey;\n      secretKey = decoded.secretKey;\n    } else {\n      var pair = TYPE_FROM_SEED[type](decoded.secretKey);\n      publicKey = pair.publicKey;\n      secretKey = pair.secretKey;\n    }\n  };\n\n  var recode = function recode(passphrase) {\n    isLocked(secretKey) && encoded && decodePkcs8(passphrase, encoded);\n    encoded = encodePair({\n      publicKey: publicKey,\n      secretKey: secretKey\n    }, passphrase); // re-encode, latest version\n\n    encTypes = undefined; // swap to defaults, latest version follows\n\n    return encoded;\n  };\n\n  var encodeAddress = function encodeAddress() {\n    var raw = TYPE_ADDRESS[type](publicKey);\n    return type === 'ethereum' ? ethereumEncode(raw) : toSS58(raw);\n  };\n\n  return {\n    get address() {\n      return encodeAddress();\n    },\n\n    get addressRaw() {\n      var raw = TYPE_ADDRESS[type](publicKey);\n      return type === 'ethereum' ? raw.slice(-20) : raw;\n    },\n\n    get isLocked() {\n      return isLocked(secretKey);\n    },\n\n    get meta() {\n      return meta;\n    },\n\n    get publicKey() {\n      return publicKey;\n    },\n\n    get type() {\n      return type;\n    },\n\n    // eslint-disable-next-line sort-keys\n    decodePkcs8: decodePkcs8,\n    derive: function derive(suri, meta) {\n      assert(type !== 'ethereum', 'Unable to derive on this keypair');\n      assert(!isLocked(secretKey), 'Cannot derive on a locked keypair');\n\n      var _keyExtractPath = keyExtractPath(suri),\n          path = _keyExtractPath.path;\n\n      var derived = keyFromPath({\n        publicKey: publicKey,\n        secretKey: secretKey\n      }, path, type);\n      return createPair({\n        toSS58: toSS58,\n        type: type\n      }, derived, meta, null);\n    },\n    encodePkcs8: function encodePkcs8(passphrase) {\n      return recode(passphrase);\n    },\n    lock: function lock() {\n      secretKey = new Uint8Array();\n    },\n    setMeta: function setMeta(additional) {\n      meta = _objectSpread(_objectSpread({}, meta), additional);\n    },\n    sign: function sign(message) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      assert(!isLocked(secretKey), 'Cannot sign with a locked key pair');\n      return u8aConcat(options.withType ? TYPE_PREFIX[type] : SIG_TYPE_NONE, TYPE_SIGNATURE[type](u8aToU8a(message), {\n        publicKey: publicKey,\n        secretKey: secretKey\n      }));\n    },\n    toJson: function toJson(passphrase) {\n      // NOTE: For ecdsa and ethereum, the publicKey cannot be extracted from the address. For these\n      // pass the hex-encoded publicKey through to the address portion of the JSON (before decoding)\n      var address = ['ecdsa', 'ethereum'].includes(type) ? u8aToHex(secp256k1Compress(publicKey)) : encodeAddress();\n      return pairToJson(type, {\n        address: address,\n        meta: meta\n      }, recode(passphrase), !!passphrase);\n    },\n    unlock: function unlock(passphrase) {\n      return decodePkcs8(passphrase);\n    },\n    verify: function verify(message, signature, _signerPublic) {\n      return signatureVerify(message, signature, TYPE_ADDRESS[type](u8aToU8a(_signerPublic))).isValid;\n    },\n    vrfSign: function vrfSign(message, context, extra) {\n      assert(!isLocked(secretKey), 'Cannot sign with a locked key pair');\n\n      if (type === 'sr25519') {\n        return schnorrkelVrfSign(message, {\n          secretKey: secretKey\n        }, context, extra);\n      }\n\n      var proof = TYPE_SIGNATURE[type](u8aToU8a(message), {\n        publicKey: publicKey,\n        secretKey: secretKey\n      });\n      return u8aConcat(vrfHash(proof, context, extra), proof);\n    },\n    vrfVerify: function vrfVerify(message, vrfResult, _signerPublic, context, extra) {\n      var signerPublic = TYPE_ADDRESS[type](u8aToU8a(_signerPublic));\n\n      if (type === 'sr25519') {\n        return schnorrkelVrfVerify(message, vrfResult, publicKey, context, extra);\n      }\n\n      var result = signatureVerify(message, u8aConcat(TYPE_PREFIX[type], vrfResult.subarray(32)), signerPublic);\n      return result.isValid && u8aEq(vrfResult.subarray(0, 32), vrfHash(vrfResult.subarray(32), context, extra));\n    }\n  };\n}","map":null,"metadata":{},"sourceType":"module"}
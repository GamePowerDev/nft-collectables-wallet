{"ast":null,"code":"import _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createClass from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _inherits from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, bnToBn, formatNumber, hexToU8a, isHex, isObject, isU8a, u8aToBn, u8aToU8a } from '@polkadot/util';\nimport { Enum } from \"../codec/Enum.js\";\nimport { Raw } from \"../codec/Raw.js\";\nimport { Tuple } from \"../codec/Tuple.js\";\nimport { u64 as U64 } from \"../primitive/U64.js\";\nimport { IMMORTAL_ERA } from \"./constants.js\";\n\nfunction getTrailingZeros(period) {\n  var binary = period.toString(2);\n  var index = 0;\n\n  while (binary[binary.length - 1 - index] === '0') {\n    index++;\n  }\n\n  return index;\n}\n/**\n * @name ImmortalEra\n * @description\n * The ImmortalEra for an extrinsic\n */\n\n\nexport var ImmortalEra = /*#__PURE__*/function (_Raw) {\n  _inherits(ImmortalEra, _Raw);\n\n  var _super = _createSuper(ImmortalEra);\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  function ImmortalEra(registry, value) {\n    _classCallCheck(this, ImmortalEra);\n\n    // For immortals, we always provide the known value (i.e. treated as a\n    // constant no matter how it is constructed - it is a fixed structure)\n    return _super.call(this, registry, IMMORTAL_ERA);\n  }\n\n  return ImmortalEra;\n}(Raw);\n/**\n * @name MortalEra\n * @description\n * The MortalEra for an extrinsic, indicating period and phase\n */\n\nexport var MortalEra = /*#__PURE__*/function (_Tuple) {\n  _inherits(MortalEra, _Tuple);\n\n  var _super2 = _createSuper(MortalEra);\n\n  function MortalEra(registry, value) {\n    _classCallCheck(this, MortalEra);\n\n    return _super2.call(this, registry, {\n      period: U64,\n      phase: U64\n    }, MortalEra._decodeMortalEra(registry, value));\n  }\n  /** @internal */\n\n\n  _createClass(MortalEra, [{\n    key: \"encodedLength\",\n    get:\n    /**\n     * @description Encoded length for mortals occupy 2 bytes, different from the actual Tuple since it is encoded. This is a shortcut fro `toU8a().length`\n     */\n    function get() {\n      return 2;\n    }\n    /**\n     * @description The period of this Mortal wraps as a [[U64]]\n     */\n\n  }, {\n    key: \"period\",\n    get: function get() {\n      return this[0];\n    }\n    /**\n     * @description The phase of this Mortal wraps as a [[U64]]\n     */\n\n  }, {\n    key: \"phase\",\n    get: function get() {\n      return this[1];\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n\n  }, {\n    key: \"toHuman\",\n    value: function toHuman() {\n      return {\n        period: formatNumber(this.period),\n        phase: formatNumber(this.phase)\n      };\n    }\n    /**\n     * @description Returns a JSON representation of the actual value\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.toHex();\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the parity-codec specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     * Period and phase are encoded:\n     *   - The period of validity from the block hash found in the signing material.\n     *   - The phase in the period that this transaction's lifetime begins (and, importantly,\n     *     implies which block hash is included in the signature material). If the `period` is\n     *     greater than 1 << 12, then it will be a factor of the times greater than 1<<12 that\n     *     `period` is.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"toU8a\",\n    value: function toU8a(isBare) {\n      var period = this.period.toNumber();\n      var phase = this.phase.toNumber();\n      var quantizeFactor = Math.max(period >> 12, 1);\n      var trailingZeros = getTrailingZeros(period);\n      var encoded = Math.min(15, Math.max(1, trailingZeros - 1)) + (phase / quantizeFactor << 4);\n      var first = encoded >> 8;\n      var second = encoded & 0xff;\n      return new Uint8Array([second, first]);\n    }\n    /**\n     * @description Get the block number of the start of the era whose properties this object describes that `current` belongs to.\n     */\n\n  }, {\n    key: \"birth\",\n    value: function birth(current) {\n      // FIXME No toNumber() here\n      return Math.floor((Math.max(bnToBn(current).toNumber(), this.phase.toNumber()) - this.phase.toNumber()) / this.period.toNumber()) * this.period.toNumber() + this.phase.toNumber();\n    }\n    /**\n     * @description Get the block number of the first block at which the era has ended.\n     */\n\n  }, {\n    key: \"death\",\n    value: function death(current) {\n      // FIXME No toNumber() here\n      return this.birth(current) + this.period.toNumber();\n    }\n  }], [{\n    key: \"_decodeMortalEra\",\n    value: function _decodeMortalEra(registry, value) {\n      if (!value) {\n        return [new U64(registry), new U64(registry)];\n      } else if (isU8a(value) || isHex(value) || Array.isArray(value)) {\n        return MortalEra._decodeMortalU8a(registry, u8aToU8a(value));\n      } else if (isObject(value)) {\n        return MortalEra._decodeMortalObject(registry, value);\n      }\n\n      throw new Error('Invalid data passed to Mortal era');\n    }\n    /** @internal */\n\n  }, {\n    key: \"_decodeMortalObject\",\n    value: function _decodeMortalObject(registry, value) {\n      var current = value.current,\n          period = value.period;\n      var calPeriod = Math.pow(2, Math.ceil(Math.log2(period)));\n      calPeriod = Math.min(Math.max(calPeriod, 4), 1 << 16);\n      var phase = current % calPeriod;\n      var quantizeFactor = Math.max(calPeriod >> 12, 1);\n      var quantizedPhase = phase / quantizeFactor * quantizeFactor;\n      return [new U64(registry, calPeriod), new U64(registry, quantizedPhase)];\n    }\n    /** @internal */\n\n  }, {\n    key: \"_decodeMortalU8a\",\n    value: function _decodeMortalU8a(registry, value) {\n      if (value.length === 0) {\n        return [new U64(registry), new U64(registry)];\n      }\n\n      var first = u8aToBn(value.subarray(0, 1)).toNumber();\n      var second = u8aToBn(value.subarray(1, 2)).toNumber();\n      var encoded = first + (second << 8);\n      var period = 2 << encoded % (1 << 4);\n      var quantizeFactor = Math.max(period >> 12, 1);\n      var phase = (encoded >> 4) * quantizeFactor;\n      assert(period >= 4 && phase < period, 'Invalid data passed to Mortal era');\n      return [new U64(registry, period), new U64(registry, phase)];\n    }\n  }]);\n\n  return MortalEra;\n}(Tuple);\n/**\n * @name GenericExtrinsicEra\n * @description\n * The era for an extrinsic, indicating either a mortal or immortal extrinsic\n */\n\nexport var GenericExtrinsicEra = /*#__PURE__*/function (_Enum) {\n  _inherits(GenericExtrinsicEra, _Enum);\n\n  var _super3 = _createSuper(GenericExtrinsicEra);\n\n  function GenericExtrinsicEra(registry, value) {\n    _classCallCheck(this, GenericExtrinsicEra);\n\n    return _super3.call(this, registry, {\n      ImmortalEra: ImmortalEra,\n      MortalEra: MortalEra\n    }, GenericExtrinsicEra._decodeExtrinsicEra(value));\n  }\n  /** @internal */\n  // eslint-disable-next-line @typescript-eslint/ban-types\n\n\n  _createClass(GenericExtrinsicEra, [{\n    key: \"encodedLength\",\n    get:\n    /**\n     * @description Override the encoded length method\n     */\n    function get() {\n      return this.isImmortalEra ? this.asImmortalEra.encodedLength : this.asMortalEra.encodedLength;\n    }\n    /**\n     * @description Returns the item as a [[ImmortalEra]]\n     */\n\n  }, {\n    key: \"asImmortalEra\",\n    get: function get() {\n      assert(this.isImmortalEra, \"Cannot convert '\".concat(this.type, \"' via asImmortalEra\"));\n      return this.value;\n    }\n    /**\n     * @description Returns the item as a [[MortalEra]]\n     */\n\n  }, {\n    key: \"asMortalEra\",\n    get: function get() {\n      assert(this.isMortalEra, \"Cannot convert '\".concat(this.type, \"' via asMortalEra\"));\n      return this.value;\n    }\n    /**\n     * @description `true` if Immortal\n     */\n\n  }, {\n    key: \"isImmortalEra\",\n    get: function get() {\n      return this.index === 0;\n    }\n    /**\n     * @description `true` if Mortal\n     */\n\n  }, {\n    key: \"isMortalEra\",\n    get: function get() {\n      return this.index > 0;\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the parity-codec specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n\n  }, {\n    key: \"toU8a\",\n    value: function toU8a(isBare) {\n      return this.isMortalEra ? this.asMortalEra.toU8a(isBare) : this.asImmortalEra.toU8a(isBare);\n    }\n  }], [{\n    key: \"_decodeExtrinsicEra\",\n    value: function _decodeExtrinsicEra() {\n      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Uint8Array();\n\n      if (value instanceof GenericExtrinsicEra) {\n        return GenericExtrinsicEra._decodeExtrinsicEra(value.toU8a());\n      } else if (isHex(value)) {\n        return GenericExtrinsicEra._decodeExtrinsicEra(hexToU8a(value));\n      } else if (!value || isU8a(value)) {\n        return !(value !== null && value !== void 0 && value.length) || value[0] === 0 ? new Uint8Array([0]) : new Uint8Array([1, value[0], value[1]]);\n      } else if (isObject(value)) {\n        var entries = Object.entries(value).map(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              k = _ref2[0],\n              v = _ref2[1];\n\n          return [k.toLowerCase(), v];\n        });\n        var mortal = entries.find(function (_ref3) {\n          var _ref4 = _slicedToArray(_ref3, 1),\n              k = _ref4[0];\n\n          return k.toLowerCase() === 'mortalera';\n        });\n        var immortal = entries.find(function (_ref5) {\n          var _ref6 = _slicedToArray(_ref5, 1),\n              k = _ref6[0];\n\n          return k.toLowerCase() === 'immortalera';\n        }); // this is to de-serialize from JSON\n\n        return mortal ? {\n          MortalEra: mortal[1]\n        } : immortal ? {\n          ImmortalEra: immortal[1]\n        } : {\n          MortalEra: value\n        };\n      }\n\n      throw new Error('Invalid data passed to Era');\n    }\n  }]);\n\n  return GenericExtrinsicEra;\n}(Enum);","map":null,"metadata":{},"sourceType":"module"}
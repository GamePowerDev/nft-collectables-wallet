{"ast":null,"code":"import _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/metadata authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { getModuleTypes } from '@polkadot/types-known';\nimport { stringCamelCase } from '@polkadot/util'; // Since we don't have insight into the origin specification, we can only define what we know about\n// in a pure Substrate/Polkadot implementation, any other custom origins won't be handled at all\n\nvar KNOWN_ORIGINS = {\n  Council: 'CollectiveOrigin',\n  System: 'SystemOrigin',\n  TechnicalCommittee: 'CollectiveOrigin'\n};\n/**\n * Find and apply the correct type override\n * @internal\n **/\n\nfunction setTypeOverride(sectionTypes) {\n  for (var _len = arguments.length, types = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    types[_key - 1] = arguments[_key];\n  }\n\n  types.forEach(function (type) {\n    var override = Object.keys(sectionTypes).find(function (aliased) {\n      return type.eq(aliased);\n    });\n\n    if (override) {\n      type.setOverride(sectionTypes[override]);\n    } else {\n      // FIXME: NOT happy with this approach, but gets over the initial hump cased by (Vec<Announcement>,BalanceOf)\n      var orig = type.toString();\n      var alias = Object.entries(sectionTypes).reduce(function (result, _ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            from = _ref2[0],\n            to = _ref2[1];\n\n        return [['<', '>'], ['<', ','], [',', '>'], ['(', ')'], ['(', ','], [',', ','], [',', ')']].reduce(function (result, _ref3) {\n          var _ref4 = _slicedToArray(_ref3, 2),\n              one = _ref4[0],\n              two = _ref4[1];\n\n          return result.replace(\"\".concat(one).concat(from).concat(two), \"\".concat(one).concat(to).concat(two));\n        }, result);\n      }, orig);\n\n      if (orig !== alias) {\n        type.setOverride(alias);\n      }\n    }\n  });\n}\n/**\n * Apply module-specific type overrides (always be done as part of toLatest)\n * @internal\n **/\n\n\nfunction convertCalls(registry, calls, sectionTypes) {\n  return calls.map(function (c) {\n    c.args.forEach(function (_ref5) {\n      var type = _ref5.type;\n      return setTypeOverride(sectionTypes, type);\n    });\n    return registry.createType('FunctionMetadataLatest', c);\n  });\n}\n/**\n * Apply module-specific type overrides (always be done as part of toLatest)\n * @internal\n */\n\n\nfunction convertConstants(registry, constants, sectionTypes) {\n  return constants.map(function (c) {\n    setTypeOverride(sectionTypes, c.type);\n    return registry.createType('ModuleConstantMetadataLatest', c);\n  });\n}\n/**\n * Apply module-specific type overrides (always be done as part of toLatest)\n * @internal\n **/\n\n\nfunction convertEvents(registry, events, sectionTypes) {\n  return events.map(function (e) {\n    e.args.forEach(function (type) {\n      return setTypeOverride(sectionTypes, type);\n    });\n    return registry.createType('EventMetadataLatest', e);\n  });\n}\n/**\n * Apply module-specific storage type overrides (always part of toLatest)\n * @internal\n **/\n\n\nfunction convertStorage(registry, _ref6, sectionTypes) {\n  var items = _ref6.items,\n      prefix = _ref6.prefix;\n  return registry.createType('StorageMetadataLatest', {\n    items: items.map(function (s) {\n      if (s.type.isDoubleMap) {\n        setTypeOverride(sectionTypes, s.type.asDoubleMap.value, s.type.asDoubleMap.key1, s.type.asDoubleMap.key2);\n      } else if (s.type.isMap) {\n        setTypeOverride(sectionTypes, s.type.asMap.value, s.type.asMap.key);\n      } else {\n        setTypeOverride(sectionTypes, s.type.asPlain);\n      }\n\n      return registry.createType('StorageEntryMetadataLatest', s);\n    }),\n    prefix: prefix\n  });\n} // generate & register the OriginCaller type\n\n\nfunction registerOriginCaller(registry, modules, metaVersion) {\n  registry.register({\n    OriginCaller: {\n      _enum: modules.map(function (mod, index) {\n        return [mod.name.toString(), metaVersion >= 12 ? mod.index.toNumber() : index];\n      }).sort(function (a, b) {\n        return a[1] - b[1];\n      }).reduce(function (result, _ref7) {\n        var _ref8 = _slicedToArray(_ref7, 2),\n            name = _ref8[0],\n            index = _ref8[1];\n\n        for (var i = Object.keys(result).length; i < index; i++) {\n          result[\"Empty\".concat(i)] = 'Null';\n        }\n\n        result[name] = KNOWN_ORIGINS[name] || 'Null';\n        return result;\n      }, {})\n    }\n  });\n}\n/** @internal */\n\n\nfunction createModule(registry, mod, _ref9) {\n  var calls = _ref9.calls,\n      constants = _ref9.constants,\n      events = _ref9.events,\n      storage = _ref9.storage;\n  var sectionTypes = getModuleTypes(registry, stringCamelCase(mod.name));\n  return registry.createType('ModuleMetadataLatest', _objectSpread(_objectSpread({}, mod), {}, {\n    calls: calls && convertCalls(registry, calls, sectionTypes),\n    constants: convertConstants(registry, constants, sectionTypes),\n    events: events && convertEvents(registry, events, sectionTypes),\n    storage: storage && convertStorage(registry, storage, sectionTypes)\n  }));\n}\n/**\n * Convert the Metadata (which is an alias) to latest - effectively this _always_ get applied to the top-level &\n * most-recent metadata, since it allows us a chance to actually apply call and storage specific type aliasses\n * @internal\n **/\n\n\nexport function toLatest(registry, _ref10, metaVersion) {\n  var extrinsic = _ref10.extrinsic,\n      modules = _ref10.modules;\n  registerOriginCaller(registry, modules, metaVersion);\n  return registry.createType('MetadataLatest', {\n    extrinsic: extrinsic,\n    modules: modules.map(function (mod) {\n      return createModule(registry, mod, {\n        calls: mod.calls.unwrapOr(null),\n        constants: mod.constants,\n        events: mod.events.unwrapOr(null),\n        storage: mod.storage.unwrapOr(null)\n      });\n    })\n  });\n}","map":null,"metadata":{},"sourceType":"module"}
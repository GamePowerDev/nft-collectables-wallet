{"ast":null,"code":"import _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n// Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { isNumber, isUndefined } from '@polkadot/util';\nimport { combineLatest, of } from '@polkadot/x-rxjs';\nimport { map, switchMap } from '@polkadot/x-rxjs/operators';\nimport { FALLBACK_MAX_HASH_COUNT, FALLBACK_PERIOD, MAX_FINALITY_LAG, MORTAL_PERIOD } from \"./constants.js\";\n\nfunction latestNonce(api, address) {\n  return api.derive.balances.account(address).pipe(map(function (_ref) {\n    var accountNonce = _ref.accountNonce;\n    return accountNonce;\n  }));\n}\n\nfunction nextNonce(api, address) {\n  var _api$rpc$system;\n\n  return (_api$rpc$system = api.rpc.system) !== null && _api$rpc$system !== void 0 && _api$rpc$system.accountNextIndex ? api.rpc.system.accountNextIndex(address) : latestNonce(api, address);\n}\n\nfunction signingHeader(api) {\n  return combineLatest([api.rpc.chain.getHeader(), api.rpc.chain.getFinalizedHead()]).pipe(switchMap(function (_ref2) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n        bestHeader = _ref3[0],\n        finHash = _ref3[1];\n\n    return (// retrieve the headers - in the case of the current block, we use the parent\n      // to minimize (not completely remove) the impact that forks do have on the system\n      // (when at genesis, just return the current header as the last known)\n      bestHeader.parentHash.isEmpty ? of([bestHeader, bestHeader]) : combineLatest([api.rpc.chain.getHeader(bestHeader.parentHash), api.rpc.chain.getHeader(finHash)])\n    );\n  }), map(function (_ref4) {\n    var _ref5 = _slicedToArray(_ref4, 2),\n        current = _ref5[0],\n        finalized = _ref5[1];\n\n    return (// determine the hash to use, current when lag > max, else finalized\n      current.number.unwrap().sub(finalized.number.unwrap()).gt(MAX_FINALITY_LAG) ? current : finalized\n    );\n  }));\n}\n\nexport function signingInfo(_instanceId, api) {\n  // no memo, we want to do this fresh on each run\n  return function (address, nonce, era) {\n    return combineLatest([// retrieve nonce if none was specified\n    isUndefined(nonce) ? latestNonce(api, address) : nonce === -1 ? nextNonce(api, address) : of(api.registry.createType('Index', nonce)), // if no era (create) or era > 0 (mortal), do block retrieval\n    isUndefined(era) || isNumber(era) && era > 0 ? signingHeader(api) : of(null)]).pipe(map(function (_ref6) {\n      var _ref7 = _slicedToArray(_ref6, 2),\n          nonce = _ref7[0],\n          header = _ref7[1];\n\n      var _api$consts$system, _api$consts$system$bl, _api$consts$babe, _api$consts$timestamp;\n\n      return {\n        header: header,\n        mortalLength: Math.min(((_api$consts$system = api.consts.system) === null || _api$consts$system === void 0 ? void 0 : (_api$consts$system$bl = _api$consts$system.blockHashCount) === null || _api$consts$system$bl === void 0 ? void 0 : _api$consts$system$bl.toNumber()) || FALLBACK_MAX_HASH_COUNT, MORTAL_PERIOD.div(((_api$consts$babe = api.consts.babe) === null || _api$consts$babe === void 0 ? void 0 : _api$consts$babe.expectedBlockTime) || ((_api$consts$timestamp = api.consts.timestamp) === null || _api$consts$timestamp === void 0 ? void 0 : _api$consts$timestamp.minimumPeriod.muln(2)) || FALLBACK_PERIOD).iadd(MAX_FINALITY_LAG).toNumber()),\n        nonce: nonce\n      };\n    }));\n  };\n}","map":null,"metadata":{},"sourceType":"module"}
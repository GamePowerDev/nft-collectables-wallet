{"ast":null,"code":"import _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n// Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { map, switchMap } from '@polkadot/x-rxjs/operators';\nimport { memo } from \"../util/index.js\";\nexport function _stakerExposures(instanceId, api) {\n  return memo(instanceId, function (accountIds, eras, withActive) {\n    var stakerIds = accountIds.map(function (a) {\n      return api.registry.createType('AccountId', a).toString();\n    });\n    return api.derive.staking._erasExposure(eras, withActive).pipe(map(function (exposures) {\n      return stakerIds.map(function (stakerId) {\n        return exposures.map(function (_ref) {\n          var era = _ref.era,\n              allNominators = _ref.nominators,\n              allValidators = _ref.validators;\n          var isValidator = !!allValidators[stakerId];\n          var validators = {};\n          var nominating = allNominators[stakerId] || [];\n\n          if (isValidator) {\n            validators[stakerId] = allValidators[stakerId];\n          } else if (nominating) {\n            nominating.forEach(function (_ref2) {\n              var validatorId = _ref2.validatorId;\n              validators[validatorId] = allValidators[validatorId];\n            });\n          }\n\n          return {\n            era: era,\n            isEmpty: !Object.keys(validators).length,\n            isValidator: isValidator,\n            nominating: nominating,\n            validators: validators\n          };\n        });\n      });\n    }));\n  });\n}\nexport function stakerExposures(instanceId, api) {\n  return memo(instanceId, function (accountIds) {\n    var withActive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return api.derive.staking.erasHistoric(withActive).pipe(switchMap(function (eras) {\n      return api.derive.staking._stakerExposures(accountIds, eras, withActive);\n    }));\n  });\n}\nexport function stakerExposure(instanceId, api) {\n  return memo(instanceId, function (accountId) {\n    var withActive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return api.derive.staking.stakerExposures([accountId, withActive]).pipe(map(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 1),\n          first = _ref4[0];\n\n      return first;\n    }));\n  });\n}","map":null,"metadata":{},"sourceType":"module"}
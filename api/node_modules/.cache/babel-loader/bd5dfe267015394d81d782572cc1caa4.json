{"ast":null,"code":"import _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n// Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { BN_ZERO, isUndefined } from '@polkadot/util';\nimport { of } from '@polkadot/x-rxjs';\nimport { map, switchMap } from '@polkadot/x-rxjs/operators';\nimport { memo } from \"../util/index.js\";\nvar LOCKUPS = [0, 1, 2, 4, 8, 16, 32];\n\nfunction parseEnd(api, vote, _ref) {\n  var approved = _ref.approved,\n      end = _ref.end;\n  return [end, approved.isTrue && vote.isAye || approved.isFalse && vote.isNay ? end.add(api.consts.democracy.enactmentPeriod.muln(LOCKUPS[vote.conviction.index])) : BN_ZERO];\n}\n\nfunction parseLock(api, _ref2, referendum) {\n  var _ref3 = _slicedToArray(_ref2, 2),\n      referendumId = _ref3[0],\n      accountVote = _ref3[1];\n\n  var _accountVote$asStanda = accountVote.asStandard,\n      balance = _accountVote$asStanda.balance,\n      vote = _accountVote$asStanda.vote;\n\n  var _ref4 = referendum.isFinished ? parseEnd(api, vote, referendum.asFinished) : [BN_ZERO, BN_ZERO],\n      _ref5 = _slicedToArray(_ref4, 2),\n      referendumEnd = _ref5[0],\n      unlockAt = _ref5[1];\n\n  return {\n    balance: balance,\n    isDelegated: false,\n    isFinished: referendum.isFinished,\n    referendumEnd: referendumEnd,\n    referendumId: referendumId,\n    unlockAt: unlockAt,\n    vote: vote\n  };\n}\n\nfunction delegateLocks(api, _ref6) {\n  var balance = _ref6.balance,\n      conviction = _ref6.conviction,\n      target = _ref6.target;\n  return api.derive.democracy.locks(target).pipe(map(function (available) {\n    return available.map(function (_ref7) {\n      var isFinished = _ref7.isFinished,\n          referendumEnd = _ref7.referendumEnd,\n          referendumId = _ref7.referendumId,\n          unlockAt = _ref7.unlockAt,\n          vote = _ref7.vote;\n      return {\n        balance: balance,\n        isDelegated: true,\n        isFinished: isFinished,\n        referendumEnd: referendumEnd,\n        referendumId: referendumId,\n        unlockAt: unlockAt.isZero() ? unlockAt : referendumEnd.add(api.consts.democracy.enactmentPeriod.muln(LOCKUPS[conviction.index])),\n        vote: api.registry.createType('Vote', {\n          aye: vote.isAye,\n          conviction: conviction\n        })\n      };\n    });\n  }));\n}\n\nfunction directLocks(api, _ref8) {\n  var votes = _ref8.votes;\n\n  if (!votes.length) {\n    return of([]);\n  }\n\n  return api.query.democracy.referendumInfoOf.multi(votes.map(function (_ref9) {\n    var _ref10 = _slicedToArray(_ref9, 1),\n        referendumId = _ref10[0];\n\n    return referendumId;\n  })).pipe(map(function (referendums) {\n    return votes.map(function (vote, index) {\n      return [vote, referendums[index].unwrapOr(null)];\n    }).filter(function (item) {\n      return !!item[1] && isUndefined(item[1].end) && item[0][1].isStandard;\n    }).map(function (_ref11) {\n      var _ref12 = _slicedToArray(_ref11, 2),\n          directVote = _ref12[0],\n          referendum = _ref12[1];\n\n      return parseLock(api, directVote, referendum);\n    });\n  }));\n}\n\nexport function locks(instanceId, api) {\n  return memo(instanceId, function (accountId) {\n    return api.query.democracy.votingOf ? api.query.democracy.votingOf(accountId).pipe(switchMap(function (voting) {\n      return voting.isDirect ? directLocks(api, voting.asDirect) : voting.isDelegating ? delegateLocks(api, voting.asDelegating) : of([]);\n    })) : of([]);\n  });\n}","map":null,"metadata":{},"sourceType":"module"}
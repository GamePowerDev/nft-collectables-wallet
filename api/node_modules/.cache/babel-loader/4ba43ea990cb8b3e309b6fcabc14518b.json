{"ast":null,"code":"import _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/api authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport BN from 'bn.js';\nimport { decorateDerive } from '@polkadot/api-derive';\nimport { memo } from '@polkadot/api-derive/util';\nimport { expandMetadata } from '@polkadot/metadata';\nimport { RpcCore } from '@polkadot/rpc-core';\nimport { WsProvider } from '@polkadot/rpc-provider';\nimport { TypeRegistry } from '@polkadot/types/create';\nimport { DEFAULT_VERSION as EXTRINSIC_DEFAULT_VERSION } from '@polkadot/types/extrinsic/constants';\nimport { unwrapStorageType } from '@polkadot/types/primitive/StorageKey';\nimport { arrayChunk, arrayFlatten, assert, compactStripLength, logger, u8aToHex } from '@polkadot/util';\nimport { BehaviorSubject, combineLatest, of } from '@polkadot/x-rxjs';\nimport { map, switchMap, tap, toArray } from '@polkadot/x-rxjs/operators';\nimport { createSubmittable } from \"../submittable/index.js\";\nimport { augmentObject } from \"../util/augmentObject.js\";\nimport { decorateSections } from \"../util/decorate.js\";\nimport { extractStorageArgs } from \"../util/validate.js\";\nimport { Events } from \"./Events.js\"; // the max amount of keys/values that we will retrieve at once\n\nvar PAGE_SIZE = 384;\nvar l = logger('api/init');\nvar instanceCounter = 0;\n\nvar _instanceId = _classPrivateFieldLooseKey(\"instanceId\");\n\nvar _registry = _classPrivateFieldLooseKey(\"registry\");\n\nexport var Decorate = /*#__PURE__*/function (_Events) {\n  _inherits(Decorate, _Events);\n\n  var _super = _createSuper(Decorate);\n\n  // HACK Use BN import so decorateDerive works... yes, wtf.\n\n  /**\n   * This is the one and only method concrete children classes need to implement.\n   * It's a higher-order function, which takes one argument\n   * `method: Method extends (...args: any[]) => Observable<any>`\n   * (and one optional `options`), and should return the user facing method.\n   * For example:\n   * - For ApiRx, `decorateMethod` should just be identity, because the input\n   * function is already an Observable\n   * - For ApiPromise, `decorateMethod` should return a function that takes all\n   * the parameters from `method`, adds an optional `callback` argument, and\n   * returns a Promise.\n   *\n   * We could easily imagine other user-facing interfaces, which are simply\n   * implemented by transforming the Observable to Stream/Iterator/Kefir/Bacon\n   * via `decorateMethod`.\n   */\n\n  /**\n   * @description Create an instance of the class\n   *\n   * @param options Options object to create API instance or a Provider instance\n   *\n   * @example\n   * <BR>\n   *\n   * ```javascript\n   * import Api from '@polkadot/api/promise';\n   *\n   * const api = new Api().isReady();\n   *\n   * api.rpc.subscribeNewHeads((header) => {\n   *   console.log(`new block #${header.number.toNumber()}`);\n   * });\n   * ```\n   */\n  function Decorate(options, type, decorateMethod) {\n    var _this;\n\n    _classCallCheck(this, Decorate);\n\n    var _options$source;\n\n    _this = _super.call(this);\n    Object.defineProperty(_assertThisInitialized(_this), _instanceId, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _registry, {\n      writable: true,\n      value: void 0\n    });\n    _this.__phantom = new BN(0);\n    _this._consts = {};\n    _this._derive = void 0;\n    _this._errors = {};\n    _this._events = {};\n    _this._extrinsics = void 0;\n    _this._extrinsicType = EXTRINSIC_DEFAULT_VERSION;\n    _this._genesisHash = void 0;\n    _this._isConnected = void 0;\n    _this._isReady = false;\n    _this._options = void 0;\n    _this._query = {};\n    _this._queryMulti = void 0;\n    _this._rpc = void 0;\n    _this._rpcCore = void 0;\n    _this._runtimeChain = void 0;\n    _this._runtimeMetadata = void 0;\n    _this._runtimeVersion = void 0;\n    _this._rx = {\n      consts: {},\n      query: {},\n      tx: {}\n    };\n    _this._type = void 0;\n    _this._decorateMethod = void 0;\n\n    _this._rxDecorateMethod = function (method) {\n      return method;\n    };\n\n    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _instanceId)[_instanceId] = \"\".concat(++instanceCounter);\n    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _registry)[_registry] = ((_options$source = options.source) === null || _options$source === void 0 ? void 0 : _options$source.registry) || options.registry || new TypeRegistry();\n    _this._rx.registry = _classPrivateFieldLooseBase(_assertThisInitialized(_this), _registry)[_registry];\n    var thisProvider = options.source ? options.source._rpcCore.provider.clone() : options.provider || new WsProvider();\n    _this._decorateMethod = decorateMethod;\n    _this._options = options;\n    _this._type = type; // The RPC interface decorates the known interfaces on init\n\n    _this._rpcCore = new RpcCore(_classPrivateFieldLooseBase(_assertThisInitialized(_this), _instanceId)[_instanceId], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _registry)[_registry], thisProvider, _this._options.rpc);\n    _this._isConnected = new BehaviorSubject(_this._rpcCore.provider.isConnected);\n    _this._rx.hasSubscriptions = _this._rpcCore.provider.hasSubscriptions;\n    return _this;\n  }\n  /**\n   * @description Return the current used registry\n   */\n\n\n  _createClass(Decorate, [{\n    key: \"registry\",\n    get: function get() {\n      return _classPrivateFieldLooseBase(this, _registry)[_registry];\n    }\n    /**\n     * @description Creates an instance of a type as registered\n     */\n\n  }, {\n    key: \"createType\",\n    value: function createType(type) {\n      var _classPrivateFieldLoo;\n\n      for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        params[_key - 1] = arguments[_key];\n      }\n\n      return (_classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _registry)[_registry]).createType.apply(_classPrivateFieldLoo, [type].concat(params));\n    }\n    /**\n     * @description Register additional user-defined of chain-specific types in the type registry\n     */\n\n  }, {\n    key: \"registerTypes\",\n    value: function registerTypes(types) {\n      types && _classPrivateFieldLooseBase(this, _registry)[_registry].register(types);\n    }\n    /**\n     * @returns `true` if the API operates with subscriptions\n     */\n\n  }, {\n    key: \"hasSubscriptions\",\n    get: function get() {\n      return this._rpcCore.provider.hasSubscriptions;\n    }\n    /**\n     * @returns `true` if the API decorate multi-key queries\n     */\n\n  }, {\n    key: \"supportMulti\",\n    get: function get() {\n      return this._rpcCore.provider.hasSubscriptions || !!this._rpcCore.state.queryStorageAt;\n    }\n  }, {\n    key: \"injectMetadata\",\n    value: function injectMetadata(metadata, fromEmpty, registry) {\n      var decoratedMeta = expandMetadata(registry || _classPrivateFieldLooseBase(this, _registry)[_registry], metadata);\n\n      if (fromEmpty || !this._extrinsics) {\n        this._extrinsics = this._decorateExtrinsics(decoratedMeta, this._decorateMethod);\n        this._rx.tx = this._decorateExtrinsics(decoratedMeta, this._rxDecorateMethod);\n      } else {\n        augmentObject('tx', this._decorateExtrinsics(decoratedMeta, this._decorateMethod), this._extrinsics, false);\n        augmentObject(null, this._decorateExtrinsics(decoratedMeta, this._rxDecorateMethod), this._rx.tx, false);\n      } // this API\n\n\n      augmentObject('query', this._decorateStorage(decoratedMeta, this._decorateMethod), this._query, fromEmpty);\n      augmentObject('consts', decoratedMeta.consts, this._consts, fromEmpty);\n      augmentObject('errors', decoratedMeta.errors, this._errors, fromEmpty);\n      augmentObject('events', decoratedMeta.events, this._events, fromEmpty); // rx\n\n      augmentObject(null, this._decorateStorage(decoratedMeta, this._rxDecorateMethod), this._rx.query, fromEmpty);\n      augmentObject(null, decoratedMeta.consts, this._rx.consts, fromEmpty);\n    }\n  }, {\n    key: \"_decorateFunctionMeta\",\n    value: function _decorateFunctionMeta(input, output) {\n      output.meta = input.meta;\n      output.method = input.method;\n      output.section = input.section;\n      output.toJSON = input.toJSON;\n\n      if (input.callIndex) {\n        output.callIndex = input.callIndex;\n      }\n\n      return output;\n    } // Filter all RPC methods based on the results of the rpc_methods call. We do this in the following\n    // manner to cater for both old and new:\n    //   - when the number of entries are 0, only remove the ones with isOptional (account & contracts)\n    //   - when non-zero, remove anything that is not in the array (we don't do this)\n\n  }, {\n    key: \"_filterRpc\",\n    value: function _filterRpc(rpcMethods, additional) {\n      var methods = rpcMethods.methods.map(function (t) {\n        return t.toString();\n      }); // add any specific user-base RPCs\n\n      if (Object.keys(additional).length !== 0) {\n        this._rpcCore.addUserInterfaces(additional); // re-decorate, only adding any new additional interfaces\n\n\n        this._decorateRpc(this._rpcCore, this._decorateMethod, this._rpc);\n\n        this._decorateRpc(this._rpcCore, this._rxDecorateMethod, this._rx.rpc);\n      }\n\n      this._filterRpcMethods(methods);\n    }\n  }, {\n    key: \"_filterRpcMethods\",\n    value: function _filterRpcMethods(exposed) {\n      var _this2 = this;\n\n      var hasResults = exposed.length !== 0;\n\n      var allKnown = _toConsumableArray(this._rpcCore.mapping.entries());\n\n      var allKeys = allKnown.reduce(function (allKeys, _ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            _ref2$ = _ref2[1],\n            alias = _ref2$.alias,\n            endpoint = _ref2$.endpoint,\n            method = _ref2$.method,\n            pubsub = _ref2$.pubsub,\n            section = _ref2$.section;\n\n        allKeys.push(\"\".concat(section, \"_\").concat(method));\n\n        if (pubsub) {\n          allKeys.push(\"\".concat(section, \"_\").concat(pubsub[1]));\n          allKeys.push(\"\".concat(section, \"_\").concat(pubsub[2]));\n        }\n\n        if (alias) {\n          allKeys.push.apply(allKeys, _toConsumableArray(alias));\n        }\n\n        if (endpoint) {\n          allKeys.push(endpoint);\n        }\n\n        return allKeys;\n      }, []);\n      var unknown = exposed.filter(function (key) {\n        return !allKeys.includes(key);\n      });\n\n      if (unknown.length) {\n        l.warn(\"RPC methods not decorated: \".concat(unknown.join(', ')));\n      } // loop through all entries we have (populated in decorate) and filter as required\n      // only remove when we have results and method missing, or with no results if optional\n\n\n      allKnown.filter(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 1),\n            key = _ref4[0];\n\n        return hasResults ? !exposed.includes(key) && key !== 'rpc_methods' // rpc_methods doesn't appear, v1\n        : key === 'rpc_methods';\n      } // we didn't find this one, remove\n      ) // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      .forEach(function (_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n            _ = _ref6[0],\n            _ref6$ = _ref6[1],\n            method = _ref6$.method,\n            section = _ref6$.section;\n\n        delete _this2._rpc[section][method];\n        delete _this2._rpcCore[section][method];\n        delete _this2._rx.rpc[section][method];\n      });\n    }\n  }, {\n    key: \"_decorateRpc\",\n    value: function _decorateRpc(rpc, decorateMethod) {\n      var _this3 = this;\n\n      var input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return rpc.sections.reduce(function (out, _sectionName) {\n        var sectionName = _sectionName;\n\n        if (!out[sectionName]) {\n          // out and section here are horrors to get right from a typing perspective :(\n          out[sectionName] = Object.entries(rpc[sectionName]).reduce(function (section, _ref7) {\n            var _ref8 = _slicedToArray(_ref7, 2),\n                methodName = _ref8[0],\n                method = _ref8[1];\n\n            //  skip subscriptions where we have a non-subscribe interface\n            if (_this3.hasSubscriptions || !(methodName.startsWith('subscribe') || methodName.startsWith('unsubscribe'))) {\n              section[methodName] = decorateMethod(method, {\n                methodName: methodName\n              }); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n              section[methodName].json = decorateMethod(method.json, {\n                methodName: methodName\n              }); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n              section[methodName].raw = decorateMethod(method.raw, {\n                methodName: methodName\n              });\n            }\n\n            return section;\n          }, {});\n        }\n\n        return out;\n      }, input);\n    } // only be called if supportMulti is true\n\n  }, {\n    key: \"_decorateMulti\",\n    value: function _decorateMulti(decorateMethod) {\n      var _this4 = this;\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      return decorateMethod(function (calls) {\n        return (_this4.hasSubscriptions ? _this4._rpcCore.state.subscribeStorage : _this4._rpcCore.state.queryStorageAt)(calls.map(function (arg) {\n          return Array.isArray(arg) ? [arg[0].creator].concat(_toConsumableArray(arg.slice(1))) : [arg.creator];\n        }));\n      });\n    }\n  }, {\n    key: \"_decorateExtrinsics\",\n    value: function _decorateExtrinsics(_ref9, decorateMethod) {\n      var _this5 = this;\n\n      var tx = _ref9.tx;\n      var creator = createSubmittable(this._type, this._rx, decorateMethod);\n      return Object.entries(tx).reduce(function (out, _ref10) {\n        var _ref11 = _slicedToArray(_ref10, 2),\n            name = _ref11[0],\n            section = _ref11[1];\n\n        out[name] = Object.entries(section).reduce(function (out, _ref12) {\n          var _ref13 = _slicedToArray(_ref12, 2),\n              name = _ref13[0],\n              method = _ref13[1];\n\n          out[name] = _this5._decorateExtrinsicEntry(method, creator);\n          return out;\n        }, {});\n        return out;\n      }, creator);\n    }\n  }, {\n    key: \"_decorateExtrinsicEntry\",\n    value: function _decorateExtrinsicEntry(method, creator) {\n      var decorated = function decorated() {\n        return creator(method.apply(void 0, arguments));\n      }; // pass through the `.is`\n\n\n      decorated.is = function (other) {\n        return method.is(other);\n      }; // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n\n\n      return this._decorateFunctionMeta(method, decorated);\n    }\n  }, {\n    key: \"_decorateStorage\",\n    value: function _decorateStorage(_ref14, decorateMethod) {\n      var _this6 = this;\n\n      var query = _ref14.query;\n      return Object.entries(query).reduce(function (out, _ref15) {\n        var _ref16 = _slicedToArray(_ref15, 2),\n            name = _ref16[0],\n            section = _ref16[1];\n\n        out[name] = Object.entries(section).reduce(function (out, _ref17) {\n          var _ref18 = _slicedToArray(_ref17, 2),\n              name = _ref18[0],\n              method = _ref18[1];\n\n          out[name] = _this6._decorateStorageEntry(method, decorateMethod);\n          return out;\n        }, {});\n        return out;\n      }, {});\n    }\n  }, {\n    key: \"_decorateStorageEntry\",\n    value: function _decorateStorageEntry(creator, decorateMethod) {\n      var _this7 = this;\n\n      // get the storage arguments, with DoubleMap as an array entry, otherwise spread\n      var getArgs = function getArgs() {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        return extractStorageArgs(creator, args);\n      }; // Disable this where it occurs for each field we are decorating\n\n      /* eslint-disable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n\n\n      var decorated = this._decorateStorageCall(creator, decorateMethod);\n\n      decorated.creator = creator;\n      decorated.at = decorateMethod(function (hash, arg1, arg2) {\n        return _this7._rpcCore.state.getStorage(getArgs(arg1, arg2), hash);\n      });\n      decorated.hash = decorateMethod(function (arg1, arg2) {\n        return _this7._rpcCore.state.getStorageHash(getArgs(arg1, arg2));\n      });\n\n      decorated.is = function (key) {\n        return key.section === creator.section && key.method === creator.method;\n      };\n\n      decorated.key = function (arg1, arg2) {\n        return u8aToHex(compactStripLength(creator(creator.meta.type.isDoubleMap ? [arg1, arg2] : arg1))[1]);\n      };\n\n      decorated.keyPrefix = function (key1) {\n        return u8aToHex(creator.keyPrefix(key1));\n      };\n\n      decorated.range = decorateMethod(function (range, arg1, arg2) {\n        return _this7._decorateStorageRange(decorated, [arg1, arg2], range);\n      });\n      decorated.size = decorateMethod(function (arg1, arg2) {\n        return _this7._rpcCore.state.getStorageSize(getArgs(arg1, arg2));\n      });\n      decorated.sizeAt = decorateMethod(function (hash, arg1, arg2) {\n        return _this7._rpcCore.state.getStorageSize(getArgs(arg1, arg2), hash);\n      }); // .keys() & .entries() only available on map types\n\n      if (creator.iterKey && (creator.meta.type.isMap || creator.meta.type.isDoubleMap)) {\n        decorated.entries = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], function (doubleMapArg) {\n          return _this7._retrieveMapEntries(creator, null, doubleMapArg);\n        }));\n        decorated.entriesAt = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], function (hash, doubleMapArg) {\n          return _this7._retrieveMapEntries(creator, hash, doubleMapArg);\n        }));\n        decorated.entriesPaged = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], function (opts) {\n          return _this7._retrieveMapEntriesPaged(creator, opts);\n        }));\n        decorated.keys = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], function (doubleMapArg) {\n          return _this7._retrieveMapKeys(creator, null, doubleMapArg);\n        }));\n        decorated.keysAt = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], function (hash, doubleMapArg) {\n          return _this7._retrieveMapKeys(creator, hash, doubleMapArg);\n        }));\n        decorated.keysPaged = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], function (opts) {\n          return _this7._retrieveMapKeysPaged(creator, opts);\n        }));\n      }\n\n      if (this.supportMulti) {\n        // When using double map storage function, user need to pass double map key as an array\n        decorated.multi = decorateMethod(function (args) {\n          return _this7._retrieveMulti(args.map(function (arg) {\n            return [creator, arg];\n          }));\n        });\n      }\n      /* eslint-enable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n\n\n      return this._decorateFunctionMeta(creator, decorated);\n    } // Decorate the base storage call. In the case or rxjs or promise-without-callback (await)\n    // we make a subscription, alternatively we push this through a single-shot query\n\n  }, {\n    key: \"_decorateStorageCall\",\n    value: function _decorateStorageCall(creator, decorateMethod) {\n      var _this8 = this;\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      return decorateMethod(function () {\n        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n\n        return _this8.hasSubscriptions ? _this8._rpcCore.state.subscribeStorage([extractStorageArgs(creator, args)]).pipe(map(function (_ref19) {\n          var _ref20 = _slicedToArray(_ref19, 1),\n              data = _ref20[0];\n\n          return data;\n        }) // extract first/only result from list\n        ) : _this8._rpcCore.state.getStorage(extractStorageArgs(creator, args));\n      }, {\n        methodName: creator.method,\n        overrideNoSub: function overrideNoSub() {\n          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n            args[_key4] = arguments[_key4];\n          }\n\n          return _this8._rpcCore.state.getStorage(extractStorageArgs(creator, args));\n        }\n      });\n    }\n  }, {\n    key: \"_decorateStorageRange\",\n    value: function _decorateStorageRange(decorated, args, range) {\n      var _this$_rpcCore$state,\n          _this9 = this;\n\n      var outputType = unwrapStorageType(decorated.creator.meta.type, decorated.creator.meta.modifier.isOptional);\n      return (_this$_rpcCore$state = this._rpcCore.state).queryStorage.apply(_this$_rpcCore$state, [[decorated.key.apply(decorated, _toConsumableArray(args))]].concat(_toConsumableArray(range))).pipe(map(function (result) {\n        return result.map(function (_ref21) {\n          var _ref22 = _slicedToArray(_ref21, 2),\n              blockHash = _ref22[0],\n              _ref22$ = _slicedToArray(_ref22[1], 1),\n              value = _ref22$[0];\n\n          return [blockHash, _this9.createType(outputType, value.isSome ? value.unwrap().toHex() : undefined)];\n        });\n      }));\n    } // retrieve a set of values for a specific set of keys - here we chunk the keys into PAGE_SIZE sizes\n\n  }, {\n    key: \"_retrieveMulti\",\n    value: function _retrieveMulti(keys) {\n      var _this10 = this;\n\n      if (!keys.length) {\n        return of([]);\n      }\n\n      return combineLatest(arrayChunk(keys, PAGE_SIZE).map(function (keys) {\n        return (_this10.hasSubscriptions ? _this10._rpcCore.state.subscribeStorage : _this10._rpcCore.state.queryStorageAt)(keys);\n      })).pipe(map(function (valsArr) {\n        return arrayFlatten(valsArr);\n      }));\n    }\n  }, {\n    key: \"_retrieveMapKeys\",\n    value: function _retrieveMapKeys(_ref23, at, arg) {\n      var _this11 = this;\n\n      var iterKey = _ref23.iterKey,\n          meta = _ref23.meta,\n          method = _ref23.method,\n          section = _ref23.section;\n      assert(iterKey && (meta.type.isMap || meta.type.isDoubleMap), 'keys can only be retrieved on maps, linked maps and double maps');\n      var headKey = iterKey(arg).toHex();\n      var startSubject = new BehaviorSubject(headKey);\n      var query = at ? function (startKey) {\n        return _this11._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE, startKey, at);\n      } : function (startKey) {\n        return _this11._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE, startKey);\n      };\n      return startSubject.pipe(switchMap(function (startKey) {\n        return query(startKey).pipe(map(function (keys) {\n          return keys.map(function (key) {\n            return key.setMeta(meta, section, method);\n          });\n        }));\n      }), tap(function (keys) {\n        setTimeout(function () {\n          keys.length === PAGE_SIZE ? startSubject.next(keys[PAGE_SIZE - 1].toHex()) : startSubject.complete();\n        }, 0);\n      }), toArray(), // toArray since we want to startSubject to be completed\n      map(function (keysArr) {\n        return arrayFlatten(keysArr);\n      }));\n    }\n  }, {\n    key: \"_retrieveMapKeysPaged\",\n    value: function _retrieveMapKeysPaged(_ref24, opts) {\n      var iterKey = _ref24.iterKey,\n          meta = _ref24.meta,\n          method = _ref24.method,\n          section = _ref24.section;\n      assert(iterKey && (meta.type.isMap || meta.type.isDoubleMap), 'keys can only be retrieved on maps, linked maps and double maps');\n      var headKey = iterKey(opts.arg).toHex();\n      return this._rpcCore.state.getKeysPaged(headKey, opts.pageSize, opts.startKey || headKey).pipe(map(function (keys) {\n        return keys.map(function (key) {\n          return key.setMeta(meta, section, method);\n        });\n      }));\n    }\n  }, {\n    key: \"_retrieveMapEntries\",\n    value: function _retrieveMapEntries(entry, at, arg) {\n      var _this12 = this;\n\n      var query = at ? function (keyset) {\n        return _this12._rpcCore.state.queryStorageAt(keyset, at);\n      } : function (keyset) {\n        return _this12._rpcCore.state.queryStorageAt(keyset);\n      };\n      return this._retrieveMapKeys(entry, at, arg).pipe(switchMap(function (keys) {\n        return keys.length ? combineLatest(arrayChunk(keys, PAGE_SIZE).map(query)).pipe(map(function (valsArr) {\n          return arrayFlatten(valsArr).map(function (value, index) {\n            return [keys[index], value];\n          });\n        })) : of([]);\n      }));\n    }\n  }, {\n    key: \"_retrieveMapEntriesPaged\",\n    value: function _retrieveMapEntriesPaged(entry, opts) {\n      var _this13 = this;\n\n      return this._retrieveMapKeysPaged(entry, opts).pipe(switchMap(function (keys) {\n        return keys.length ? _this13._rpcCore.state.queryStorageAt(keys).pipe(map(function (valsArr) {\n          return valsArr.map(function (value, index) {\n            return [keys[index], value];\n          });\n        })) : of([]);\n      }));\n    }\n  }, {\n    key: \"_decorateDeriveRx\",\n    value: function _decorateDeriveRx(decorateMethod) {\n      var _this$_runtimeVersion, _this$_options$typesB, _this$_options$typesB2, _this$_options$typesB3;\n\n      var specName = (_this$_runtimeVersion = this._runtimeVersion) === null || _this$_runtimeVersion === void 0 ? void 0 : _this$_runtimeVersion.specName.toString();\n\n      var derives = _objectSpread(_objectSpread({}, this._options.derives), ((_this$_options$typesB = this._options.typesBundle) === null || _this$_options$typesB === void 0 ? void 0 : (_this$_options$typesB2 = _this$_options$typesB.spec) === null || _this$_options$typesB2 === void 0 ? void 0 : (_this$_options$typesB3 = _this$_options$typesB2[specName !== null && specName !== void 0 ? specName : '']) === null || _this$_options$typesB3 === void 0 ? void 0 : _this$_options$typesB3.derives) || {}); // Pull in derive from api-derive\n\n\n      var derive = decorateDerive(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], this._rx, derives);\n      return decorateSections(derive, decorateMethod);\n    }\n  }, {\n    key: \"_decorateDerive\",\n    value: function _decorateDerive(decorateMethod) {\n      return decorateSections(this._rx.derive, decorateMethod);\n    }\n    /**\n     * Put the `this.onCall` function of ApiRx here, because it is needed by\n     * `api._rx`.\n     */\n\n  }]);\n\n  return Decorate;\n}(Events);","map":null,"metadata":{},"sourceType":"module"}
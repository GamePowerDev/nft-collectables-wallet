{"ast":null,"code":"import _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { of } from '@polkadot/x-rxjs';\nimport { map } from '@polkadot/x-rxjs/operators';\nimport { memo } from \"../util/index.js\";\nimport { didUpdateToBool } from \"./util.js\";\n\nfunction parseActive(id, active) {\n  var found = active.find(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 1),\n        paraId = _ref2[0];\n\n    return paraId === id;\n  });\n\n  if (found && found[1].isSome) {\n    var _found$1$unwrap = found[1].unwrap(),\n        _found$1$unwrap2 = _slicedToArray(_found$1$unwrap, 2),\n        collatorId = _found$1$unwrap2[0],\n        retriable = _found$1$unwrap2[1];\n\n    return _objectSpread({\n      collatorId: collatorId\n    }, retriable.isWithRetries ? {\n      isRetriable: true,\n      retries: retriable.asWithRetries.toNumber()\n    } : {\n      isRetriable: false,\n      retries: 0\n    });\n  }\n\n  return null;\n}\n\nfunction parseCollators(id, collatorQueue) {\n  return collatorQueue.map(function (queue) {\n    var found = queue.find(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 1),\n          paraId = _ref4[0];\n\n      return paraId === id;\n    });\n    return found ? found[1] : null;\n  });\n}\n\nfunction parse(id, _ref5) {\n  var _ref6 = _slicedToArray(_ref5, 8),\n      active = _ref6[0],\n      retryQueue = _ref6[1],\n      selectedThreads = _ref6[2],\n      didUpdate = _ref6[3],\n      info = _ref6[4],\n      pendingSwap = _ref6[5],\n      heads = _ref6[6],\n      relayDispatchQueue = _ref6[7];\n\n  if (info.isNone) {\n    return null;\n  }\n\n  return {\n    active: parseActive(id, active),\n    didUpdate: didUpdateToBool(didUpdate, id),\n    heads: heads,\n    id: id,\n    info: _objectSpread({\n      id: id\n    }, info.unwrap()),\n    pendingSwapId: pendingSwap.unwrapOr(null),\n    relayDispatchQueue: relayDispatchQueue,\n    retryCollators: parseCollators(id, retryQueue),\n    selectedCollators: parseCollators(id, selectedThreads)\n  };\n}\n\nexport function info(instanceId, api) {\n  return memo(instanceId, function (id) {\n    return api.query.registrar && api.query.parachains ? api.queryMulti([api.query.registrar.active, api.query.registrar.retryQueue, api.query.registrar.selectedThreads, api.query.parachains.didUpdate, [api.query.registrar.paras, id], [api.query.registrar.pendingSwap, id], [api.query.parachains.heads, id], [api.query.parachains.relayDispatchQueue, id]]).pipe(map(function (result) {\n      return parse(api.registry.createType('ParaId', id), result);\n    })) : of(null);\n  });\n}","map":null,"metadata":{},"sourceType":"module"}
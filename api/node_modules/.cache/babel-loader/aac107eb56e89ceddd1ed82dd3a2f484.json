{"ast":null,"code":"import _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, compactFromU8a, logger, u8aToU8a } from '@polkadot/util';\nimport { AbstractArray } from \"./AbstractArray.js\";\nimport { decodeU8a, typeToConstructor } from \"./utils/index.js\";\nvar MAX_LENGTH = 64 * 1024;\nvar l = logger('Vec');\n/**\n * @name Vec\n * @description\n * This manages codec arrays. Internally it keeps track of the length (as decoded) and allows\n * construction with the passed `Type` in the constructor. It is an extension to Array, providing\n * specific encoding/decoding on top of the base type.\n */\n\nexport var Vec = /*#__PURE__*/function (_AbstractArray) {\n  _inherits(Vec, _AbstractArray);\n\n  var _super = _createSuper(Vec);\n\n  function Vec(registry, Type) {\n    var _this;\n\n    var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n    _classCallCheck(this, Vec);\n\n    var Clazz = typeToConstructor(registry, Type);\n    _this = _super.call.apply(_super, [this, registry].concat(_toConsumableArray(Vec.decodeVec(registry, Clazz, value))));\n    _this._Type = void 0;\n    _this._Type = Clazz;\n    return _this;\n  }\n  /** @internal */\n\n\n  _createClass(Vec, [{\n    key: \"Type\",\n    get:\n    /**\n     * @description The type for the items\n     */\n    function get() {\n      return this._Type.name;\n    }\n    /**\n     * @description Finds the index of the value in the array\n     */\n\n  }, {\n    key: \"indexOf\",\n    value: function indexOf(_other) {\n      // convert type first, this removes overhead from the eq\n      var other = _other instanceof this._Type ? _other : new this._Type(this.registry, _other);\n\n      for (var i = 0; i < this.length; i++) {\n        if (other.eq(this[i])) {\n          return i;\n        }\n      }\n\n      return -1;\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n\n  }, {\n    key: \"toRawType\",\n    value: function toRawType() {\n      return \"Vec<\".concat(this.registry.getClassName(this._Type) || new this._Type(this.registry).toRawType(), \">\");\n    }\n  }], [{\n    key: \"decodeVec\",\n    value: function decodeVec(registry, Type, value) {\n      if (Array.isArray(value)) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return value.map(function (entry, index) {\n          try {\n            return entry instanceof Type ? entry : new Type(registry, entry);\n          } catch (error) {\n            l.error(\"Unable to decode on index \".concat(index), error.message);\n            throw error;\n          }\n        });\n      }\n\n      var u8a = u8aToU8a(value);\n\n      var _compactFromU8a = compactFromU8a(u8a),\n          _compactFromU8a2 = _slicedToArray(_compactFromU8a, 2),\n          offset = _compactFromU8a2[0],\n          length = _compactFromU8a2[1];\n\n      assert(length.lten(MAX_LENGTH), \"Vec length \".concat(length.toString(), \" exceeds \").concat(MAX_LENGTH));\n      return decodeU8a(registry, u8a.subarray(offset), new Array(length.toNumber()).fill(Type));\n    }\n  }, {\n    key: \"with\",\n    value: function _with(Type) {\n      return /*#__PURE__*/function (_Vec) {\n        _inherits(_class, _Vec);\n\n        var _super2 = _createSuper(_class);\n\n        function _class(registry, value) {\n          _classCallCheck(this, _class);\n\n          return _super2.call(this, registry, Type, value);\n        }\n\n        return _class;\n      }(Vec);\n    }\n  }]);\n\n  return Vec;\n}(AbstractArray);","map":null,"metadata":{},"sourceType":"module"}
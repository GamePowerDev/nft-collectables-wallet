{"ast":null,"code":"import _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n// Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { isHex, u8aToString } from '@polkadot/util';\nimport { combineLatest, of } from '@polkadot/x-rxjs';\nimport { map, switchMap } from '@polkadot/x-rxjs/operators';\nimport { memo } from \"../util/index.js\";\nvar UNDEF_HEX = {\n  toHex: function toHex() {\n    return undefined;\n  }\n};\n\nfunction dataAsString(data) {\n  return data.isRaw ? u8aToString(data.asRaw.toU8a(true)) : data.isNone ? undefined : data.toHex();\n}\n\nfunction extractOther(additional) {\n  return additional.reduce(function (other, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        _key = _ref2[0],\n        _value = _ref2[1];\n\n    var key = dataAsString(_key);\n    var value = dataAsString(_value);\n\n    if (key && value) {\n      other[key] = value;\n    }\n\n    return other;\n  }, {});\n}\n\nfunction extractIdentity(identityOfOpt, superOf) {\n  if (!(identityOfOpt !== null && identityOfOpt !== void 0 && identityOfOpt.isSome)) {\n    return {\n      judgements: []\n    };\n  }\n\n  var _identityOfOpt$unwrap = identityOfOpt.unwrap(),\n      info = _identityOfOpt$unwrap.info,\n      judgements = _identityOfOpt$unwrap.judgements;\n\n  var topDisplay = dataAsString(info.display);\n  return {\n    display: superOf && dataAsString(superOf[1]) || topDisplay,\n    displayParent: superOf && topDisplay,\n    email: dataAsString(info.email),\n    image: dataAsString(info.image),\n    judgements: judgements,\n    legal: dataAsString(info.legal),\n    other: extractOther(info.additional),\n    parent: superOf && superOf[0],\n    pgp: info.pgpFingerprint.unwrapOr(UNDEF_HEX).toHex(),\n    riot: dataAsString(info.riot),\n    twitter: dataAsString(info.twitter),\n    web: dataAsString(info.web)\n  };\n}\n\nfunction getParent(api, identityOfOpt, superOfOpt) {\n  if (identityOfOpt !== null && identityOfOpt !== void 0 && identityOfOpt.isSome) {\n    // this identity has something set\n    return of([identityOfOpt, undefined]);\n  } else if (superOfOpt !== null && superOfOpt !== void 0 && superOfOpt.isSome) {\n    var superOf = superOfOpt.unwrap(); // we have a super\n\n    return combineLatest([api.query.identity.identityOf(superOf[0]), of(superOf)]);\n  } // nothing of value returned\n\n\n  return of([undefined, undefined]);\n}\n\nfunction getBase(api, accountId) {\n  var _api$query$identity;\n\n  return accountId && (_api$query$identity = api.query.identity) !== null && _api$query$identity !== void 0 && _api$query$identity.identityOf ? api.queryMulti([[api.query.identity.identityOf, accountId], [api.query.identity.superOf, accountId]]) : of([undefined, undefined]);\n}\n/**\n * @name identity\n * @description Returns identity info for an account\n */\n\n\nexport function identity(instanceId, api) {\n  return memo(instanceId, function (accountId) {\n    return getBase(api, accountId).pipe(switchMap(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 2),\n          identityOfOpt = _ref4[0],\n          superOfOpt = _ref4[1];\n\n      return getParent(api, identityOfOpt, superOfOpt);\n    }), map(function (_ref5) {\n      var _ref6 = _slicedToArray(_ref5, 2),\n          identityOfOpt = _ref6[0],\n          superOf = _ref6[1];\n\n      return extractIdentity(identityOfOpt, superOf);\n    }));\n  });\n}\nexport function hasIdentity(instanceId, api) {\n  return memo(instanceId, function (accountId) {\n    return api.derive.accounts.hasIdentityMulti([accountId]).pipe(map(function (_ref7) {\n      var _ref8 = _slicedToArray(_ref7, 1),\n          first = _ref8[0];\n\n      return first;\n    }));\n  });\n}\nexport function hasIdentityMulti(instanceId, api) {\n  return memo(instanceId, function (accountIds) {\n    var _api$query$identity2;\n\n    return (_api$query$identity2 = api.query.identity) !== null && _api$query$identity2 !== void 0 && _api$query$identity2.identityOf ? combineLatest([api.query.identity.identityOf.multi(accountIds), api.query.identity.superOf.multi(accountIds)]).pipe(map(function (_ref9) {\n      var _ref10 = _slicedToArray(_ref9, 2),\n          identities = _ref10[0],\n          supers = _ref10[1];\n\n      return identities.map(function (identityOfOpt, index) {\n        var superOfOpt = supers[index];\n        var parentId = superOfOpt && superOfOpt.isSome ? superOfOpt.unwrap()[0].toString() : undefined;\n        var display;\n\n        if (identityOfOpt && identityOfOpt.isSome) {\n          var value = dataAsString(identityOfOpt.unwrap().info.display);\n\n          if (value && !isHex(value)) {\n            display = value;\n          }\n        }\n\n        return {\n          display: display,\n          hasIdentity: !!(display || parentId),\n          parentId: parentId\n        };\n      });\n    })) : of(accountIds.map(function () {\n      return {\n        hasIdentity: false\n      };\n    }));\n  });\n}","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _toConsumableArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { isString, isU8a, u8aToU8a } from '@polkadot/util';\nimport { Enum } from \"../codec/Enum.js\";\n/** @internal */\n\nfunction decodeDataU8a(registry, value) {\n  var indicator = value[0];\n\n  if (!indicator) {\n    return [undefined, undefined];\n  } else if (indicator >= 1 && indicator <= 33) {\n    var length = indicator - 1;\n    var data = value.subarray(1, length + 1); // in this case, we are passing a Raw back (since we have no length)\n\n    return [registry.createType('Raw', data), 1];\n  } else if (indicator >= 34 && indicator <= 37) {\n    return [value.subarray(1, 32 + 1), indicator - 32]; // 34 becomes 2\n  }\n\n  throw new Error(\"Unable to decode Data, invalid indicator byte \".concat(indicator));\n}\n/** @internal */\n\n\nfunction decodeData(registry, value) {\n  if (!value) {\n    return [undefined, undefined];\n  } else if (isU8a(value) || isString(value)) {\n    return decodeDataU8a(registry, u8aToU8a(value));\n  } // assume we have an Enum or an  object input, handle this via the normal Enum decoding\n\n\n  return [value, undefined];\n}\n/**\n * @name Data\n * @description\n * A [[Data]] container with node, raw or hashed data\n */\n\n\nexport var Data = /*#__PURE__*/function (_Enum) {\n  _inherits(Data, _Enum);\n\n  var _super = _createSuper(Data);\n\n  function Data(registry, value) {\n    _classCallCheck(this, Data);\n\n    return _super.call.apply(_super, [this, registry, {\n      None: 'Null',\n      // 0\n      Raw: 'Bytes',\n      // 1\n      // eslint-disable-next-line sort-keys\n      BlakeTwo256: 'H256',\n      // 2\n      Sha256: 'H256',\n      // 3\n      // eslint-disable-next-line sort-keys\n      Keccak256: 'H256',\n      // 4\n      ShaThree256: 'H256' // 5\n\n    }].concat(_toConsumableArray(decodeData(registry, value))));\n  }\n\n  _createClass(Data, [{\n    key: \"asRaw\",\n    get: function get() {\n      return this.value;\n    }\n  }, {\n    key: \"asSha256\",\n    get: function get() {\n      return this.value;\n    }\n  }, {\n    key: \"isRaw\",\n    get: function get() {\n      return this.index === 1;\n    }\n  }, {\n    key: \"isSha256\",\n    get: function get() {\n      return this.index === 3;\n    }\n    /**\n     * @description The encoded length\n     */\n\n  }, {\n    key: \"encodedLength\",\n    get: function get() {\n      return this.toU8a().length;\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     */\n\n  }, {\n    key: \"toU8a\",\n    value: function toU8a() {\n      if (this.index === 0) {\n        return new Uint8Array(1);\n      } else if (this.index === 1) {\n        // don't add the length, just the data\n        var data = this.value.toU8a(true);\n        var length = Math.min(data.length, 32);\n\n        var _u8a = new Uint8Array(length + 1);\n\n        _u8a.set([data.length + 1], 0);\n\n        _u8a.set(data.subarray(0, length), 1);\n\n        return _u8a;\n      } // otherwise we simply have a hash\n\n\n      var u8a = new Uint8Array(33);\n      u8a.set([this.index + 32], 0);\n      u8a.set(this.value.toU8a(), 1);\n      return u8a;\n    }\n  }]);\n\n  return Data;\n}(Enum);","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/metadata authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { Raw } from '@polkadot/types/codec';\nimport { assert, compactAddLength, compactStripLength, isNull, isUndefined, stringLowerFirst, u8aConcat } from '@polkadot/util';\nimport { xxhashAsU8a } from '@polkadot/util-crypto';\nimport { getHasher } from \"./getHasher.js\";\nvar EMPTY_U8A = new Uint8Array([]);\n\nvar NULL_HASHER = function NULL_HASHER(value) {\n  return value;\n}; // get the hashers, the base (and  in the case of DoubleMap), the second key\n\n/** @internal */\n\n\nfunction getHashers(_ref) {\n  var type = _ref.meta.type;\n\n  if (type.isDoubleMap) {\n    return [getHasher(type.asDoubleMap.hasher), getHasher(type.asDoubleMap.key2Hasher)];\n  } else if (type.isMap) {\n    return [getHasher(type.asMap.hasher)];\n  } // the default\n\n\n  return [getHasher()];\n} // create a base prefixed key\n\n/** @internal */\n\n\nfunction createPrefixedKey(_ref2) {\n  var method = _ref2.method,\n      prefix = _ref2.prefix;\n  return u8aConcat(xxhashAsU8a(prefix, 128), xxhashAsU8a(method, 128));\n} // create a key for a DoubleMap type\n\n/** @internal */\n\n\nfunction createKeyDoubleMap(registry, itemFn, args, _ref3) {\n  var _ref4 = _slicedToArray(_ref3, 2),\n      hasher1 = _ref4[0],\n      hasher2 = _ref4[1];\n\n  var _itemFn$meta = itemFn.meta,\n      name = _itemFn$meta.name,\n      type = _itemFn$meta.type; // since we are passing an almost-unknown through, trust, but verify\n\n  assert(Array.isArray(args) && !isUndefined(args[0]) && !isNull(args[0]) && !isUndefined(args[1]) && !isNull(args[1]), \"\".concat((name || 'unknown').toString(), \" is a DoubleMap and requires two arguments\")); // if this fails, we have bigger issues\n\n  assert(!isUndefined(hasher2), '2 hashing functions should be defined for DoubleMaps');\n\n  var _args = _slicedToArray(args, 2),\n      key1 = _args[0],\n      key2 = _args[1];\n\n  var map = type.asDoubleMap;\n  var val1 = registry.createType(map.key1.toString(), key1).toU8a();\n  var val2 = registry.createType(map.key2.toString(), key2).toU8a(); // as per createKey, always add the length prefix (underlying it is Bytes)\n\n  return compactAddLength(u8aConcat(createPrefixedKey(itemFn), hasher1(val1), hasher2(val2)));\n} // create a key for either a map or a plain value\n\n/** @internal */\n\n\nfunction createKey(registry, itemFn, arg, hasher) {\n  var _itemFn$meta2 = itemFn.meta,\n      name = _itemFn$meta2.name,\n      type = _itemFn$meta2.type;\n  var param = EMPTY_U8A;\n\n  if (type.isMap) {\n    var map = type.asMap;\n    assert(!isUndefined(arg) && !isNull(arg), \"\".concat(name.toString(), \" is a Map and requires one argument\"));\n    param = registry.createType(map.key.toString(), arg).toU8a();\n  } // StorageKey is a Bytes, so is length-prefixed\n\n\n  return compactAddLength(u8aConcat(createPrefixedKey(itemFn), param.length ? hasher(param) : EMPTY_U8A));\n} // attach the metadata to expand to a StorageFunction\n\n/** @internal */\n\n\nfunction expandWithMeta(_ref5, _storageFn) {\n  var meta = _ref5.meta,\n      method = _ref5.method,\n      prefix = _ref5.prefix,\n      section = _ref5.section;\n  var storageFn = _storageFn;\n  storageFn.meta = meta;\n  storageFn.method = stringLowerFirst(method);\n  storageFn.prefix = prefix;\n  storageFn.section = section; // explicitly add the actual method in the toJSON, this gets used to determine caching and without it\n  // instances (e.g. collective) will not work since it is only matched on param meta\n\n  storageFn.toJSON = function () {\n    return _objectSpread(_objectSpread({}, meta.toJSON()), {}, {\n      storage: {\n        method: method,\n        prefix: prefix,\n        section: section\n      }\n    });\n  };\n\n  return storageFn;\n}\n/** @internal */\n\n\nfunction extendHeadMeta(registry, _ref6, _ref7, iterFn) {\n  var _ref6$meta = _ref6.meta,\n      documentation = _ref6$meta.documentation,\n      name = _ref6$meta.name,\n      type = _ref6$meta.type,\n      section = _ref6.section;\n  var method = _ref7.method;\n  var outputType = type.isMap ? type.asMap.key.toString() : type.asDoubleMap.key1.toString(); // metadata with a fallback value using the type of the key, the normal\n  // meta fallback only applies to actual entry values, create one for head\n\n  iterFn.meta = registry.createType('StorageEntryMetadataLatest', {\n    documentation: documentation,\n    fallback: registry.createType('Bytes', registry.createType(outputType).toHex()),\n    modifier: registry.createType('StorageEntryModifierLatest', 1),\n    // required\n    name: name,\n    type: registry.createType('StorageEntryTypeLatest', registry.createType('Type', type.isMap ? type.asMap.key : type.asDoubleMap.key1), 0)\n  });\n  var prefixKey = registry.createType('StorageKey', iterFn, {\n    method: method,\n    section: section\n  });\n  return function (arg) {\n    return !isUndefined(arg) && !isNull(arg) ? registry.createType('StorageKey', iterFn(arg), {\n      method: method,\n      section: section\n    }) : prefixKey;\n  };\n} // attach the full list hashing for prefixed maps\n\n/** @internal */\n\n\nfunction extendPrefixedMap(registry, itemFn, storageFn) {\n  var type = itemFn.meta.type;\n  storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, function (arg) {\n    assert(type.isDoubleMap || isUndefined(arg), 'Filtering arguments for keys/entries are only valid on double maps');\n    return new Raw(registry, type.isDoubleMap && !isUndefined(arg) && !isNull(arg) ? u8aConcat(createPrefixedKey(itemFn), getHasher(type.asDoubleMap.hasher)(registry.createType(type.asDoubleMap.key1.toString(), arg).toU8a())) : createPrefixedKey(itemFn));\n  });\n  return storageFn;\n}\n/** @internal */\n\n\nexport function createFunction(registry, itemFn, options) {\n  var type = itemFn.meta.type;\n\n  var _getHashers = getHashers(itemFn),\n      _getHashers2 = _slicedToArray(_getHashers, 2),\n      hasher = _getHashers2[0],\n      key2Hasher = _getHashers2[1]; // Can only have zero or one argument:\n  //   - storage.system.account(address)\n  //   - storage.timestamp.blockPeriod()\n  // For doublemap queries the params is passed in as an tuple, [key1, key2]\n\n\n  var storageFn = expandWithMeta(itemFn, function (arg) {\n    return type.isDoubleMap ? createKeyDoubleMap(registry, itemFn, arg, [hasher, key2Hasher]) : createKey(registry, itemFn, arg, options.skipHashing ? NULL_HASHER : hasher);\n  });\n\n  if (type.isMap || type.isDoubleMap) {\n    extendPrefixedMap(registry, itemFn, storageFn);\n  }\n\n  storageFn.keyPrefix = function (arg) {\n    return storageFn.iterKey && storageFn.iterKey(arg) || compactStripLength(storageFn())[1];\n  };\n\n  return storageFn;\n}","map":null,"metadata":{},"sourceType":"module"}
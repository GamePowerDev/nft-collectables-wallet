{"ast":null,"code":"import _classCallCheck from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport BN from 'bn.js';\nimport { bnToU8a, isAscii, u8aToHex, u8aToString } from '@polkadot/util';\nimport { u32 } from \"../primitive/U32.js\"; // there are all reversed since it is actually encoded as u32, LE,\n// this means that FRNK has the bytes as KNRF\n\nexport var CID_AURA = 0x61727561; // 'aura'\n\nexport var CID_BABE = 0x45424142; // 'BABE'\n\nexport var CID_GRPA = 0x4b4e5246; // 'FRNK' (don't ask, used to be afg1)\n\nexport var CID_POW = 0x5f776f70; // 'pow_'\n\n/**\n * @name GenericConsensusEngineId\n * @description\n * A 4-byte identifier (actually a [u8; 4]) identifying the engine, e.g. for Aura it would be [b'a', b'u', b'r', b'a']\n */\n\nexport var GenericConsensusEngineId = /*#__PURE__*/function (_u) {\n  _inherits(GenericConsensusEngineId, _u);\n\n  var _super = _createSuper(GenericConsensusEngineId);\n\n  function GenericConsensusEngineId() {\n    _classCallCheck(this, GenericConsensusEngineId);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(GenericConsensusEngineId, [{\n    key: \"isAura\",\n    get:\n    /**\n     * @description `true` if the engine matches aura\n     */\n    function get() {\n      return this.eq(CID_AURA);\n    }\n    /**\n     * @description `true` is the engine matches babe\n     */\n\n  }, {\n    key: \"isBabe\",\n    get: function get() {\n      return this.eq(CID_BABE);\n    }\n    /**\n     * @description `true` is the engine matches grandpa\n     */\n\n  }, {\n    key: \"isGrandpa\",\n    get: function get() {\n      return this.eq(CID_GRPA);\n    }\n    /**\n     * @description `true` is the engine matches pow\n     */\n\n  }, {\n    key: \"isPow\",\n    get: function get() {\n      return this.eq(CID_POW);\n    }\n  }, {\n    key: \"_getAuraAuthor\",\n    value: function _getAuraAuthor(bytes, sessionValidators) {\n      return sessionValidators[this.registry.createType('RawAuraPreDigest', bytes.toU8a(true)).slotNumber.mod(new BN(sessionValidators.length)).toNumber()];\n    }\n  }, {\n    key: \"_getBabeAuthor\",\n    value: function _getBabeAuthor(bytes, sessionValidators) {\n      var digest = this.registry.createType('RawBabePreDigestCompat', bytes.toU8a(true));\n      return sessionValidators[digest.value.toNumber()];\n    }\n  }, {\n    key: \"_getPowAuthor\",\n    value: function _getPowAuthor(bytes) {\n      return this.registry.createType('AccountId', bytes);\n    }\n  }, {\n    key: \"_getH160Author\",\n    value: function _getH160Author(bytes) {\n      return this.registry.createType('AccountId', bytes);\n    }\n    /**\n     * @description From the input bytes, decode into an author\n     */\n\n  }, {\n    key: \"extractAuthor\",\n    value: function extractAuthor(bytes, sessionValidators) {\n      if (sessionValidators !== null && sessionValidators !== void 0 && sessionValidators.length) {\n        if (this.isAura) {\n          return this._getAuraAuthor(bytes, sessionValidators);\n        } else if (this.isBabe) {\n          return this._getBabeAuthor(bytes, sessionValidators);\n        }\n      }\n\n      if (this.isPow) {\n        return this._getPowAuthor(bytes);\n      } // Moonbeam is neither Aura nor Babe nor Pow and uses h160 addresses\n\n\n      if (bytes.length === 20) {\n        return this._getH160Author(bytes);\n      }\n\n      return undefined;\n    }\n    /**\n     * @description Override the default toString to return a 4-byte string\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return GenericConsensusEngineId.idToString(this);\n    }\n  }], [{\n    key: \"idToString\",\n    value: function idToString(input) {\n      var u8a = bnToU8a(input);\n      return isAscii(u8a) ? u8aToString(u8a) : u8aToHex(u8a);\n    }\n  }, {\n    key: \"stringToId\",\n    value: function stringToId(input) {\n      return input.split('').reverse().reduce(function (result, char) {\n        return result * 256 + char.charCodeAt(0);\n      }, 0);\n    }\n  }]);\n\n  return GenericConsensusEngineId;\n}(u32);","map":null,"metadata":{},"sourceType":"module"}
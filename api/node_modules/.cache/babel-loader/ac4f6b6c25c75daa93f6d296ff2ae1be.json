{"ast":null,"code":"import _defineProperty from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\nvar _infoMapping;\n\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isNumber, isUndefined } from '@polkadot/util';\nimport { BTreeMap, BTreeSet, CodecSet, Compact, Enum, HashMap, Int, Option, Result, Struct, Tuple, U8aFixed, UInt, Vec, VecFixed } from \"../codec/index.js\";\nimport { DoNotConstruct } from \"../primitive/index.js\";\nimport { getTypeDef } from \"./getTypeDef.js\";\nimport { TypeDefInfo } from \"./types.js\";\nexport function createClass(registry, type) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  return getTypeClass(registry, getTypeDef(type));\n} // An unsafe version of the `createType` below. It's unsafe because the `type`\n// argument here can be any string, which, if it cannot be parsed, it will yield\n// a runtime error.\n\nexport function ClassOfUnsafe(registry, name) {\n  return createClass(registry, name);\n} // alias for createClass\n\nexport function ClassOf(registry, name) {\n  // TS2589: Type instantiation is excessively deep and possibly infinite.\n  // The above happens with as Constructor<InterfaceTypes[K]>;\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n  return ClassOfUnsafe(registry, name);\n}\n\nfunction getSubDefArray(value) {\n  assert(value.sub && Array.isArray(value.sub), \"Expected subtype as TypeDef[] in \".concat(JSON.stringify(value)));\n  return value.sub;\n}\n\nfunction getSubDef(value) {\n  assert(value.sub && !Array.isArray(value.sub), \"Expected subtype as TypeDef in \".concat(JSON.stringify(value)));\n  return value.sub;\n}\n\nfunction getSubType(value) {\n  return getSubDef(value).type;\n} // create a maps of type string constructors from the input\n\n\nfunction getTypeClassMap(value) {\n  var result = {};\n  return getSubDefArray(value).reduce(function (result, sub) {\n    result[sub.name] = sub.type;\n    return result;\n  }, result);\n} // create an array of type string constructors from the input\n\n\nfunction getTypeClassArray(value) {\n  return getSubDefArray(value).map(function (_ref) {\n    var type = _ref.type;\n    return type;\n  });\n}\n\nfunction createInt(_ref2, Clazz) {\n  var displayName = _ref2.displayName,\n      length = _ref2.length;\n  assert(isNumber(length), \"Expected bitLength information for \".concat(displayName || Clazz.constructor.name, \"<bitLength>\"));\n  return Clazz.with(length, displayName);\n}\n\nfunction createHashMap(value, Clazz) {\n  var _getTypeClassArray = getTypeClassArray(value),\n      _getTypeClassArray2 = _slicedToArray(_getTypeClassArray, 2),\n      keyType = _getTypeClassArray2[0],\n      valueType = _getTypeClassArray2[1];\n\n  return Clazz.with(keyType, valueType);\n}\n\nvar infoMapping = (_infoMapping = {}, _defineProperty(_infoMapping, TypeDefInfo.BTreeMap, function (registry, value) {\n  return createHashMap(value, BTreeMap);\n}), _defineProperty(_infoMapping, TypeDefInfo.BTreeSet, function (registry, value) {\n  return BTreeSet.with(getSubType(value));\n}), _defineProperty(_infoMapping, TypeDefInfo.Compact, function (registry, value) {\n  return Compact.with(getSubType(value));\n}), _defineProperty(_infoMapping, TypeDefInfo.DoNotConstruct, function (registry, value) {\n  return DoNotConstruct.with(value.displayName);\n}), _defineProperty(_infoMapping, TypeDefInfo.Enum, function (registry, value) {\n  var subs = getSubDefArray(value);\n  return Enum.with(subs.every(function (_ref3) {\n    var type = _ref3.type;\n    return type === 'Null';\n  }) ? subs.reduce(function (out, _ref4, count) {\n    var index = _ref4.index,\n        name = _ref4.name;\n    out[name] = index || count;\n    return out;\n  }, {}) : getTypeClassMap(value));\n}), _defineProperty(_infoMapping, TypeDefInfo.HashMap, function (registry, value) {\n  return createHashMap(value, HashMap);\n}), _defineProperty(_infoMapping, TypeDefInfo.Int, function (registry, value) {\n  return createInt(value, Int);\n}), _defineProperty(_infoMapping, TypeDefInfo.Linkage, function (registry, value) {\n  var type = \"Option<\".concat(getSubType(value), \">\"); // eslint-disable-next-line sort-keys\n\n  var Clazz = Struct.with({\n    previous: type,\n    next: type\n  }); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n  Clazz.prototype.toRawType = function () {\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call\n    return \"Linkage<\".concat(this.next.toRawType(true), \">\");\n  };\n\n  return Clazz;\n}), _defineProperty(_infoMapping, TypeDefInfo.Null, function (registry, _) {\n  return createClass(registry, 'Null');\n}), _defineProperty(_infoMapping, TypeDefInfo.Option, function (registry, value) {\n  return Option.with(getSubType(value));\n}), _defineProperty(_infoMapping, TypeDefInfo.Plain, function (registry, value) {\n  return registry.getOrUnknown(value.type);\n}), _defineProperty(_infoMapping, TypeDefInfo.Result, function (registry, value) {\n  var _getTypeClassArray3 = getTypeClassArray(value),\n      _getTypeClassArray4 = _slicedToArray(_getTypeClassArray3, 2),\n      Ok = _getTypeClassArray4[0],\n      Err = _getTypeClassArray4[1]; // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n\n  return Result.with({\n    Err: Err,\n    Ok: Ok\n  });\n}), _defineProperty(_infoMapping, TypeDefInfo.Set, function (registry, value) {\n  var result = {};\n  return CodecSet.with(getSubDefArray(value).reduce(function (result, _ref5) {\n    var index = _ref5.index,\n        name = _ref5.name;\n    result[name] = index;\n    return result;\n  }, result), value.length);\n}), _defineProperty(_infoMapping, TypeDefInfo.Struct, function (registry, value) {\n  return Struct.with(getTypeClassMap(value), value.alias);\n}), _defineProperty(_infoMapping, TypeDefInfo.Tuple, function (registry, value) {\n  return Tuple.with(getTypeClassArray(value));\n}), _defineProperty(_infoMapping, TypeDefInfo.UInt, function (registry, value) {\n  return createInt(value, UInt);\n}), _defineProperty(_infoMapping, TypeDefInfo.Vec, function (registry, value) {\n  var subType = getSubType(value);\n  return subType === 'u8' ? createClass(registry, 'Bytes') : Vec.with(subType);\n}), _defineProperty(_infoMapping, TypeDefInfo.VecFixed, function (registry, _ref6) {\n  var displayName = _ref6.displayName,\n      length = _ref6.length,\n      sub = _ref6.sub;\n  assert(isNumber(length) && !isUndefined(sub), 'Expected length & type information for fixed vector');\n  return sub.type === 'u8' ? U8aFixed.with(length * 8, displayName) : VecFixed.with(sub.type, length);\n}), _infoMapping); // Returns the type Class for construction\n\nexport function getTypeClass(registry, value) {\n  var Type = registry.get(value.type);\n\n  if (Type) {\n    return Type;\n  }\n\n  var getFn = infoMapping[value.info];\n  assert(getFn, \"Unable to construct class from \".concat(JSON.stringify(value)));\n  return getFn(registry, value);\n}","map":null,"metadata":{},"sourceType":"module"}
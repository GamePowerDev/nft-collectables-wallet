{"ast":null,"code":"import _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { combineLatest, of } from '@polkadot/x-rxjs';\nimport { map, switchMap } from '@polkadot/x-rxjs/operators';\nimport { memo } from \"../util/index.js\";\n\nfunction createDerive(api, info, _ref) {\n  var _ref2 = _slicedToArray(_ref, 4),\n      currentSlot = _ref2[0],\n      epochIndex = _ref2[1],\n      epochOrGenesisStartSlot = _ref2[2],\n      activeEraStartSessionIndex = _ref2[3];\n\n  var epochStartSlot = epochIndex.mul(info.sessionLength).iadd(epochOrGenesisStartSlot);\n  var sessionProgress = currentSlot.sub(epochStartSlot);\n  var eraProgress = info.currentIndex.sub(activeEraStartSessionIndex).imul(info.sessionLength).iadd(sessionProgress);\n  return _objectSpread(_objectSpread({}, info), {}, {\n    eraProgress: api.registry.createType('BlockNumber', eraProgress),\n    sessionProgress: api.registry.createType('BlockNumber', sessionProgress)\n  });\n}\n\nfunction queryAura(api) {\n  return api.derive.session.info().pipe(map(function (info) {\n    return _objectSpread(_objectSpread({}, info), {}, {\n      eraProgress: api.registry.createType('BlockNumber'),\n      sessionProgress: api.registry.createType('BlockNumber')\n    });\n  }));\n}\n\nfunction queryBabe(api) {\n  return api.derive.session.info().pipe(switchMap(function (info) {\n    var _api$query$staking;\n\n    return combineLatest([of(info), // we may have no staking, but have babe (permissioned)\n    (_api$query$staking = api.query.staking) !== null && _api$query$staking !== void 0 && _api$query$staking.erasStartSessionIndex ? api.queryMulti([api.query.babe.currentSlot, api.query.babe.epochIndex, api.query.babe.genesisSlot, [api.query.staking.erasStartSessionIndex, info.activeEra]]) : api.queryMulti([api.query.babe.currentSlot, api.query.babe.epochIndex, api.query.babe.genesisSlot])]);\n  }), map(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        info = _ref4[0],\n        _ref4$ = _slicedToArray(_ref4[1], 4),\n        currentSlot = _ref4$[0],\n        epochIndex = _ref4$[1],\n        genesisSlot = _ref4$[2],\n        optStartIndex = _ref4$[3];\n\n    return [info, [currentSlot, epochIndex, genesisSlot, optStartIndex && optStartIndex.isSome ? optStartIndex.unwrap() : api.registry.createType('SessionIndex', 1)]];\n  }));\n}\n/**\n * @description Retrieves all the session and era query and calculates specific values on it as the length of the session and eras\n */\n\n\nexport function progress(instanceId, api) {\n  return memo(instanceId, function () {\n    return api.query.babe ? queryBabe(api).pipe(map(function (_ref5) {\n      var _ref6 = _slicedToArray(_ref5, 2),\n          info = _ref6[0],\n          slots = _ref6[1];\n\n      return createDerive(api, info, slots);\n    })) : queryAura(api);\n  });\n}","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _toArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toArray\";\nimport _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport BN from 'bn.js';\nimport { bnMax, isFunction } from '@polkadot/util';\nimport { combineLatest, of } from '@polkadot/x-rxjs';\nimport { map, switchMap } from '@polkadot/x-rxjs/operators';\nimport { memo } from \"../util/index.js\";\nvar VESTING_ID = '0x76657374696e6720';\n\nfunction calcLocked(api, bestNumber, locks) {\n  var lockedBalance = api.registry.createType('Balance');\n  var lockedBreakdown = [];\n  var vestingLocked = api.registry.createType('Balance');\n  var allLocked = false;\n\n  if (Array.isArray(locks)) {\n    // only get the locks that are valid until passed the current block\n    lockedBreakdown = locks.filter(function (_ref) {\n      var until = _ref.until;\n      return !until || bestNumber && until.gt(bestNumber);\n    });\n    allLocked = lockedBreakdown.some(function (_ref2) {\n      var amount = _ref2.amount;\n      return amount.isMax();\n    });\n    vestingLocked = api.registry.createType('Balance', lockedBreakdown.filter(function (_ref3) {\n      var id = _ref3.id;\n      return id.eq(VESTING_ID);\n    }).reduce(function (result, _ref4) {\n      var amount = _ref4.amount;\n      return result.iadd(amount);\n    }, new BN(0))); // get the maximum of the locks according to https://github.com/paritytech/substrate/blob/master/srml/balances/src/lib.rs#L699\n\n    var notAll = lockedBreakdown.filter(function (_ref5) {\n      var amount = _ref5.amount;\n      return !amount.isMax();\n    });\n\n    if (notAll.length) {\n      lockedBalance = api.registry.createType('Balance', bnMax.apply(void 0, _toConsumableArray(notAll.map(function (_ref6) {\n        var amount = _ref6.amount;\n        return amount;\n      }))));\n    }\n  }\n\n  return {\n    allLocked: allLocked,\n    lockedBalance: lockedBalance,\n    lockedBreakdown: lockedBreakdown,\n    vestingLocked: vestingLocked\n  };\n}\n\nfunction calcShared(api, bestNumber, data, locks) {\n  var _calcLocked = calcLocked(api, bestNumber, locks),\n      allLocked = _calcLocked.allLocked,\n      lockedBalance = _calcLocked.lockedBalance,\n      lockedBreakdown = _calcLocked.lockedBreakdown,\n      vestingLocked = _calcLocked.vestingLocked;\n\n  return _objectSpread(_objectSpread({}, data), {}, {\n    availableBalance: api.registry.createType('Balance', allLocked ? 0 : bnMax(new BN(0), data.freeBalance.sub(lockedBalance))),\n    lockedBalance: lockedBalance,\n    lockedBreakdown: lockedBreakdown,\n    vestingLocked: vestingLocked\n  });\n}\n\nfunction calcBalances(api, _ref7) {\n  var _ref8 = _slicedToArray(_ref7, 3),\n      data = _ref8[0],\n      bestNumber = _ref8[1],\n      _ref8$ = _slicedToArray(_ref8[2], 2),\n      vesting = _ref8$[0],\n      allLocks = _ref8$[1];\n\n  var shared = calcShared(api, bestNumber, data, allLocks[0]); // Calculate the vesting balances,\n  //  - offset = balance locked at startingBlock\n  //  - perBlock is the unlock amount\n\n  var _ref9 = vesting || api.registry.createType('VestingInfo'),\n      vestingTotal = _ref9.locked,\n      perBlock = _ref9.perBlock,\n      startingBlock = _ref9.startingBlock;\n\n  var isStarted = bestNumber.gt(startingBlock);\n  var vestedNow = isStarted ? perBlock.mul(bestNumber.sub(startingBlock)) : new BN(0);\n  var vestedBalance = vestedNow.gt(vestingTotal) ? vestingTotal : api.registry.createType('Balance', vestedNow);\n  var isVesting = isStarted && !shared.vestingLocked.isZero();\n  return _objectSpread(_objectSpread({}, shared), {}, {\n    accountId: data.accountId,\n    accountNonce: data.accountNonce,\n    additional: allLocks.filter(function (_, index) {\n      return index !== 0;\n    }).map(function (l, index) {\n      return calcShared(api, bestNumber, data.additional[index], l);\n    }),\n    isVesting: isVesting,\n    vestedBalance: vestedBalance,\n    vestedClaimable: api.registry.createType('Balance', isVesting ? shared.vestingLocked.sub(vestingTotal.sub(vestedBalance)) : 0),\n    vestingEndBlock: api.registry.createType('BlockNumber', isVesting ? vestingTotal.div(perBlock).add(startingBlock) : 0),\n    vestingPerBlock: perBlock,\n    vestingTotal: vestingTotal\n  });\n} // old\n\n\nfunction queryOld(api, accountId) {\n  return api.queryMulti([[api.query.balances.locks, accountId], [api.query.balances.vesting, accountId]]).pipe(map(function (_ref10) {\n    var _ref11 = _slicedToArray(_ref10, 2),\n        locks = _ref11[0],\n        optVesting = _ref11[1];\n\n    var vestingNew = null;\n\n    if (optVesting.isSome) {\n      var _optVesting$unwrap = optVesting.unwrap(),\n          locked = _optVesting$unwrap.offset,\n          perBlock = _optVesting$unwrap.perBlock,\n          startingBlock = _optVesting$unwrap.startingBlock;\n\n      vestingNew = api.registry.createType('VestingInfo', {\n        locked: locked,\n        perBlock: perBlock,\n        startingBlock: startingBlock\n      });\n    }\n\n    return [vestingNew, [locks]];\n  }));\n}\n\nvar isNonNullable = function isNonNullable(nullable) {\n  return !!nullable;\n}; // current (balances, vesting)\n\n\nfunction queryCurrent(api, accountId) {\n  var balanceInstances = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ['balances'];\n\n  var _api$query$vesting;\n\n  var lockCalls = balanceInstances.map(function (m) {\n    var _m, _api$query;\n\n    return ((_m = api.derive[m]) === null || _m === void 0 ? void 0 : _m.customLocks) || ((_api$query = api.query[m]) === null || _api$query === void 0 ? void 0 : _api$query.locks);\n  });\n  var lockEmpty = lockCalls.map(function (c) {\n    return !c;\n  });\n  var lockQueries = lockCalls.filter(isNonNullable).map(function (c) {\n    return [c, accountId];\n  });\n  return ((_api$query$vesting = api.query.vesting) !== null && _api$query$vesting !== void 0 && _api$query$vesting.vesting ? api.queryMulti([[api.query.vesting.vesting, accountId]].concat(_toConsumableArray(lockQueries))) // TODO We need to check module instances here as well, not only the balances module\n  : lockQueries.length ? api.queryMulti(lockQueries).pipe(map(function (locks) {\n    return [api.registry.createType('Option<VestingInfo>')].concat(_toConsumableArray(locks));\n  })) : of([api.registry.createType('Option<VestingInfo>')])).pipe(map(function (_ref12) {\n    var _ref13 = _toArray(_ref12),\n        optVesting = _ref13[0],\n        locks = _ref13.slice(1);\n\n    var offset = -1;\n    return [optVesting.unwrapOr(null), lockEmpty.map(function (e) {\n      return e ? api.registry.createType('Vec<BalanceLock>') : locks[++offset];\n    })];\n  }));\n}\n/**\n * @name all\n * @param {( AccountIndex | AccountId | Address | string )} address - An accounts Id in different formats.\n * @returns An object containing the results of various balance queries\n * @example\n * <BR>\n *\n * ```javascript\n * const ALICE = 'F7Hs';\n *\n * api.derive.balances.all(ALICE, ({ accountId, lockedBalance }) => {\n *   console.log(`The account ${accountId} has a locked balance ${lockedBalance} units.`);\n * });\n * ```\n */\n\n\nexport function all(instanceId, api) {\n  var balanceInstances = api.registry.getModuleInstances(api.runtimeVersion.specName.toString(), 'balances');\n  return memo(instanceId, function (address) {\n    return api.derive.balances.account(address).pipe(switchMap(function (account) {\n      var _api$query$system, _api$query$balances;\n\n      return !account.accountId.isEmpty ? combineLatest([of(account), api.derive.chain.bestNumber(), isFunction((_api$query$system = api.query.system) === null || _api$query$system === void 0 ? void 0 : _api$query$system.account) || isFunction((_api$query$balances = api.query.balances) === null || _api$query$balances === void 0 ? void 0 : _api$query$balances.account) ? queryCurrent(api, account.accountId, balanceInstances) : queryOld(api, account.accountId)]) : of([account, api.registry.createType('BlockNumber'), [null, []]]);\n    }), map(function (result) {\n      return calcBalances(api, result);\n    }));\n  });\n}","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { assert, compactAddLength, compactFromU8a, isHex, isU8a, u8aConcat, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { Base } from \"../codec/Base.js\";\nimport { BIT_SIGNED, BIT_UNSIGNED, DEFAULT_VERSION, UNMASK_VERSION } from \"./constants.js\";\nvar VERSIONS = ['ExtrinsicUnknown', // v0 is unknown\n'ExtrinsicUnknown', 'ExtrinsicUnknown', 'ExtrinsicUnknown', 'ExtrinsicV4'];\nexport { EXTRINSIC_VERSION as LATEST_EXTRINSIC_VERSION } from \"./v4/Extrinsic.js\";\n\nvar ExtrinsicBase = /*#__PURE__*/function (_Base) {\n  _inherits(ExtrinsicBase, _Base);\n\n  var _super = _createSuper(ExtrinsicBase);\n\n  function ExtrinsicBase() {\n    _classCallCheck(this, ExtrinsicBase);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(ExtrinsicBase, [{\n    key: \"args\",\n    get:\n    /**\n     * @description The arguments passed to for the call, exposes args so it is compatible with [[Call]]\n     */\n    function get() {\n      return this.method.args;\n    }\n    /**\n     * @description The argument definitions, compatible with [[Call]]\n     */\n\n  }, {\n    key: \"argsDef\",\n    get: function get() {\n      return this.method.argsDef;\n    }\n    /**\n     * @description The actual `[sectionIndex, methodIndex]` as used in the Call\n     */\n\n  }, {\n    key: \"callIndex\",\n    get: function get() {\n      return this.method.callIndex;\n    }\n    /**\n     * @description The actual data for the Call\n     */\n\n  }, {\n    key: \"data\",\n    get: function get() {\n      return this.method.data;\n    }\n    /**\n     * @description The era for this extrinsic\n     */\n\n  }, {\n    key: \"era\",\n    get: function get() {\n      return this._raw.signature.era;\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n\n  }, {\n    key: \"encodedLength\",\n    get: function get() {\n      return this.toU8a().length;\n    }\n    /**\n     * @description `true` id the extrinsic is signed\n     */\n\n  }, {\n    key: \"isSigned\",\n    get: function get() {\n      return this._raw.signature.isSigned;\n    }\n    /**\n     * @description The length of the actual data, excluding prefix\n     */\n\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.toU8a(true).length;\n    }\n    /**\n     * @description The [[FunctionMetadataLatest]] that describes the extrinsic\n     */\n\n  }, {\n    key: \"meta\",\n    get: function get() {\n      return this.method.meta;\n    }\n    /**\n     * @description The [[Call]] this extrinsic wraps\n     */\n\n  }, {\n    key: \"method\",\n    get: function get() {\n      return this._raw.method;\n    }\n    /**\n     * @description The nonce for this extrinsic\n     */\n\n  }, {\n    key: \"nonce\",\n    get: function get() {\n      return this._raw.signature.nonce;\n    }\n    /**\n     * @description The actual [[EcdsaSignature]], [[Ed25519Signature]] or [[Sr25519Signature]]\n     */\n\n  }, {\n    key: \"signature\",\n    get: function get() {\n      return this._raw.signature.signature;\n    }\n    /**\n     * @description The [[Address]] that signed\n     */\n\n  }, {\n    key: \"signer\",\n    get: function get() {\n      return this._raw.signature.signer;\n    }\n    /**\n     * @description Forwards compat\n     */\n\n  }, {\n    key: \"tip\",\n    get: function get() {\n      return this._raw.signature.tip;\n    }\n    /**\n     * @description Returns the raw transaction version (not flagged with signing information)\n    */\n\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._raw.version;\n    }\n    /**\n     * @description Returns the encoded version flag\n    */\n\n  }, {\n    key: \"version\",\n    get: function get() {\n      return this.type | (this.isSigned ? BIT_SIGNED : BIT_UNSIGNED);\n    }\n    /**\n     * @description Checks if the source matches this in type\n     */\n\n  }, {\n    key: \"is\",\n    value: function is(other) {\n      return this.method.is(other);\n    }\n  }]);\n\n  return ExtrinsicBase;\n}(Base);\n/**\n * @name GenericExtrinsic\n * @description\n * Representation of an Extrinsic in the system. It contains the actual call,\n * (optional) signature and encodes with an actual length prefix\n *\n * {@link https://github.com/paritytech/wiki/blob/master/Extrinsic.md#the-extrinsic-format-for-node}.\n *\n * Can be:\n * - signed, to create a transaction\n * - left as is, to create an inherent\n */\n\n\nexport var GenericExtrinsic = /*#__PURE__*/function (_ExtrinsicBase) {\n  _inherits(GenericExtrinsic, _ExtrinsicBase);\n\n  var _super2 = _createSuper(GenericExtrinsic);\n\n  function GenericExtrinsic(registry, value) {\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        version = _ref.version;\n\n    _classCallCheck(this, GenericExtrinsic);\n\n    return _super2.call(this, registry, GenericExtrinsic._decodeExtrinsic(registry, value, version));\n  }\n  /** @internal */\n\n\n  _createClass(GenericExtrinsic, [{\n    key: \"addSignature\",\n    value:\n    /**\n     * @description Injects an already-generated signature into the extrinsic\n     */\n    function addSignature(signer, signature, payload) {\n      this._raw.addSignature(signer, signature, payload);\n\n      return this;\n    }\n    /**\n     * @description Sign the extrinsic with a specific keypair\n     */\n\n  }, {\n    key: \"sign\",\n    value: function sign(account, options) {\n      this._raw.sign(account, options);\n\n      return this;\n    }\n    /**\n     * @describe Adds a fake signature to the extrinsic\n     */\n\n  }, {\n    key: \"signFake\",\n    value: function signFake(signer, options) {\n      this._raw.signFake(signer, options);\n\n      return this;\n    }\n    /**\n     * @description Returns a hex string representation of the value\n     */\n\n  }, {\n    key: \"toHex\",\n    value: function toHex(isBare) {\n      return u8aToHex(this.toU8a(isBare));\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n\n  }, {\n    key: \"toHuman\",\n    value: function toHuman(isExpanded) {\n      return _objectSpread({\n        isSigned: this.isSigned,\n        method: this.method.toHuman(isExpanded)\n      }, this.isSigned ? {\n        era: this.era.toHuman(isExpanded),\n        nonce: this.nonce.toHuman(isExpanded),\n        signature: this.signature.toHex(),\n        signer: this.signer.toHuman(isExpanded),\n        tip: this.tip.toHuman(isExpanded)\n      } : {});\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.toHex();\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n\n  }, {\n    key: \"toRawType\",\n    value: function toRawType() {\n      return 'Extrinsic';\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value is not length-prefixed\n     */\n\n  }, {\n    key: \"toU8a\",\n    value: function toU8a(isBare) {\n      // we do not apply bare to the internal values, rather this only determines out length addition,\n      // where we strip all lengths this creates an extrinsic that cannot be decoded\n      var encoded = u8aConcat(new Uint8Array([this.version]), this._raw.toU8a());\n      return isBare ? encoded : compactAddLength(encoded);\n    }\n  }], [{\n    key: \"_newFromValue\",\n    value: function _newFromValue(registry, value, version) {\n      if (value instanceof GenericExtrinsic) {\n        return value._raw;\n      }\n\n      var isSigned = (version & BIT_SIGNED) === BIT_SIGNED;\n      var type = VERSIONS[version & UNMASK_VERSION] || VERSIONS[0]; // we cast here since the VERSION definition is incredibly broad - we don't have a\n      // slice for \"only add extrinsic types\", and more string definitions become unwieldy\n\n      return registry.createType(type, value, {\n        isSigned: isSigned,\n        version: version\n      });\n    }\n    /** @internal */\n\n  }, {\n    key: \"_decodeExtrinsic\",\n    value: function _decodeExtrinsic(registry, value) {\n      var version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_VERSION;\n\n      if (isU8a(value) || Array.isArray(value) || isHex(value)) {\n        return GenericExtrinsic._decodeU8a(registry, u8aToU8a(value), version);\n      } else if (value instanceof registry.createClass('Call')) {\n        return GenericExtrinsic._newFromValue(registry, {\n          method: value\n        }, version);\n      }\n\n      return GenericExtrinsic._newFromValue(registry, value, version);\n    }\n    /** @internal */\n\n  }, {\n    key: \"_decodeU8a\",\n    value: function _decodeU8a(registry, value, version) {\n      if (!value.length) {\n        return GenericExtrinsic._newFromValue(registry, new Uint8Array(), version);\n      }\n\n      var _compactFromU8a = compactFromU8a(value),\n          _compactFromU8a2 = _slicedToArray(_compactFromU8a, 2),\n          offset = _compactFromU8a2[0],\n          length = _compactFromU8a2[1];\n\n      var total = offset + length.toNumber();\n      assert(total <= value.length, \"Extrinsic: length less than remainder, expected at least \".concat(total, \", found \").concat(value.length));\n      var data = value.subarray(offset, total);\n      return GenericExtrinsic._newFromValue(registry, data.subarray(1), data[0]);\n    }\n  }]);\n\n  return GenericExtrinsic;\n}(ExtrinsicBase);","map":null,"metadata":{},"sourceType":"module"}
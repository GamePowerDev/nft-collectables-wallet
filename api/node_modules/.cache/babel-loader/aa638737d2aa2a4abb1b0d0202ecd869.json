{"ast":null,"code":"// Copyright 2017-2021 @polkadot/metadata authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// we are attempting to avoid circular refs, hence the path import\nimport { getTypeDef } from '@polkadot/types/create/getTypeDef';\nimport { TypeDefInfo } from '@polkadot/types/types';\n/** @internal */\n\nexport function extractTypes(types) {\n  return types.map(function (type) {\n    var decoded = getTypeDef(type);\n\n    switch (decoded.info) {\n      case TypeDefInfo.Plain:\n        return decoded.type;\n\n      case TypeDefInfo.BTreeSet:\n      case TypeDefInfo.Compact:\n      case TypeDefInfo.Option:\n      case TypeDefInfo.Vec:\n      case TypeDefInfo.VecFixed:\n        return extractTypes([decoded.sub.type]);\n\n      case TypeDefInfo.BTreeMap:\n      case TypeDefInfo.HashMap:\n      case TypeDefInfo.Result:\n      case TypeDefInfo.Tuple:\n        return extractTypes(decoded.sub.map(function (_ref) {\n          var type = _ref.type;\n          return type;\n        }));\n\n      default:\n        throw new Error(\"Unhandled: Unable to create and validate type from \".concat(type));\n    }\n  });\n}","map":null,"metadata":{},"sourceType":"module"}
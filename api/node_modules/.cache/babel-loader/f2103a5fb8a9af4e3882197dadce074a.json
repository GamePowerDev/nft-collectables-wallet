{"ast":null,"code":"import _regeneratorRuntime from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/rpc-provider authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable camelcase */\n\n\nimport EventEmitter from 'eventemitter3';\nimport { assert, isChildClass, isNull, isUndefined, logger } from '@polkadot/util';\nimport { xglobal } from '@polkadot/x-global';\nimport { WebSocket } from '@polkadot/x-ws';\nimport { RpcCoder } from \"../coder/index.js\";\nimport defaults from \"../defaults.js\";\nimport { getWSErrorString } from \"./errors.js\";\nvar ALIASSES = {\n  chain_finalisedHead: 'chain_finalizedHead',\n  chain_subscribeFinalisedHeads: 'chain_subscribeFinalizedHeads',\n  chain_unsubscribeFinalisedHeads: 'chain_unsubscribeFinalizedHeads'\n};\nvar RETRY_DELAY = 1000;\nvar l = logger('api-ws');\n\nfunction eraseRecord(record, cb) {\n  Object.keys(record).forEach(function (key) {\n    if (cb) {\n      cb(record[key]);\n    }\n\n    delete record[key];\n  });\n}\n/**\n * # @polkadot/rpc-provider/ws\n *\n * @name WsProvider\n *\n * @description The WebSocket Provider allows sending requests using WebSocket to a WebSocket RPC server TCP port. Unlike the [[HttpProvider]], it does support subscriptions and allows listening to events such as new blocks or balance changes.\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Api from '@polkadot/api/promise';\n * import { WsProvider } from '@polkadot/rpc-provider/ws';\n *\n * const provider = new WsProvider('ws://127.0.0.1:9944');\n * const api = new Api(provider);\n * ```\n *\n * @see [[HttpProvider]]\n */\n\n\nvar _coder = _classPrivateFieldLooseKey(\"coder\");\n\nvar _endpoints = _classPrivateFieldLooseKey(\"endpoints\");\n\nvar _headers = _classPrivateFieldLooseKey(\"headers\");\n\nvar _eventemitter = _classPrivateFieldLooseKey(\"eventemitter\");\n\nvar _handlers = _classPrivateFieldLooseKey(\"handlers\");\n\nvar _isReadyPromise = _classPrivateFieldLooseKey(\"isReadyPromise\");\n\nvar _waitingForId = _classPrivateFieldLooseKey(\"waitingForId\");\n\nvar _autoConnectMs = _classPrivateFieldLooseKey(\"autoConnectMs\");\n\nvar _endpointIndex = _classPrivateFieldLooseKey(\"endpointIndex\");\n\nvar _isConnected = _classPrivateFieldLooseKey(\"isConnected\");\n\nvar _subscriptions = _classPrivateFieldLooseKey(\"subscriptions\");\n\nvar _websocket = _classPrivateFieldLooseKey(\"websocket\");\n\nvar _emit = _classPrivateFieldLooseKey(\"emit\");\n\nvar _onSocketClose = _classPrivateFieldLooseKey(\"onSocketClose\");\n\nvar _onSocketError = _classPrivateFieldLooseKey(\"onSocketError\");\n\nvar _onSocketMessage = _classPrivateFieldLooseKey(\"onSocketMessage\");\n\nvar _onSocketMessageResult = _classPrivateFieldLooseKey(\"onSocketMessageResult\");\n\nvar _onSocketMessageSubscribe = _classPrivateFieldLooseKey(\"onSocketMessageSubscribe\");\n\nvar _onSocketOpen = _classPrivateFieldLooseKey(\"onSocketOpen\");\n\nvar _resubscribe = _classPrivateFieldLooseKey(\"resubscribe\");\n\nexport var WsProvider = /*#__PURE__*/function () {\n  /**\n   * @param {string | string[]}  endpoint    The endpoint url. Usually `ws://ip:9944` or `wss://ip:9944`, may provide an array of endpoint strings.\n   * @param {boolean} autoConnect Whether to connect automatically or not.\n   */\n  function WsProvider() {\n    var _this = this;\n\n    var endpoint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaults.WS_URL;\n    var autoConnectMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : RETRY_DELAY;\n    var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, WsProvider);\n\n    Object.defineProperty(this, _coder, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _endpoints, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _headers, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _eventemitter, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _handlers, {\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, _isReadyPromise, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _waitingForId, {\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, _autoConnectMs, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _endpointIndex, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _isConnected, {\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, _subscriptions, {\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, _websocket, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _emit, {\n      writable: true,\n      value: function value(type) {\n        var _classPrivateFieldLoo;\n\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        (_classPrivateFieldLoo = _classPrivateFieldLooseBase(_this, _eventemitter)[_eventemitter]).emit.apply(_classPrivateFieldLoo, [type].concat(args));\n      }\n    });\n    Object.defineProperty(this, _onSocketClose, {\n      writable: true,\n      value: function value(event) {\n        var error = new Error(\"disconnected from \".concat(_classPrivateFieldLooseBase(_this, _endpoints)[_endpoints][_classPrivateFieldLooseBase(_this, _endpointIndex)[_endpointIndex]], \": \").concat(event.code, \":: \").concat(event.reason || getWSErrorString(event.code)));\n\n        if (_classPrivateFieldLooseBase(_this, _autoConnectMs)[_autoConnectMs] > 0) {\n          l.error(error.message);\n        }\n\n        _classPrivateFieldLooseBase(_this, _isConnected)[_isConnected] = false;\n\n        _classPrivateFieldLooseBase(_this, _emit)[_emit]('disconnected'); // reject all hanging requests\n\n\n        eraseRecord(_classPrivateFieldLooseBase(_this, _handlers)[_handlers], function (handler) {\n          return handler.callback(error, undefined);\n        });\n        eraseRecord(_classPrivateFieldLooseBase(_this, _waitingForId)[_waitingForId]);\n\n        if (_classPrivateFieldLooseBase(_this, _autoConnectMs)[_autoConnectMs] > 0) {\n          setTimeout(function () {\n            _this.connectWithRetry().catch(function () {// does not throw\n            });\n          }, _classPrivateFieldLooseBase(_this, _autoConnectMs)[_autoConnectMs]);\n        }\n      }\n    });\n    Object.defineProperty(this, _onSocketError, {\n      writable: true,\n      value: function value(error) {\n        l.debug(function () {\n          return ['socket error', error];\n        });\n\n        _classPrivateFieldLooseBase(_this, _emit)[_emit]('error', error);\n      }\n    });\n    Object.defineProperty(this, _onSocketMessage, {\n      writable: true,\n      value: function value(message) {\n        l.debug(function () {\n          return ['received', message.data];\n        });\n        var response = JSON.parse(message.data);\n        return isUndefined(response.method) ? _classPrivateFieldLooseBase(_this, _onSocketMessageResult)[_onSocketMessageResult](response) : _classPrivateFieldLooseBase(_this, _onSocketMessageSubscribe)[_onSocketMessageSubscribe](response);\n      }\n    });\n    Object.defineProperty(this, _onSocketMessageResult, {\n      writable: true,\n      value: function value(response) {\n        var handler = _classPrivateFieldLooseBase(_this, _handlers)[_handlers][response.id];\n\n        if (!handler) {\n          l.debug(function () {\n            return \"Unable to find handler for id=\".concat(response.id);\n          });\n          return;\n        }\n\n        try {\n          var method = handler.method,\n              params = handler.params,\n              subscription = handler.subscription;\n\n          var result = _classPrivateFieldLooseBase(_this, _coder)[_coder].decodeResponse(response); // first send the result - in case of subs, we may have an update\n          // immediately if we have some queued results already\n\n\n          handler.callback(null, result);\n\n          if (subscription) {\n            var subId = \"\".concat(subscription.type, \"::\").concat(result);\n            _classPrivateFieldLooseBase(_this, _subscriptions)[_subscriptions][subId] = _objectSpread(_objectSpread({}, subscription), {}, {\n              method: method,\n              params: params\n            }); // if we have a result waiting for this subscription already\n\n            if (_classPrivateFieldLooseBase(_this, _waitingForId)[_waitingForId][subId]) {\n              _classPrivateFieldLooseBase(_this, _onSocketMessageSubscribe)[_onSocketMessageSubscribe](_classPrivateFieldLooseBase(_this, _waitingForId)[_waitingForId][subId]);\n            }\n          }\n        } catch (error) {\n          handler.callback(error, undefined);\n        }\n\n        delete _classPrivateFieldLooseBase(_this, _handlers)[_handlers][response.id];\n      }\n    });\n    Object.defineProperty(this, _onSocketMessageSubscribe, {\n      writable: true,\n      value: function value(response) {\n        var method = ALIASSES[response.method] || response.method || 'invalid';\n        var subId = \"\".concat(method, \"::\").concat(response.params.subscription);\n\n        var handler = _classPrivateFieldLooseBase(_this, _subscriptions)[_subscriptions][subId];\n\n        if (!handler) {\n          // store the JSON, we could have out-of-order subid coming in\n          _classPrivateFieldLooseBase(_this, _waitingForId)[_waitingForId][subId] = response;\n          l.debug(function () {\n            return \"Unable to find handler for subscription=\".concat(subId);\n          });\n          return;\n        } // housekeeping\n\n\n        delete _classPrivateFieldLooseBase(_this, _waitingForId)[_waitingForId][subId];\n\n        try {\n          var result = _classPrivateFieldLooseBase(_this, _coder)[_coder].decodeResponse(response);\n\n          handler.callback(null, result);\n        } catch (error) {\n          handler.callback(error, undefined);\n        }\n      }\n    });\n    Object.defineProperty(this, _onSocketOpen, {\n      writable: true,\n      value: function value() {\n        assert(!isNull(_classPrivateFieldLooseBase(_this, _websocket)[_websocket]), 'WebSocket cannot be null in onOpen');\n        l.debug(function () {\n          return ['connected to', _classPrivateFieldLooseBase(_this, _endpoints)[_endpoints][_classPrivateFieldLooseBase(_this, _endpointIndex)[_endpointIndex]]];\n        });\n        _classPrivateFieldLooseBase(_this, _isConnected)[_isConnected] = true;\n\n        _classPrivateFieldLooseBase(_this, _emit)[_emit]('connected');\n\n        _classPrivateFieldLooseBase(_this, _resubscribe)[_resubscribe]();\n\n        return true;\n      }\n    });\n    Object.defineProperty(this, _resubscribe, {\n      writable: true,\n      value: function value() {\n        var subscriptions = _classPrivateFieldLooseBase(_this, _subscriptions)[_subscriptions];\n\n        _classPrivateFieldLooseBase(_this, _subscriptions)[_subscriptions] = {};\n        Promise.all(Object.keys(subscriptions).map( /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(id) {\n            var _subscriptions$id, callback, method, params, type;\n\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    _subscriptions$id = subscriptions[id], callback = _subscriptions$id.callback, method = _subscriptions$id.method, params = _subscriptions$id.params, type = _subscriptions$id.type; // only re-create subscriptions which are not in author (only area where\n                    // transactions are created, i.e. submissions such as 'author_submitAndWatchExtrinsic'\n                    // are not included (and will not be re-broadcast)\n\n                    if (!type.startsWith('author_')) {\n                      _context.next = 3;\n                      break;\n                    }\n\n                    return _context.abrupt(\"return\");\n\n                  case 3:\n                    _context.prev = 3;\n                    _context.next = 6;\n                    return _this.subscribe(type, method, params, callback);\n\n                  case 6:\n                    _context.next = 11;\n                    break;\n\n                  case 8:\n                    _context.prev = 8;\n                    _context.t0 = _context[\"catch\"](3);\n                    l.error(_context.t0);\n\n                  case 11:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, _callee, null, [[3, 8]]);\n          }));\n\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }())).catch(l.error);\n      }\n    });\n    var endpoints = Array.isArray(endpoint) ? endpoint : [endpoint];\n    assert(endpoints.length !== 0, 'WsProvider requires at least one Endpoint');\n    endpoints.forEach(function (endpoint) {\n      assert(/^(wss|ws):\\/\\//.test(endpoint), \"Endpoint should start with 'ws://', received '\".concat(endpoint, \"'\"));\n    });\n    _classPrivateFieldLooseBase(this, _eventemitter)[_eventemitter] = new EventEmitter();\n    _classPrivateFieldLooseBase(this, _autoConnectMs)[_autoConnectMs] = autoConnectMs || 0;\n    _classPrivateFieldLooseBase(this, _coder)[_coder] = new RpcCoder();\n    _classPrivateFieldLooseBase(this, _endpointIndex)[_endpointIndex] = -1;\n    _classPrivateFieldLooseBase(this, _endpoints)[_endpoints] = endpoints;\n    _classPrivateFieldLooseBase(this, _headers)[_headers] = headers;\n    _classPrivateFieldLooseBase(this, _websocket)[_websocket] = null;\n\n    if (autoConnectMs > 0) {\n      this.connectWithRetry().catch(function () {// does not throw\n      });\n    }\n\n    _classPrivateFieldLooseBase(this, _isReadyPromise)[_isReadyPromise] = new Promise(function (resolve) {\n      _classPrivateFieldLooseBase(_this, _eventemitter)[_eventemitter].once('connected', function () {\n        resolve(_this);\n      });\n    });\n  }\n  /**\n   * @summary `true` when this provider supports subscriptions\n   */\n\n\n  _createClass(WsProvider, [{\n    key: \"hasSubscriptions\",\n    get: function get() {\n      return true;\n    }\n    /**\n     * @summary Whether the node is connected or not.\n     * @return {boolean} true if connected\n     */\n\n  }, {\n    key: \"isConnected\",\n    get: function get() {\n      return _classPrivateFieldLooseBase(this, _isConnected)[_isConnected];\n    }\n    /**\n     * @description Promise that resolves the first time we are connected and loaded\n     */\n\n  }, {\n    key: \"isReady\",\n    get: function get() {\n      return _classPrivateFieldLooseBase(this, _isReadyPromise)[_isReadyPromise];\n    }\n    /**\n     * @description Returns a clone of the object\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new WsProvider(_classPrivateFieldLooseBase(this, _endpoints)[_endpoints]);\n    }\n    /**\n     * @summary Manually connect\n     * @description The [[WsProvider]] connects automatically by default, however if you decided otherwise, you may\n     * connect manually using this method.\n     */\n    // eslint-disable-next-line @typescript-eslint/require-await\n\n  }, {\n    key: \"connect\",\n    value: function () {\n      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _classPrivateFieldLooseBase(this, _endpointIndex)[_endpointIndex] = (_classPrivateFieldLooseBase(this, _endpointIndex)[_endpointIndex] + 1) % _classPrivateFieldLooseBase(this, _endpoints)[_endpoints].length;\n                _classPrivateFieldLooseBase(this, _websocket)[_websocket] = typeof xglobal.WebSocket !== 'undefined' && isChildClass(xglobal.WebSocket, WebSocket) ? new WebSocket(_classPrivateFieldLooseBase(this, _endpoints)[_endpoints][_classPrivateFieldLooseBase(this, _endpointIndex)[_endpointIndex]]) // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore - WS may be an instance of w3cwebsocket, which supports headers\n                : new WebSocket(_classPrivateFieldLooseBase(this, _endpoints)[_endpoints][_classPrivateFieldLooseBase(this, _endpointIndex)[_endpointIndex]], undefined, undefined, _classPrivateFieldLooseBase(this, _headers)[_headers], undefined, {\n                  // default: true\n                  fragmentOutgoingMessages: true,\n                  // default: 16K\n                  fragmentationThreshold: 256 * 1024\n                });\n                _classPrivateFieldLooseBase(this, _websocket)[_websocket].onclose = _classPrivateFieldLooseBase(this, _onSocketClose)[_onSocketClose];\n                _classPrivateFieldLooseBase(this, _websocket)[_websocket].onerror = _classPrivateFieldLooseBase(this, _onSocketError)[_onSocketError];\n                _classPrivateFieldLooseBase(this, _websocket)[_websocket].onmessage = _classPrivateFieldLooseBase(this, _onSocketMessage)[_onSocketMessage];\n                _classPrivateFieldLooseBase(this, _websocket)[_websocket].onopen = _classPrivateFieldLooseBase(this, _onSocketOpen)[_onSocketOpen];\n                _context2.next = 14;\n                break;\n\n              case 9:\n                _context2.prev = 9;\n                _context2.t0 = _context2[\"catch\"](0);\n                l.error(_context2.t0);\n\n                _classPrivateFieldLooseBase(this, _emit)[_emit]('error', _context2.t0);\n\n                throw _context2.t0;\n\n              case 14:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[0, 9]]);\n      }));\n\n      function connect() {\n        return _connect.apply(this, arguments);\n      }\n\n      return connect;\n    }()\n    /**\n     * @description Connect, never throwing an error, but rather forcing a retry\n     */\n\n  }, {\n    key: \"connectWithRetry\",\n    value: function () {\n      var _connectWithRetry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(_classPrivateFieldLooseBase(this, _autoConnectMs)[_autoConnectMs] > 0)) {\n                  _context3.next = 9;\n                  break;\n                }\n\n                _context3.prev = 1;\n                _context3.next = 4;\n                return this.connect();\n\n              case 4:\n                _context3.next = 9;\n                break;\n\n              case 6:\n                _context3.prev = 6;\n                _context3.t0 = _context3[\"catch\"](1);\n                setTimeout(function () {\n                  _this2.connectWithRetry().catch(function () {// does not throw\n                  });\n                }, _classPrivateFieldLooseBase(this, _autoConnectMs)[_autoConnectMs]);\n\n              case 9:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[1, 6]]);\n      }));\n\n      function connectWithRetry() {\n        return _connectWithRetry.apply(this, arguments);\n      }\n\n      return connectWithRetry;\n    }()\n    /**\n     * @description Manually disconnect from the connection, clearing autoconnect logic\n     */\n    // eslint-disable-next-line @typescript-eslint/require-await\n\n  }, {\n    key: \"disconnect\",\n    value: function () {\n      var _disconnect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.prev = 0;\n                assert(!isNull(_classPrivateFieldLooseBase(this, _websocket)[_websocket]), 'Cannot disconnect on a non-connected websocket'); // switch off autoConnect, we are in manual mode now\n\n                _classPrivateFieldLooseBase(this, _autoConnectMs)[_autoConnectMs] = 0; // 1000 - Normal closure; the connection successfully completed\n\n                _classPrivateFieldLooseBase(this, _websocket)[_websocket].close(1000);\n\n                _classPrivateFieldLooseBase(this, _websocket)[_websocket] = null;\n                _context4.next = 12;\n                break;\n\n              case 7:\n                _context4.prev = 7;\n                _context4.t0 = _context4[\"catch\"](0);\n                l.error(_context4.t0);\n\n                _classPrivateFieldLooseBase(this, _emit)[_emit]('error', _context4.t0);\n\n                throw _context4.t0;\n\n              case 12:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[0, 7]]);\n      }));\n\n      function disconnect() {\n        return _disconnect.apply(this, arguments);\n      }\n\n      return disconnect;\n    }()\n    /**\n     * @summary Listens on events after having subscribed using the [[subscribe]] function.\n     * @param  {ProviderInterfaceEmitted} type Event\n     * @param  {ProviderInterfaceEmitCb}  sub  Callback\n     * @return unsubscribe function\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(type, sub) {\n      var _this3 = this;\n\n      _classPrivateFieldLooseBase(this, _eventemitter)[_eventemitter].on(type, sub);\n\n      return function () {\n        _classPrivateFieldLooseBase(_this3, _eventemitter)[_eventemitter].removeListener(type, sub);\n      };\n    }\n    /**\n     * @summary Send JSON data using WebSockets to configured HTTP Endpoint or queue.\n     * @param method The RPC methods to execute\n     * @param params Encoded parameters as applicable for the method\n     * @param subscription Subscription details (internally used)\n     */\n\n  }, {\n    key: \"send\",\n    value: function send(method, params, subscription) {\n      var _this4 = this;\n\n      return new Promise(function (resolve, reject) {\n        try {\n          assert(_this4.isConnected && !isNull(_classPrivateFieldLooseBase(_this4, _websocket)[_websocket]), 'WebSocket is not connected');\n\n          var json = _classPrivateFieldLooseBase(_this4, _coder)[_coder].encodeJson(method, params);\n\n          var id = _classPrivateFieldLooseBase(_this4, _coder)[_coder].getId();\n\n          var callback = function callback(error, result) {\n            error ? reject(error) : resolve(result);\n          };\n\n          l.debug(function () {\n            return ['calling', method, json];\n          });\n          _classPrivateFieldLooseBase(_this4, _handlers)[_handlers][id] = {\n            callback: callback,\n            method: method,\n            params: params,\n            subscription: subscription\n          };\n\n          _classPrivateFieldLooseBase(_this4, _websocket)[_websocket].send(json);\n        } catch (error) {\n          reject(error);\n        }\n      });\n    }\n    /**\n     * @name subscribe\n     * @summary Allows subscribing to a specific event.\n     * @param  {string}                     type     Subscription type\n     * @param  {string}                     method   Subscription method\n     * @param  {any[]}                 params   Parameters\n     * @param  {ProviderInterfaceCallback} callback Callback\n     * @return {Promise<number>}                     Promise resolving to the dd of the subscription you can use with [[unsubscribe]].\n     *\n     * @example\n     * <BR>\n     *\n     * ```javascript\n     * const provider = new WsProvider('ws://127.0.0.1:9944');\n     * const rpc = new Rpc(provider);\n     *\n     * rpc.state.subscribeStorage([[storage.system.account, <Address>]], (_, values) => {\n     *   console.log(values)\n     * }).then((subscriptionId) => {\n     *   console.log('balance changes subscription id: ', subscriptionId)\n     * })\n     * ```\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(type, method, params, callback) {\n      return this.send(method, params, {\n        callback: callback,\n        type: type\n      });\n    }\n    /**\n     * @summary Allows unsubscribing to subscriptions made with [[subscribe]].\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function () {\n      var _unsubscribe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(type, method, id) {\n        var subscription;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                subscription = \"\".concat(type, \"::\").concat(id); // FIXME This now could happen with re-subscriptions. The issue is that with a re-sub\n                // the assigned id now does not match what the API user originally received. It has\n                // a slight complication in solving - since we cannot rely on the send id, but rather\n                // need to find the actual subscription id to map it\n\n                if (!isUndefined(_classPrivateFieldLooseBase(this, _subscriptions)[_subscriptions][subscription])) {\n                  _context5.next = 4;\n                  break;\n                }\n\n                l.debug(function () {\n                  return \"Unable to find active subscription=\".concat(subscription);\n                });\n                return _context5.abrupt(\"return\", false);\n\n              case 4:\n                delete _classPrivateFieldLooseBase(this, _subscriptions)[_subscriptions][subscription];\n                _context5.prev = 5;\n                return _context5.abrupt(\"return\", this.isConnected && !isNull(_classPrivateFieldLooseBase(this, _websocket)[_websocket]) ? this.send(method, [id]) : true);\n\n              case 9:\n                _context5.prev = 9;\n                _context5.t0 = _context5[\"catch\"](5);\n                return _context5.abrupt(\"return\", false);\n\n              case 12:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[5, 9]]);\n      }));\n\n      function unsubscribe(_x2, _x3, _x4) {\n        return _unsubscribe.apply(this, arguments);\n      }\n\n      return unsubscribe;\n    }()\n  }]);\n\n  return WsProvider;\n}();","map":null,"metadata":{},"sourceType":"module"}
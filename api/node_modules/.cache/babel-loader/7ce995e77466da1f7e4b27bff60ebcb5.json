{"ast":null,"code":"import _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n// Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { combineLatest, of } from '@polkadot/x-rxjs';\nimport { map, switchMap } from '@polkadot/x-rxjs/operators';\nimport { memo } from \"../util/index.js\";\n\nfunction parseResult(api, _ref) {\n  var allIds = _ref.allIds,\n      allProposals = _ref.allProposals,\n      approvalIds = _ref.approvalIds,\n      councilProposals = _ref.councilProposals,\n      proposalCount = _ref.proposalCount;\n  var approvals = [];\n  var proposals = [];\n  var councilTreasury = councilProposals.filter(function (_ref2) {\n    var proposal = _ref2.proposal;\n    return api.tx.treasury.approveProposal.is(proposal) || api.tx.treasury.rejectProposal.is(proposal);\n  });\n  allIds.forEach(function (id, index) {\n    if (allProposals[index].isSome) {\n      var council = councilTreasury.filter(function (_ref3) {\n        var proposal = _ref3.proposal;\n        return id.eq(proposal.args[0]);\n      }).sort(function (a, b) {\n        return a.proposal.method.localeCompare(b.proposal.method);\n      });\n      var isApproval = approvalIds.some(function (approvalId) {\n        return approvalId.eq(id);\n      });\n      var derived = {\n        council: council,\n        id: id,\n        proposal: allProposals[index].unwrap()\n      };\n\n      if (isApproval) {\n        approvals.push(derived);\n      } else {\n        proposals.push(derived);\n      }\n    }\n  });\n  return {\n    approvals: approvals,\n    proposalCount: proposalCount,\n    proposals: proposals\n  };\n}\n\nfunction retrieveProposals(api, proposalCount, approvalIds) {\n  var proposalIds = [];\n  var count = proposalCount.toNumber();\n\n  var _loop = function _loop(index) {\n    if (!approvalIds.some(function (id) {\n      return id.eqn(index);\n    })) {\n      proposalIds.push(api.registry.createType('ProposalIndex', index));\n    }\n  };\n\n  for (var index = 0; index < count; index++) {\n    _loop(index);\n  }\n\n  var allIds = [].concat(proposalIds, _toConsumableArray(approvalIds));\n  return combineLatest([api.query.treasury.proposals.multi(allIds), api.derive.council ? api.derive.council.proposals() : of([])]).pipe(map(function (_ref4) {\n    var _ref5 = _slicedToArray(_ref4, 2),\n        allProposals = _ref5[0],\n        councilProposals = _ref5[1];\n\n    return parseResult(api, {\n      allIds: allIds,\n      allProposals: allProposals,\n      approvalIds: approvalIds,\n      councilProposals: councilProposals,\n      proposalCount: proposalCount\n    });\n  }));\n}\n/**\n * @description Retrieve all active and approved treasury proposals, along with their info\n */\n\n\nexport function proposals(instanceId, api) {\n  return memo(instanceId, function () {\n    return api.query.treasury ? combineLatest([api.query.treasury.proposalCount(), api.query.treasury.approvals()]).pipe(switchMap(function (_ref6) {\n      var _ref7 = _slicedToArray(_ref6, 2),\n          proposalCount = _ref7[0],\n          approvalIds = _ref7[1];\n\n      return retrieveProposals(api, proposalCount, approvalIds);\n    })) : of({\n      approvals: [],\n      proposalCount: api.registry.createType('ProposalIndex'),\n      proposals: []\n    });\n  });\n}","map":null,"metadata":{},"sourceType":"module"}
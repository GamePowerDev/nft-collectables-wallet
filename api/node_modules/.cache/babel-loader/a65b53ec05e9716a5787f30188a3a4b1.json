{"ast":null,"code":"import _regeneratorRuntime from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/rpc-core authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport \"./detectPackage.js\";\nimport { Option } from '@polkadot/types';\nimport { createClass, createTypeUnsafe } from '@polkadot/types/create';\nimport jsonrpc from '@polkadot/types/interfaces/jsonrpc';\nimport { assert, hexToU8a, isFunction, isNull, isUndefined, logger, memoize, u8aToU8a } from '@polkadot/util';\nimport { Observable } from '@polkadot/x-rxjs';\nimport { publishReplay, refCount } from '@polkadot/x-rxjs/operators';\nimport { drr, refCountDelay } from \"./util/index.js\";\nexport { packageInfo } from \"./packageInfo.js\";\nvar l = logger('rpc-core');\nvar EMPTY_META = {\n  fallback: undefined,\n  modifier: {\n    isOptional: true\n  },\n  type: {\n    asMap: {\n      linked: {\n        isTrue: false\n      }\n    },\n    isMap: false\n  }\n}; // utility method to create a nicely-formatted error\n\n/** @internal */\n\nfunction logErrorMessage(method, _ref3, error) {\n  var params = _ref3.params,\n      type = _ref3.type;\n  var inputs = params.map(function (_ref4) {\n    var isOptional = _ref4.isOptional,\n        name = _ref4.name,\n        type = _ref4.type;\n    return \"\".concat(name).concat(isOptional ? '?' : '', \": \").concat(type);\n  }).join(', ');\n  l.error(\"\".concat(method, \"(\").concat(inputs, \"): \").concat(type, \":: \").concat(error.message));\n}\n\nfunction isTreatAsHex(key) {\n  // :code is problematic - it does not have the length attached, which is\n  // unlike all other storage entries where it is indeed properly encoded\n  return ['0x3a636f6465'].includes(key.toHex());\n}\n/**\n * @name Rpc\n * @summary The API may use a HTTP or WebSockets provider.\n * @description It allows for querying a Polkadot Client Node.\n * WebSockets provider is recommended since HTTP provider only supports basic querying.\n *\n * ```mermaid\n * graph LR;\n *   A[Api] --> |WebSockets| B[WsProvider];\n *   B --> |endpoint| C[ws://127.0.0.1:9944]\n * ```\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Rpc from '@polkadot/rpc-core';\n * import { WsProvider } from '@polkadot/rpc-provider/ws';\n *\n * const provider = new WsProvider('ws://127.0.0.1:9944');\n * const rpc = new Rpc(provider);\n * ```\n */\n\n\nvar _instanceId = _classPrivateFieldLooseKey(\"instanceId\");\n\nvar _registryDefault = _classPrivateFieldLooseKey(\"registryDefault\");\n\nvar _getBlockRegistry = _classPrivateFieldLooseKey(\"getBlockRegistry\");\n\nvar _storageCache = _classPrivateFieldLooseKey(\"storageCache\");\n\nexport var RpcCore = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * Default constructor for the Api Object\n   * @param  {ProviderInterface} provider An API provider using HTTP or WebSocket\n   */\n  function RpcCore(instanceId, registry, provider) {\n    var _this$sections;\n\n    var userRpc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    _classCallCheck(this, RpcCore);\n\n    Object.defineProperty(this, _instanceId, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _registryDefault, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _getBlockRegistry, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _storageCache, {\n      writable: true,\n      value: new Map()\n    });\n    this.mapping = new Map();\n    this.provider = void 0;\n    this.sections = []; // eslint-disable-next-line @typescript-eslint/unbound-method\n\n    assert(provider && isFunction(provider.send), 'Expected Provider to API create');\n    _classPrivateFieldLooseBase(this, _instanceId)[_instanceId] = instanceId;\n    _classPrivateFieldLooseBase(this, _registryDefault)[_registryDefault] = registry;\n    this.provider = provider;\n    var sectionNames = Object.keys(jsonrpc); // these are the base keys (i.e. part of jsonrpc)\n\n    (_this$sections = this.sections).push.apply(_this$sections, _toConsumableArray(sectionNames)); // decorate all interfaces, defined and user on this instance\n\n\n    this.addUserInterfaces(userRpc);\n  }\n  /**\n   * @description Returns the connected status of a provider\n   */\n\n\n  _createClass(RpcCore, [{\n    key: \"isConnected\",\n    get: function get() {\n      return this.provider.isConnected;\n    }\n    /**\n     * @description Manually connect from the attached provider\n     */\n\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      return this.provider.connect();\n    }\n    /**\n     * @description Manually disconnect from the attached provider\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      return this.provider.disconnect();\n    }\n    /**\n     * @description Sets a registry swap (typically from Api)\n     */\n\n  }, {\n    key: \"setRegistrySwap\",\n    value: function setRegistrySwap(registrySwap) {\n      _classPrivateFieldLooseBase(this, _getBlockRegistry)[_getBlockRegistry] = registrySwap;\n    }\n  }, {\n    key: \"addUserInterfaces\",\n    value: function addUserInterfaces(userRpc) {\n      var _this$sections2,\n          _this = this;\n\n      // add any extra user-defined sections\n      (_this$sections2 = this.sections).push.apply(_this$sections2, _toConsumableArray(Object.keys(userRpc).filter(function (key) {\n        return !_this.sections.includes(key);\n      }))); // decorate the sections with base and user methods\n\n\n      this.sections.forEach(function (sectionName) {\n        var _ref, _ref2;\n\n        (_ref = _this)[_ref2 = sectionName] || (_ref[_ref2] = {});\n        var section = _this[sectionName];\n        Object.entries(_objectSpread(_objectSpread({}, _this._createInterface(sectionName, jsonrpc[sectionName] || {})), _this._createInterface(sectionName, userRpc[sectionName] || {}))).forEach(function (_ref5) {\n          var _ref6 = _slicedToArray(_ref5, 2),\n              key = _ref6[0],\n              value = _ref6[1];\n\n          section[key] || (section[key] = value);\n        });\n      });\n    }\n  }, {\n    key: \"_createInterface\",\n    value: function _createInterface(section, methods) {\n      var _this2 = this;\n\n      return Object.entries(methods).filter(function (_ref7) {\n        var _ref8 = _slicedToArray(_ref7, 2),\n            method = _ref8[0],\n            endpoint = _ref8[1].endpoint;\n\n        return !_this2.mapping.has(endpoint || \"\".concat(section, \"_\").concat(method));\n      }).reduce(function (exposed, _ref9) {\n        var _ref10 = _slicedToArray(_ref9, 2),\n            method = _ref10[0],\n            endpoint = _ref10[1].endpoint;\n\n        var def = methods[method];\n        var isSubscription = !!def.pubsub;\n        var jsonrpc = endpoint || \"\".concat(section, \"_\").concat(method);\n\n        _this2.mapping.set(jsonrpc, _objectSpread(_objectSpread({}, def), {}, {\n          isSubscription: isSubscription,\n          jsonrpc: jsonrpc,\n          method: method,\n          section: section\n        })); // FIXME Remove any here\n        // To do so, remove `RpcInterfaceMethod` from './types.ts', and refactor\n        // every method inside this class to take:\n        // `<S extends keyof RpcInterface, M extends keyof RpcInterface[S]>`\n        // Not doing so, because it makes this class a little bit less readable,\n        // and leaving it as-is doesn't harm much\n\n\n        exposed[method] = isSubscription ? _this2._createMethodSubscribe(section, method, def) : _this2._createMethodSend(section, method, def);\n        return exposed;\n      }, {});\n    }\n  }, {\n    key: \"_memomize\",\n    value: function _memomize(creator) {\n      var _this3 = this;\n\n      var memoized = memoize(creator('scale'), {\n        getInstanceId: function getInstanceId() {\n          return _classPrivateFieldLooseBase(_this3, _instanceId)[_instanceId];\n        }\n      });\n      memoized.json = creator('json');\n      memoized.raw = creator('raw');\n      return memoized;\n    }\n  }, {\n    key: \"_createMethodSend\",\n    value: function _createMethodSend(section, method, def) {\n      var _this4 = this;\n\n      var rpcName = def.endpoint || \"\".concat(section, \"_\").concat(method);\n      var hashIndex = def.params.findIndex(function (_ref11) {\n        var isHistoric = _ref11.isHistoric;\n        return isHistoric;\n      });\n      var cacheIndex = def.params.findIndex(function (_ref12) {\n        var isCached = _ref12.isCached;\n        return isCached;\n      });\n      var memoized = null; // execute the RPC call, doing a registry swap for historic as applicable\n\n      var callWithRegistry = /*#__PURE__*/function () {\n        var _ref13 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(outputAs, values) {\n          var blockHash, _ref14, registry, params, data;\n\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  blockHash = hashIndex === -1 ? null : values[hashIndex];\n\n                  if (!(blockHash && _classPrivateFieldLooseBase(_this4, _getBlockRegistry)[_getBlockRegistry])) {\n                    _context.next = 7;\n                    break;\n                  }\n\n                  _context.next = 4;\n                  return _classPrivateFieldLooseBase(_this4, _getBlockRegistry)[_getBlockRegistry](blockHash);\n\n                case 4:\n                  _context.t0 = _context.sent;\n                  _context.next = 8;\n                  break;\n\n                case 7:\n                  _context.t0 = {\n                    registry: _classPrivateFieldLooseBase(_this4, _registryDefault)[_registryDefault]\n                  };\n\n                case 8:\n                  _ref14 = _context.t0;\n                  registry = _ref14.registry;\n                  params = _this4._formatInputs(registry, null, def, values);\n                  _context.next = 13;\n                  return _this4.provider.send(rpcName, params.map(function (param) {\n                    return param.toJSON();\n                  }));\n\n                case 13:\n                  data = _context.sent;\n                  return _context.abrupt(\"return\", outputAs === 'scale' ? _this4._formatOutput(registry, blockHash, method, def, params, data) : registry.createType(outputAs === 'raw' ? 'Raw' : 'Json', data));\n\n                case 15:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee);\n        }));\n\n        return function callWithRegistry(_x, _x2) {\n          return _ref13.apply(this, arguments);\n        };\n      }();\n\n      var creator = function creator(outputAs) {\n        return function () {\n          for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n            values[_key] = arguments[_key];\n          }\n\n          var isDelayed = hashIndex !== -1 && !!values[hashIndex] || cacheIndex !== -1 && !!values[cacheIndex];\n          return new Observable(function (observer) {\n            callWithRegistry(outputAs, values).then(function (value) {\n              observer.next(value);\n              observer.complete();\n            }).catch(function (error) {\n              logErrorMessage(method, def, error);\n              observer.error(error);\n              observer.complete();\n            });\n            return function () {\n              var _memoized3;\n\n              var _memoized; // delete old results from cache\n\n\n              (_memoized = memoized) === null || _memoized === void 0 ? void 0 : (_memoized3 = _memoized).unmemoize.apply(_memoized3, values);\n            };\n          }).pipe(publishReplay(1), // create a Replay(1)\n          isDelayed ? refCountDelay() // Unsubscribe after delay\n          : refCount());\n        };\n      };\n\n      memoized = this._memomize(creator);\n      return memoized;\n    } // create a subscriptor, it subscribes once and resolves with the id as subscribe\n\n  }, {\n    key: \"_createSubscriber\",\n    value: function _createSubscriber(_ref15, errorHandler) {\n      var _this5 = this;\n\n      var paramsJson = _ref15.paramsJson,\n          subName = _ref15.subName,\n          subType = _ref15.subType,\n          update = _ref15.update;\n      return new Promise(function (resolve, reject) {\n        _this5.provider.subscribe(subType, subName, paramsJson, update).then(resolve).catch(function (error) {\n          errorHandler(error);\n          reject(error);\n        });\n      });\n    }\n  }, {\n    key: \"_createMethodSubscribe\",\n    value: function _createMethodSubscribe(section, method, def) {\n      var _this6 = this;\n\n      var _def$pubsub = _slicedToArray(def.pubsub, 3),\n          updateType = _def$pubsub[0],\n          subMethod = _def$pubsub[1],\n          unsubMethod = _def$pubsub[2];\n\n      var subName = \"\".concat(section, \"_\").concat(subMethod);\n      var unsubName = \"\".concat(section, \"_\").concat(unsubMethod);\n      var subType = \"\".concat(section, \"_\").concat(updateType);\n      var memoized = null;\n\n      var creator = function creator(outputAs) {\n        return function () {\n          for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            values[_key2] = arguments[_key2];\n          }\n\n          return new Observable(function (observer) {\n            // Have at least an empty promise, as used in the unsubscribe\n            var subscriptionPromise = Promise.resolve(null);\n\n            var registry = _classPrivateFieldLooseBase(_this6, _registryDefault)[_registryDefault];\n\n            var errorHandler = function errorHandler(error) {\n              logErrorMessage(method, def, error);\n              observer.error(error);\n            };\n\n            try {\n              var params = _this6._formatInputs(registry, null, def, values);\n\n              var paramsJson = params.map(function (param) {\n                return param.toJSON();\n              });\n\n              var update = function update(error, result) {\n                if (error) {\n                  logErrorMessage(method, def, error);\n                  return;\n                }\n\n                try {\n                  observer.next(outputAs === 'scale' ? _this6._formatOutput(registry, null, method, def, params, result) : registry.createType(outputAs === 'raw' ? 'Raw' : 'Json', result));\n                } catch (error) {\n                  observer.error(error);\n                }\n              };\n\n              subscriptionPromise = _this6._createSubscriber({\n                paramsJson: paramsJson,\n                subName: subName,\n                subType: subType,\n                update: update\n              }, errorHandler);\n            } catch (error) {\n              errorHandler(error);\n            } // Teardown logic\n\n\n            return function () {\n              var _memoized4;\n\n              var _memoized2; // Delete from cache, so old results don't hang around\n\n\n              (_memoized2 = memoized) === null || _memoized2 === void 0 ? void 0 : (_memoized4 = _memoized2).unmemoize.apply(_memoized4, values); // Unsubscribe from provider\n\n              subscriptionPromise.then(function (subscriptionId) {\n                return isNull(subscriptionId) ? Promise.resolve(false) : _this6.provider.unsubscribe(subType, unsubName, subscriptionId);\n              }).catch(function (error) {\n                return logErrorMessage(method, def, error);\n              });\n            };\n          }).pipe(drr());\n        };\n      };\n\n      memoized = this._memomize(creator);\n      return memoized;\n    }\n  }, {\n    key: \"_formatInputs\",\n    value: function _formatInputs(registry, blockHash, def, inputs) {\n      var reqArgCount = def.params.filter(function (_ref16) {\n        var isOptional = _ref16.isOptional;\n        return !isOptional;\n      }).length;\n      var optText = reqArgCount === def.params.length ? '' : \" (\".concat(def.params.length - reqArgCount, \" optional)\");\n      assert(inputs.length >= reqArgCount && inputs.length <= def.params.length, \"Expected \".concat(def.params.length, \" parameters\").concat(optText, \", \").concat(inputs.length, \" found instead\"));\n      return inputs.map(function (input, index) {\n        return createTypeUnsafe(registry, def.params[index].type, [input], {\n          blockHash: blockHash\n        });\n      });\n    }\n  }, {\n    key: \"_formatOutput\",\n    value: function _formatOutput(registry, blockHash, method, rpc, params, result) {\n      var _this7 = this;\n\n      if (rpc.type === 'StorageData') {\n        var key = params[0];\n        return this._formatStorageData(registry, blockHash, key, result);\n      } else if (rpc.type === 'StorageChangeSet') {\n        var keys = params[0];\n        return keys ? this._formatStorageSet(registry, result.block, keys, result.changes) : registry.createType('StorageChangeSet', result);\n      } else if (rpc.type === 'Vec<StorageChangeSet>') {\n        var mapped = result.map(function (_ref17) {\n          var block = _ref17.block,\n              changes = _ref17.changes;\n          return [registry.createType('Hash', block), _this7._formatStorageSet(registry, block, params[0], changes)];\n        }); // we only query at a specific block, not a range - flatten\n\n        return method === 'queryStorageAt' ? mapped[0][1] : mapped;\n      }\n\n      return createTypeUnsafe(registry, rpc.type, [result], {\n        blockHash: blockHash\n      });\n    }\n  }, {\n    key: \"_formatStorageData\",\n    value: function _formatStorageData(registry, blockHash, key, value) {\n      var isEmpty = isNull(value); // we convert to Uint8Array since it maps to the raw encoding, all\n      // data will be correctly encoded (incl. numbers, excl. :code)\n\n      var input = isEmpty ? null : isTreatAsHex(key) ? value : u8aToU8a(value);\n      return this._newType(registry, blockHash, key, input, isEmpty);\n    }\n  }, {\n    key: \"_formatStorageSet\",\n    value: function _formatStorageSet(registry, blockHash, keys, changes) {\n      var _this8 = this;\n\n      // For StorageChangeSet, the changes has the [key, value] mappings\n      var withCache = keys.length !== 1; // multiple return values (via state.storage subscription), decode the values\n      // one at a time, all based on the query types. Three values can be returned -\n      //   - Codec - There is a valid value, non-empty\n      //   - null - The storage key is empty\n\n      return keys.reduce(function (results, key, index) {\n        results.push(_this8._formatStorageSetEntry(registry, blockHash, key, changes, withCache, index));\n        return results;\n      }, []);\n    }\n  }, {\n    key: \"_formatStorageSetEntry\",\n    value: function _formatStorageSetEntry(registry, blockHash, key, changes, witCache, entryIndex) {\n      var hexKey = key.toHex();\n      var found = changes.find(function (_ref18) {\n        var _ref19 = _slicedToArray(_ref18, 1),\n            key = _ref19[0];\n\n        return key === hexKey;\n      }); // if we don't find the value, this is our fallback\n      //   - in the case of an array of values, fill the hole from the cache\n      //   - if a single result value, don't fill - it is not an update hole\n      //   - fallback to an empty option in all cases\n\n      var value = isUndefined(found) ? witCache && _classPrivateFieldLooseBase(this, _storageCache)[_storageCache].get(hexKey) || null : found[1];\n      var isEmpty = isNull(value);\n      var input = isEmpty || isTreatAsHex(key) ? value : u8aToU8a(value); // store the retrieved result - the only issue with this cache is that there is no\n      // clearing of it, so very long running processes (not just a couple of hours, longer)\n      // will increase memory beyond what is allowed.\n\n      _classPrivateFieldLooseBase(this, _storageCache)[_storageCache].set(hexKey, value);\n\n      return this._newType(registry, blockHash, key, input, isEmpty, entryIndex);\n    }\n  }, {\n    key: \"_newType\",\n    value: function _newType(registry, blockHash, key, input, isEmpty) {\n      var entryIndex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : -1;\n      // single return value (via state.getStorage), decode the value based on the\n      // outputType that we have specified. Fallback to Raw on nothing\n      var type = key.outputType || 'Raw';\n      var meta = key.meta || EMPTY_META;\n      var entryNum = entryIndex === -1 ? '' : \" entry \".concat(entryIndex, \":\");\n\n      if (meta.modifier.isOptional) {\n        var inner = null;\n\n        if (!isEmpty) {\n          try {\n            inner = createTypeUnsafe(registry, type, [input], {\n              blockHash: blockHash,\n              isPedantic: true\n            });\n          } catch (error) {\n            l.error(\"Unable to decode storage \".concat(key.section || 'unknown', \".\").concat(key.method || 'unknown', \":\").concat(entryNum), error.message);\n          }\n        }\n\n        var option = new Option(registry, createClass(registry, type), inner);\n\n        if (blockHash) {\n          option.createdAtHash = registry.createType('Hash', blockHash);\n        }\n\n        return option;\n      }\n\n      try {\n        return createTypeUnsafe(registry, type, [isEmpty ? meta.fallback ? hexToU8a(meta.fallback.toHex()) : undefined : input], {\n          blockHash: blockHash,\n          isPedantic: true\n        });\n      } catch (error) {\n        l.error(\"Unable to decode storage \".concat(key.section || 'unknown', \".\").concat(key.method || 'unknown', \":\").concat(entryNum), error.message);\n        return createTypeUnsafe(registry, 'Raw', [input], {\n          blockHash: blockHash\n        });\n      }\n    }\n  }]);\n\n  return RpcCore;\n}();","map":null,"metadata":{},"sourceType":"module"}
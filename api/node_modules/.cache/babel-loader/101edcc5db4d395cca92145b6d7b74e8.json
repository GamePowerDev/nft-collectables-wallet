{"ast":null,"code":"import _assertThisInitialized from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _defineProperty from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\"; // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\nimport { assert, hexToU8a, isHex, isNumber, isObject, isString, isU8a, isUndefined, stringCamelCase, stringUpperFirst, u8aConcat, u8aToHex } from '@polkadot/util';\nimport { Null } from \"../primitive/Null.js\";\nimport { Struct } from \"./Struct.js\";\nimport { mapToTypeMap } from \"./utils/index.js\"; // export interface, this is used in Enum.with, so required as public by TS\n\nfunction isRustEnum(def) {\n  var defValues = Object.values(def);\n\n  if (defValues.some(function (v) {\n    return isNumber(v);\n  })) {\n    assert(defValues.every(function (v) {\n      return isNumber(v) && v >= 0 && v <= 255;\n    }), 'Invalid number-indexed enum definition');\n    return false;\n  }\n\n  return true;\n}\n\nfunction extractDef(registry, _def) {\n  if (Array.isArray(_def)) {\n    return {\n      def: _def.reduce(function (def, key, index) {\n        def[key] = {\n          Type: Null,\n          index: index\n        };\n        return def;\n      }, {}),\n      isBasic: true,\n      isIndexed: false\n    };\n  }\n\n  var isBasic;\n  var isIndexed;\n  var def;\n\n  if (isRustEnum(_def)) {\n    def = Object.entries(mapToTypeMap(registry, _def)).reduce(function (def, _ref, index) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          key = _ref2[0],\n          Type = _ref2[1];\n\n      def[key] = {\n        Type: Type,\n        index: index\n      };\n      return def;\n    }, {});\n    isBasic = !Object.values(def).some(function (_ref3) {\n      var Type = _ref3.Type;\n      return Type !== Null;\n    });\n    isIndexed = false;\n  } else {\n    def = Object.entries(_def).reduce(function (def, _ref4) {\n      var _ref5 = _slicedToArray(_ref4, 2),\n          key = _ref5[0],\n          index = _ref5[1];\n\n      def[key] = {\n        Type: Null,\n        index: index\n      };\n      return def;\n    }, {});\n    isBasic = true;\n    isIndexed = true;\n  }\n\n  return {\n    def: def,\n    isBasic: isBasic,\n    isIndexed: isIndexed\n  };\n}\n\nfunction createFromValue(registry, def) {\n  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var value = arguments.length > 3 ? arguments[3] : undefined;\n  var entry = Object.values(def).find(function (e) {\n    return e.index === index;\n  });\n  assert(!isUndefined(entry), \"Unable to create Enum via index \".concat(index, \", in \").concat(Object.keys(def).join(', ')));\n  return {\n    index: index,\n    value: value instanceof entry.Type ? value : new entry.Type(registry, value)\n  };\n}\n\nfunction decodeFromJSON(registry, def, key, value) {\n  // JSON comes in the form of { \"<type (camelCase)>\": \"<value for type>\" }, here we\n  // additionally force to lower to ensure forward compat\n  var keys = Object.keys(def).map(function (k) {\n    return k.toLowerCase();\n  });\n  var keyLower = key.toLowerCase();\n  var index = keys.indexOf(keyLower);\n  assert(index !== -1, \"Cannot map Enum JSON, unable to find '\".concat(key, \"' in \").concat(keys.join(', ')));\n\n  try {\n    return createFromValue(registry, def, Object.values(def)[index].index, value);\n  } catch (error) {\n    throw new Error(\"Enum(\".concat(key, \"):: \").concat(error.message));\n  }\n}\n\nfunction decodeFromString(registry, def, value) {\n  return isHex(value) // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  ? decodeFromValue(registry, def, hexToU8a(value)) : decodeFromJSON(registry, def, value);\n}\n\nfunction decodeFromValue(registry, def, value) {\n  if (isU8a(value)) {\n    // nested, we don't want to match isObject below\n    if (value.length) {\n      return createFromValue(registry, def, value[0], value.subarray(1));\n    }\n  } else if (isNumber(value)) {\n    return createFromValue(registry, def, value);\n  } else if (isString(value)) {\n    return decodeFromString(registry, def, value.toString());\n  } else if (isObject(value)) {\n    var key = Object.keys(value)[0];\n    return decodeFromJSON(registry, def, key, value[key]);\n  } // Worst-case scenario, return the first with default\n\n\n  return createFromValue(registry, def, Object.values(def)[0].index);\n}\n\nfunction decodeEnum(registry, def, value, index) {\n  // NOTE We check the index path first, before looking at values - this allows treating\n  // the optional indexes before anything else, more-specific > less-specific\n  if (isNumber(index)) {\n    return createFromValue(registry, def, index, value); // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  } else if (value instanceof Enum) {\n    return createFromValue(registry, def, value.index, value.value);\n  }\n\n  return decodeFromValue(registry, def, value);\n}\n/**\n * @name Enum\n * @description\n * This implements an enum, that based on the value wraps a different type. It is effectively\n * an extension to enum where the value type is determined by the actual index.\n */\n// TODO:\n//   - As per Enum, actually use TS enum\n//   - It should rather probably extend Enum instead of copying code\n\n\nvar _def2 = _classPrivateFieldLooseKey(\"def\");\n\nvar _entryIndex = _classPrivateFieldLooseKey(\"entryIndex\");\n\nvar _indexes = _classPrivateFieldLooseKey(\"indexes\");\n\nvar _isBasic = _classPrivateFieldLooseKey(\"isBasic\");\n\nvar _isIndexed = _classPrivateFieldLooseKey(\"isIndexed\");\n\nvar _raw = _classPrivateFieldLooseKey(\"raw\");\n\nexport var Enum = /*#__PURE__*/function () {\n  function Enum(registry, def, value, index) {\n    _classCallCheck(this, Enum);\n\n    this.registry = void 0;\n    this.createdAtHash = void 0;\n    Object.defineProperty(this, _def2, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _entryIndex, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _indexes, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _isBasic, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _isIndexed, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _raw, {\n      writable: true,\n      value: void 0\n    });\n    var defInfo = extractDef(registry, def);\n    var decoded = decodeEnum(registry, defInfo.def, value, index);\n    this.registry = registry;\n    _classPrivateFieldLooseBase(this, _def2)[_def2] = defInfo.def;\n    _classPrivateFieldLooseBase(this, _isBasic)[_isBasic] = defInfo.isBasic;\n    _classPrivateFieldLooseBase(this, _isIndexed)[_isIndexed] = defInfo.isIndexed;\n    _classPrivateFieldLooseBase(this, _indexes)[_indexes] = Object.values(defInfo.def).map(function (_ref6) {\n      var index = _ref6.index;\n      return index;\n    });\n    _classPrivateFieldLooseBase(this, _entryIndex)[_entryIndex] = _classPrivateFieldLooseBase(this, _indexes)[_indexes].indexOf(decoded.index) || 0;\n    _classPrivateFieldLooseBase(this, _raw)[_raw] = decoded.value;\n  }\n\n  _createClass(Enum, [{\n    key: \"encodedLength\",\n    get:\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    function get() {\n      return 1 + _classPrivateFieldLooseBase(this, _raw)[_raw].encodedLength;\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n\n  }, {\n    key: \"hash\",\n    get: function get() {\n      return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description The index of the enum value\n     */\n\n  }, {\n    key: \"index\",\n    get: function get() {\n      return _classPrivateFieldLooseBase(this, _indexes)[_indexes][_classPrivateFieldLooseBase(this, _entryIndex)[_entryIndex]];\n    }\n    /**\n     * @description true if this is a basic enum (no values)\n     */\n\n  }, {\n    key: \"isBasic\",\n    get: function get() {\n      return _classPrivateFieldLooseBase(this, _isBasic)[_isBasic];\n    }\n    /**\n     * @description Checks if the value is an empty value\n     */\n\n  }, {\n    key: \"isEmpty\",\n    get: function get() {\n      return _classPrivateFieldLooseBase(this, _raw)[_raw].isEmpty;\n    }\n    /**\n     * @description Checks if the Enum points to a [[Null]] type\n     */\n\n  }, {\n    key: \"isNone\",\n    get: function get() {\n      return this.isNull;\n    }\n    /**\n     * @description Checks if the Enum points to a [[Null]] type (deprecated, use isNone)\n     */\n\n  }, {\n    key: \"isNull\",\n    get: function get() {\n      return _classPrivateFieldLooseBase(this, _raw)[_raw] instanceof Null;\n    }\n    /**\n     * @description The available keys for this enum\n     */\n\n  }, {\n    key: \"defIndexes\",\n    get: function get() {\n      return _classPrivateFieldLooseBase(this, _indexes)[_indexes];\n    }\n    /**\n     * @description The available keys for this enum\n     */\n\n  }, {\n    key: \"defKeys\",\n    get: function get() {\n      return Object.keys(_classPrivateFieldLooseBase(this, _def2)[_def2]);\n    }\n    /**\n     * @description The name of the type this enum value represents\n     */\n\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this.defKeys[_classPrivateFieldLooseBase(this, _entryIndex)[_entryIndex]];\n    }\n    /**\n     * @description The value of the enum\n     */\n\n  }, {\n    key: \"value\",\n    get: function get() {\n      return _classPrivateFieldLooseBase(this, _raw)[_raw];\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      // cater for the case where we only pass the enum index\n      if (isNumber(other)) {\n        return this.toNumber() === other;\n      } else if (_classPrivateFieldLooseBase(this, _isBasic)[_isBasic] && isString(other)) {\n        return this.type === other;\n      } else if (isU8a(other)) {\n        return !this.toU8a().some(function (entry, index) {\n          return entry !== other[index];\n        });\n      } else if (isHex(other)) {\n        return this.toHex() === other;\n      } else if (other instanceof Enum) {\n        return this.index === other.index && this.value.eq(other.value);\n      } else if (isObject(other)) {\n        return this.value.eq(other[this.type]);\n      } // compare the actual wrapper value\n\n\n      return this.value.eq(other);\n    }\n    /**\n     * @description Returns a hex string representation of the value\n     */\n\n  }, {\n    key: \"toHex\",\n    value: function toHex() {\n      return u8aToHex(this.toU8a());\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n\n  }, {\n    key: \"toHuman\",\n    value: function toHuman(isExtended) {\n      return _classPrivateFieldLooseBase(this, _isBasic)[_isBasic] ? this.type : _defineProperty({}, this.type, _classPrivateFieldLooseBase(this, _raw)[_raw].toHuman(isExtended));\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return _classPrivateFieldLooseBase(this, _isBasic)[_isBasic] ? this.type : _defineProperty({}, stringCamelCase(this.type), _classPrivateFieldLooseBase(this, _raw)[_raw].toJSON());\n    }\n    /**\n     * @description Returns the number representation for the value\n     */\n\n  }, {\n    key: \"toNumber\",\n    value: function toNumber() {\n      return this.index;\n    }\n    /**\n     * @description Returns a raw struct representation of the enum types\n     */\n\n  }, {\n    key: \"_toRawStruct\",\n    value: function _toRawStruct() {\n      var _this = this;\n\n      if (_classPrivateFieldLooseBase(this, _isBasic)[_isBasic]) {\n        return _classPrivateFieldLooseBase(this, _isIndexed)[_isIndexed] ? this.defKeys.reduce(function (out, key, index) {\n          out[key] = _classPrivateFieldLooseBase(_this, _indexes)[_indexes][index];\n          return out;\n        }, {}) : this.defKeys;\n      }\n\n      var typeMap = Object.entries(_classPrivateFieldLooseBase(this, _def2)[_def2]).reduce(function (out, _ref9) {\n        var _ref10 = _slicedToArray(_ref9, 2),\n            key = _ref10[0],\n            Type = _ref10[1].Type;\n\n        out[key] = Type;\n        return out;\n      }, {});\n      return Struct.typesToMap(this.registry, typeMap);\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n\n  }, {\n    key: \"toRawType\",\n    value: function toRawType() {\n      return JSON.stringify({\n        _enum: this._toRawStruct()\n      });\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.isNull ? this.type : JSON.stringify(this.toJSON());\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n\n  }, {\n    key: \"toU8a\",\n    value: function toU8a(isBare) {\n      return u8aConcat(new Uint8Array(isBare ? [] : [this.index]), _classPrivateFieldLooseBase(this, _raw)[_raw].toU8a(isBare));\n    }\n  }], [{\n    key: \"with\",\n    value: function _with(Types) {\n      return /*#__PURE__*/function (_Enum) {\n        _inherits(_class, _Enum);\n\n        var _super = _createSuper(_class);\n\n        function _class(registry, value, index) {\n          var _this2;\n\n          _classCallCheck(this, _class);\n\n          _this2 = _super.call(this, registry, Types, value, index);\n          Object.keys(_classPrivateFieldLooseBase(_assertThisInitialized(_this2), _def2)[_def2]).forEach(function (_key) {\n            var name = stringUpperFirst(stringCamelCase(_key.replace(' ', '_')));\n            var askey = \"as\".concat(name);\n            var iskey = \"is\".concat(name);\n            isUndefined(_this2[iskey]) && Object.defineProperty(_assertThisInitialized(_this2), iskey, {\n              enumerable: true,\n              get: function get() {\n                return _this2.type === _key;\n              }\n            });\n            isUndefined(_this2[askey]) && Object.defineProperty(_assertThisInitialized(_this2), askey, {\n              enumerable: true,\n              get: function get() {\n                assert(_this2[iskey], \"Cannot convert '\".concat(_this2.type, \"' via \").concat(askey));\n                return _this2.value;\n              }\n            });\n          });\n          return _this2;\n        }\n\n        return _class;\n      }(Enum);\n    }\n  }]);\n\n  return Enum;\n}();","map":null,"metadata":{},"sourceType":"module"}
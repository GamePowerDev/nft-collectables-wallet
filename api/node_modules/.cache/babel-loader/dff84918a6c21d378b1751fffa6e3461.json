{"ast":null,"code":"import _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\"; // Copyright 2017-2021 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bnToHex, compactAddLength, hexToU8a, isBigInt, isBn, isHex, isNumber, isString, stringToU8a } from '@polkadot/util';\nimport { blake2AsU8a } from \"../blake2/asU8a.js\";\nvar RE_NUMBER = /^\\d+$/;\nvar JUNCTION_ID_LEN = 32;\nvar BN_OPTIONS = {\n  bitLength: 256,\n  isLe: true\n};\n\nvar _chainCode = _classPrivateFieldLooseKey(\"chainCode\");\n\nvar _isHard = _classPrivateFieldLooseKey(\"isHard\");\n\nexport var DeriveJunction = /*#__PURE__*/function () {\n  function DeriveJunction() {\n    _classCallCheck(this, DeriveJunction);\n\n    Object.defineProperty(this, _chainCode, {\n      writable: true,\n      value: new Uint8Array(32)\n    });\n    Object.defineProperty(this, _isHard, {\n      writable: true,\n      value: false\n    });\n  }\n\n  _createClass(DeriveJunction, [{\n    key: \"chainCode\",\n    get: function get() {\n      return _classPrivateFieldLooseBase(this, _chainCode)[_chainCode];\n    }\n  }, {\n    key: \"isHard\",\n    get: function get() {\n      return _classPrivateFieldLooseBase(this, _isHard)[_isHard];\n    }\n  }, {\n    key: \"isSoft\",\n    get: function get() {\n      return !_classPrivateFieldLooseBase(this, _isHard)[_isHard];\n    }\n  }, {\n    key: \"hard\",\n    value: function hard(value) {\n      return this.soft(value).harden();\n    }\n  }, {\n    key: \"harden\",\n    value: function harden() {\n      _classPrivateFieldLooseBase(this, _isHard)[_isHard] = true;\n      return this;\n    }\n  }, {\n    key: \"soft\",\n    value: function soft(value) {\n      if (isNumber(value) || isBn(value) || isBigInt(value)) {\n        return this.soft(bnToHex(value, BN_OPTIONS));\n      } else if (isString(value)) {\n        return isHex(value) ? this.soft(hexToU8a(value)) : this.soft(compactAddLength(stringToU8a(value)));\n      }\n\n      if (value.length > JUNCTION_ID_LEN) {\n        return this.soft(blake2AsU8a(value));\n      }\n\n      _classPrivateFieldLooseBase(this, _chainCode)[_chainCode].fill(0);\n\n      _classPrivateFieldLooseBase(this, _chainCode)[_chainCode].set(value, 0);\n\n      return this;\n    }\n  }, {\n    key: \"soften\",\n    value: function soften() {\n      _classPrivateFieldLooseBase(this, _isHard)[_isHard] = false;\n      return this;\n    }\n  }], [{\n    key: \"from\",\n    value: function from(value) {\n      var result = new DeriveJunction();\n\n      var _ref = value.startsWith('/') ? [value.substr(1), true] : [value, false],\n          _ref2 = _slicedToArray(_ref, 2),\n          code = _ref2[0],\n          isHard = _ref2[1];\n\n      result.soft(RE_NUMBER.test(code) ? parseInt(code, 10) : code);\n      return isHard ? result.harden() : result;\n    }\n  }]);\n\n  return DeriveJunction;\n}();","map":null,"metadata":{},"sourceType":"module"}
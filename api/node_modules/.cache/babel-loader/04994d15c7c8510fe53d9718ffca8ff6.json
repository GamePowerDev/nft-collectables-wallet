{"ast":null,"code":"import _classCallCheck from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { isFunction, isNull, isUndefined } from '@polkadot/util';\nimport { Json } from \"../codec/Json.js\";\n\nfunction createValue(registry, type, value) {\n  var asArray = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n  // We detect codec here as well - when found, generally this is constructed from itself\n  if (value && isFunction(value.unwrapOrDefault)) {\n    return value;\n  }\n\n  return registry.createType(type, asArray ? isNull(value) || isUndefined(value) ? null : Array.isArray(value) ? value : [value] : value);\n}\n\nfunction decodeValue(registry, key, value) {\n  return key === 'ss58Format' ? createValue(registry, 'Option<u32>', value, false) : key === 'tokenDecimals' ? createValue(registry, 'Option<Vec<u32>>', value) : key === 'tokenSymbol' ? createValue(registry, 'Option<Vec<Text>>', value) : value;\n}\n\nfunction decode(registry, value) {\n  return ( // allow decoding from a map as well (ourselves)\n  value && isFunction(value.entries) ? _toConsumableArray(value.entries()) : Object.entries(value || {})).reduce(function (all, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        value = _ref2[1];\n\n    all[key] = decodeValue(registry, key, value);\n    return all;\n  }, {\n    ss58Format: registry.createType('Option<u32>'),\n    tokenDecimals: registry.createType('Option<Vec<u32>>'),\n    tokenSymbol: registry.createType('Option<Vec<Text>>')\n  });\n}\n\nexport var GenericChainProperties = /*#__PURE__*/function (_Json) {\n  _inherits(GenericChainProperties, _Json);\n\n  var _super = _createSuper(GenericChainProperties);\n\n  function GenericChainProperties(registry, value) {\n    _classCallCheck(this, GenericChainProperties);\n\n    return _super.call(this, registry, decode(registry, value));\n  }\n  /**\n   * @description The chain ss58Format\n   */\n\n\n  _createClass(GenericChainProperties, [{\n    key: \"ss58Format\",\n    get: function get() {\n      return this.get('ss58Format');\n    }\n    /**\n     * @description The decimals for each of the tokens\n     */\n\n  }, {\n    key: \"tokenDecimals\",\n    get: function get() {\n      return this.get('tokenDecimals');\n    }\n    /**\n     * @description The symbols for the tokens\n     */\n\n  }, {\n    key: \"tokenSymbol\",\n    get: function get() {\n      return this.get('tokenSymbol');\n    }\n  }]);\n\n  return GenericChainProperties;\n}(Json);","map":null,"metadata":{},"sourceType":"module"}
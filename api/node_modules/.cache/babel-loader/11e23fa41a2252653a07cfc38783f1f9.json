{"ast":null,"code":"import _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { isFunction } from '@polkadot/util';\nimport { combineLatest, of } from '@polkadot/x-rxjs';\nimport { map, switchMap } from '@polkadot/x-rxjs/operators';\nimport { memo } from \"../util/index.js\";\nimport { calcVotes, getStatus, parseImage } from \"./util.js\";\n\nfunction votesPrev(api, referendumId) {\n  return api.query.democracy.votersFor(referendumId).pipe(switchMap(function (votersFor) {\n    return combineLatest([of(votersFor), votersFor.length ? api.query.democracy.voteOf.multi(votersFor.map(function (accountId) {\n      return [referendumId, accountId];\n    })) : of([]), api.derive.balances.votingBalances(votersFor)]);\n  }), map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 3),\n        votersFor = _ref2[0],\n        votes = _ref2[1],\n        balances = _ref2[2];\n\n    return votersFor.map(function (accountId, index) {\n      return {\n        accountId: accountId,\n        balance: balances[index].votingBalance || api.registry.createType('Balance'),\n        isDelegating: false,\n        vote: votes[index] || api.registry.createType('Vote')\n      };\n    });\n  }));\n}\n\nfunction extractVotes(mapped, referendumId) {\n  return mapped.filter(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        voting = _ref4[1];\n\n    return voting.isDirect;\n  }).map(function (_ref5) {\n    var _ref6 = _slicedToArray(_ref5, 2),\n        accountId = _ref6[0],\n        voting = _ref6[1];\n\n    return [accountId, voting.asDirect.votes.filter(function (_ref7) {\n      var _ref8 = _slicedToArray(_ref7, 1),\n          idx = _ref8[0];\n\n      return idx.eq(referendumId);\n    })];\n  }).filter(function (_ref9) {\n    var _ref10 = _slicedToArray(_ref9, 2),\n        directVotes = _ref10[1];\n\n    return !!directVotes.length;\n  }).reduce(function (result, _ref11) {\n    var _ref12 = _slicedToArray(_ref11, 2),\n        accountId = _ref12[0],\n        votes = _ref12[1];\n\n    return (// FIXME We are ignoring split votes\n      votes.reduce(function (result, _ref13) {\n        var _ref14 = _slicedToArray(_ref13, 2),\n            vote = _ref14[1];\n\n        if (vote.isStandard) {\n          result.push(_objectSpread({\n            accountId: accountId,\n            isDelegating: false\n          }, vote.asStandard));\n        }\n\n        return result;\n      }, result)\n    );\n  }, []);\n}\n\nfunction votesCurr(api, referendumId) {\n  return api.query.democracy.votingOf.entries().pipe(map(function (allVoting) {\n    var mapped = allVoting.map(function (_ref15) {\n      var _ref16 = _slicedToArray(_ref15, 2),\n          _ref16$0$args = _slicedToArray(_ref16[0].args, 1),\n          accountId = _ref16$0$args[0],\n          voting = _ref16[1];\n\n      return [accountId, voting];\n    });\n    var votes = extractVotes(mapped, referendumId);\n    var delegations = mapped.filter(function (_ref17) {\n      var _ref18 = _slicedToArray(_ref17, 2),\n          voting = _ref18[1];\n\n      return voting.isDelegating;\n    }).map(function (_ref19) {\n      var _ref20 = _slicedToArray(_ref19, 2),\n          accountId = _ref20[0],\n          voting = _ref20[1];\n\n      return [accountId, voting.asDelegating];\n    }); // add delegations\n\n    delegations.forEach(function (_ref21) {\n      var _ref22 = _slicedToArray(_ref21, 2),\n          accountId = _ref22[0],\n          _ref22$ = _ref22[1],\n          balance = _ref22$.balance,\n          conviction = _ref22$.conviction,\n          target = _ref22$.target;\n\n      // Are we delegating to a delegator\n      var toDelegator = delegations.find(function (_ref23) {\n        var _ref24 = _slicedToArray(_ref23, 1),\n            accountId = _ref24[0];\n\n        return accountId.eq(target);\n      });\n      var to = votes.find(function (_ref25) {\n        var accountId = _ref25.accountId;\n        return accountId.eq(toDelegator ? toDelegator[0] : target);\n      }); // this delegation has a target\n\n      if (to) {\n        votes.push({\n          accountId: accountId,\n          balance: balance,\n          isDelegating: true,\n          vote: api.registry.createType('Vote', {\n            aye: to.vote.isAye,\n            conviction: conviction\n          })\n        });\n      }\n    });\n    return votes;\n  }));\n}\n\nexport function _referendumVotes(instanceId, api) {\n  return memo(instanceId, function (referendum) {\n    return combineLatest([api.derive.democracy.sqrtElectorate(), isFunction(api.query.democracy.votingOf) ? votesCurr(api, referendum.index) : votesPrev(api, referendum.index)]).pipe(map(function (_ref26) {\n      var _ref27 = _slicedToArray(_ref26, 2),\n          sqrtElectorate = _ref27[0],\n          votes = _ref27[1];\n\n      return calcVotes(sqrtElectorate, referendum, votes);\n    }));\n  });\n}\nexport function _referendumsVotes(instanceId, api) {\n  return memo(instanceId, function (referendums) {\n    return referendums.length ? combineLatest(referendums.map(function (referendum) {\n      return api.derive.democracy._referendumVotes(referendum);\n    })) : of([]);\n  });\n}\nexport function _referendumInfo(instanceId, api) {\n  return memo(instanceId, function (index, info) {\n    var status = getStatus(info);\n    return status ? api.query.democracy.preimages(status.proposalHash).pipe(map(function (preimage) {\n      return {\n        image: parseImage(api, preimage),\n        imageHash: status.proposalHash,\n        index: api.registry.createType('ReferendumIndex', index),\n        status: status\n      };\n    })) : of(null);\n  });\n}\nexport function referendumsInfo(instanceId, api) {\n  return memo(instanceId, function (ids) {\n    return ids.length ? api.query.democracy.referendumInfoOf.multi(ids).pipe(switchMap(function (infos) {\n      return combineLatest(ids.map(function (id, index) {\n        return api.derive.democracy._referendumInfo(id, infos[index]);\n      }));\n    }), map(function (infos) {\n      return infos.filter(function (referendum) {\n        return !!referendum;\n      });\n    })) : of([]);\n  });\n}","map":null,"metadata":{},"sourceType":"module"}
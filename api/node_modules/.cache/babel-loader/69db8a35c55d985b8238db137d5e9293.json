{"ast":null,"code":"import _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { isFunction } from '@polkadot/util';\nimport { combineLatest, of } from '@polkadot/x-rxjs';\nimport { map, switchMap } from '@polkadot/x-rxjs/operators';\nimport { memo } from \"../util/index.js\"; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nfunction isNewDepositors(depositors) {\n  // Detect balance...\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  return isFunction(depositors[1].mul);\n}\n\nfunction parse(_ref) {\n  var _ref2 = _slicedToArray(_ref, 3),\n      proposals = _ref2[0],\n      images = _ref2[1],\n      optDepositors = _ref2[2];\n\n  return proposals.filter(function (_ref3, index) {\n    var _ref4 = _slicedToArray(_ref3, 3),\n        proposer = _ref4[2];\n\n    var _optDepositors$index;\n\n    return !!((_optDepositors$index = optDepositors[index]) !== null && _optDepositors$index !== void 0 && _optDepositors$index.isSome) && !proposer.isEmpty;\n  }).map(function (_ref5, proposalIndex) {\n    var _ref6 = _slicedToArray(_ref5, 3),\n        index = _ref6[0],\n        imageHash = _ref6[1],\n        proposer = _ref6[2];\n\n    var depositors = optDepositors[proposalIndex].unwrap();\n    return _objectSpread(_objectSpread({}, isNewDepositors(depositors) ? {\n      balance: depositors[1],\n      seconds: depositors[0]\n    } : {\n      balance: depositors[0],\n      seconds: depositors[1]\n    }), {}, {\n      image: images[proposalIndex],\n      imageHash: imageHash,\n      index: index,\n      proposer: proposer\n    });\n  });\n}\n\nexport function proposals(instanceId, api) {\n  return memo(instanceId, function () {\n    var _api$query$democracy, _api$query$democracy2;\n\n    return isFunction((_api$query$democracy = api.query.democracy) === null || _api$query$democracy === void 0 ? void 0 : _api$query$democracy.publicProps) && isFunction((_api$query$democracy2 = api.query.democracy) === null || _api$query$democracy2 === void 0 ? void 0 : _api$query$democracy2.preimages) ? api.query.democracy.publicProps().pipe(switchMap(function (proposals) {\n      return combineLatest([of(proposals), api.derive.democracy.preimages(proposals.map(function (_ref7) {\n        var _ref8 = _slicedToArray(_ref7, 2),\n            hash = _ref8[1];\n\n        return hash;\n      })), api.query.democracy.depositOf.multi(proposals.map(function (_ref9) {\n        var _ref10 = _slicedToArray(_ref9, 1),\n            index = _ref10[0];\n\n        return index;\n      }))]);\n    }), map(parse)) : of([]);\n  });\n}","map":null,"metadata":{},"sourceType":"module"}
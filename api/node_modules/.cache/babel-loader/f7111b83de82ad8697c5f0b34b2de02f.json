{"ast":null,"code":"import _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _get from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\"; // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\nimport BN from 'bn.js';\nimport { assert, BN_BILLION, BN_HUNDRED, BN_MILLION, BN_QUINTILL, BN_ZERO, bnToBn, bnToHex, bnToU8a, formatBalance, formatNumber, hexToBn, isHex, isString, isU8a, u8aToBn } from '@polkadot/util';\nexport var DEFAULT_UINT_BITS = 64; // Maximum allowed integer for JS is 2^53 - 1, set limit at 52\n// In this case however, we always print any >32 as hex\n\nvar MAX_NUMBER_BITS = 52;\nvar MUL_P = new BN(10000);\nvar FORMATTERS = [['Perquintill', BN_QUINTILL], ['Perbill', BN_BILLION], ['Permill', BN_MILLION], ['Percent', BN_HUNDRED]];\n\nfunction toPercentage(value, divisor) {\n  return \"\".concat((value.mul(MUL_P).div(divisor).toNumber() / 100).toFixed(2), \"%\");\n}\n/** @internal */\n\n\nfunction decodeAbstracIntU8a(value, bitLength, isNegative) {\n  if (!value.length) {\n    return '0';\n  }\n\n  try {\n    // NOTE When passing u8a in (typically from decoded data), it is always Little Endian\n    return u8aToBn(value.subarray(0, bitLength / 8), {\n      isLe: true,\n      isNegative: isNegative\n    }).toString();\n  } catch (error) {\n    throw new Error(\"AbstractInt: failed on \".concat(JSON.stringify(value), \":: \").concat(error.message));\n  }\n}\n/** @internal */\n\n\nfunction decodeAbstractInt(value, bitLength, isNegative) {\n  // This function returns a string, which will be passed in the BN\n  // constructor. It would be ideal to actually return a BN, but there's a\n  // bug: https://github.com/indutny/bn.js/issues/206.\n  if (isHex(value, -1, true)) {\n    return hexToBn(value, {\n      isLe: false,\n      isNegative: isNegative\n    }).toString();\n  } else if (isU8a(value)) {\n    return decodeAbstracIntU8a(value, bitLength, isNegative);\n  } else if (isString(value)) {\n    return new BN(value.toString(), 10).toString();\n  }\n\n  return bnToBn(value).toString();\n}\n/**\n * @name AbstractInt\n * @ignore\n * @noInheritDoc\n */\n// TODO:\n//   - Apart from encoding/decoding we don't actually keep check on the sizes, is this good enough?\n\n\nvar _bitLength = _classPrivateFieldLooseKey(\"bitLength\");\n\nvar _isSigned = _classPrivateFieldLooseKey(\"isSigned\");\n\nexport var AbstractInt = /*#__PURE__*/function (_BN) {\n  _inherits(AbstractInt, _BN);\n\n  var _super = _createSuper(AbstractInt);\n\n  function AbstractInt(registry) {\n    var _thisSuper, _thisSuper2, _this;\n\n    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var bitLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_UINT_BITS;\n    var isSigned = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    _classCallCheck(this, AbstractInt);\n\n    _this = _super.call(this, decodeAbstractInt(value, bitLength, isSigned));\n    _this.registry = void 0;\n    _this.createdAtHash = void 0;\n    Object.defineProperty(_assertThisInitialized(_this), _bitLength, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _isSigned, {\n      writable: true,\n      value: void 0\n    });\n    _this.registry = registry;\n    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _bitLength)[_bitLength] = bitLength;\n    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _isSigned)[_isSigned] = isSigned;\n\n    var isPositive = _this.gte(BN_ZERO);\n\n    var maxBits = bitLength - (isSigned && isPositive ? 1 : 0);\n    assert(isSigned || isPositive, \"\".concat(_this.toRawType(), \": Negative number passed to unsigned type\"));\n    assert(_get((_thisSuper = _assertThisInitialized(_this), _getPrototypeOf(AbstractInt.prototype)), \"bitLength\", _thisSuper).call(_thisSuper) <= maxBits, \"\".concat(_this.toRawType(), \": Input too large. Found input with \").concat(_get((_thisSuper2 = _assertThisInitialized(_this), _getPrototypeOf(AbstractInt.prototype)), \"bitLength\", _thisSuper2).call(_thisSuper2), \" bits, expected \").concat(maxBits));\n    return _this;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  _createClass(AbstractInt, [{\n    key: \"encodedLength\",\n    get: function get() {\n      return _classPrivateFieldLooseBase(this, _bitLength)[_bitLength] / 8;\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n\n  }, {\n    key: \"hash\",\n    get: function get() {\n      return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description Checks if the value is a zero value (align elsewhere)\n     */\n\n  }, {\n    key: \"isEmpty\",\n    get: function get() {\n      return this.isZero();\n    }\n    /**\n     * @description Checks if the value is an unsigned type\n     */\n\n  }, {\n    key: \"isUnsigned\",\n    get: function get() {\n      return !_classPrivateFieldLooseBase(this, _isSigned)[_isSigned];\n    }\n    /**\n     * @description Returns the number of bits in the value\n     */\n\n  }, {\n    key: \"bitLength\",\n    value: function bitLength() {\n      return _classPrivateFieldLooseBase(this, _bitLength)[_bitLength];\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      // Here we are actually overriding the built-in .eq to take care of both\n      // number and BN inputs (no `.eqn` needed) - numbers will be converted\n      return _get(_getPrototypeOf(AbstractInt.prototype), \"eq\", this).call(this, isHex(other) ? hexToBn(other.toString(), {\n        isLe: false,\n        isNegative: _classPrivateFieldLooseBase(this, _isSigned)[_isSigned]\n      }) : bnToBn(other));\n    }\n    /**\n     * @description True if this value is the max of the type\n     */\n\n  }, {\n    key: \"isMax\",\n    value: function isMax() {\n      var u8a = this.toU8a().filter(function (byte) {\n        return byte === 0xff;\n      });\n      return u8a.length === _classPrivateFieldLooseBase(this, _bitLength)[_bitLength] / 8;\n    }\n    /**\n     * @description Returns a BigInt representation of the number\n     */\n\n  }, {\n    key: \"toBigInt\",\n    value: function toBigInt() {\n      return BigInt(this.toString());\n    }\n    /**\n     * @description Returns the BN representation of the number. (Compatibility)\n     */\n\n  }, {\n    key: \"toBn\",\n    value: function toBn() {\n      return this;\n    }\n    /**\n     * @description Returns a hex string representation of the value\n     */\n\n  }, {\n    key: \"toHex\",\n    value: function toHex() {\n      var isLe = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      // For display/JSON, this is BE, for compare, use isLe\n      return bnToHex(this, {\n        bitLength: this.bitLength(),\n        isLe: isLe,\n        isNegative: !this.isUnsigned\n      });\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"toHuman\",\n    value: function toHuman(isExpanded) {\n      var rawType = this.toRawType();\n\n      if (rawType === 'Balance') {\n        return this.isMax() ? 'everything' // FIXME In the case of multiples we need some way of detecting which instance this belongs\n        // to. as it stands we will always format (incorrectly) against the first token defined\n        : formatBalance(this, {\n          decimals: this.registry.chainDecimals[0],\n          withSi: true,\n          withUnit: this.registry.chainTokens[0]\n        });\n      }\n\n      var _ref = FORMATTERS.find(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 1),\n            type = _ref4[0];\n\n        return type === rawType;\n      }) || [],\n          _ref2 = _slicedToArray(_ref, 2),\n          divisor = _ref2[1];\n\n      return divisor ? toPercentage(this, divisor) : formatNumber(this);\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var onlyHex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      // FIXME this return type should by string | number, however BN returns string\n      // Options here are\n      //   - super.bitLength() - the actual used bits\n      //   - this.#bitLength - the type bits (this should be used, however contracts RPC is problematic)\n      return onlyHex || _get(_getPrototypeOf(AbstractInt.prototype), \"bitLength\", this).call(this) > MAX_NUMBER_BITS ? this.toHex() : this.toNumber();\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n\n  }, {\n    key: \"toRawType\",\n    value: function toRawType() {\n      // NOTE In the case of balances, which have a special meaning on the UI\n      // and can be interpreted differently, return a specific value for it so\n      // underlying it always matches (no matter which length it actually is)\n      return this instanceof this.registry.createClass('Balance') ? 'Balance' : \"\".concat(this.isUnsigned ? 'u' : 'i').concat(this.bitLength());\n    }\n    /**\n     * @description Returns the string representation of the value\n     * @param base The base to use for the conversion\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString(base) {\n      // only included here since we do not inherit docs\n      return _get(_getPrototypeOf(AbstractInt.prototype), \"toString\", this).call(this, base);\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"toU8a\",\n    value: function toU8a(isBare) {\n      return bnToU8a(this, {\n        bitLength: this.bitLength(),\n        isLe: true,\n        isNegative: !this.isUnsigned\n      });\n    }\n  }]);\n\n  return AbstractInt;\n}(BN);","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"// Copyright 2017-2021 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, bnToU8a, stringToU8a, u8aConcat } from '@polkadot/util';\nimport { hmacSha512 } from \"../../hmac/index.js\";\nimport { secp256k1KeypairFromSeed, secp256k1PrivateKeyTweakAdd } from \"../../secp256k1/index.js\";\nimport { HARDENED, hdValidatePath } from \"../validatePath.js\";\nvar MASTER_SECRET = stringToU8a('Bitcoin seed');\n\nfunction createCoded(secretKey, chainCode) {\n  return {\n    chainCode: chainCode,\n    publicKey: secp256k1KeypairFromSeed(secretKey).publicKey,\n    secretKey: secretKey\n  };\n}\n\nfunction deriveChild(hd, index) {\n  var indexBuffer = bnToU8a(index, {\n    bitLength: 32,\n    isLe: false\n  });\n  var data = index >= HARDENED ? u8aConcat(new Uint8Array(1), hd.secretKey, indexBuffer) : u8aConcat(hd.publicKey, indexBuffer);\n\n  try {\n    var I = hmacSha512(hd.chainCode, data);\n    return createCoded(secp256k1PrivateKeyTweakAdd(hd.secretKey, I.slice(0, 32)), I.slice(32));\n  } catch (err) {\n    // In case parse256(IL) >= n or ki == 0, proceed with the next value for i\n    return deriveChild(hd, index + 1);\n  }\n}\n\nexport function hdEthereum(seed) {\n  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var I = hmacSha512(MASTER_SECRET, seed);\n  var hd = createCoded(I.slice(0, 32), I.slice(32));\n\n  if (!path || path === 'm' || path === 'M' || path === \"m'\" || path === \"M'\") {\n    return hd;\n  }\n\n  assert(hdValidatePath(path), 'Invalid derivation path');\n  return path.split('/').slice(1).reduce(function (hd, c) {\n    return deriveChild(hd, parseInt(c, 10) + (c.length > 1 && c.endsWith(\"'\") ? HARDENED : 0));\n  }, hd);\n}","map":null,"metadata":{},"sourceType":"module"}
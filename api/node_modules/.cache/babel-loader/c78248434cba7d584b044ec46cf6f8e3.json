{"ast":null,"code":"import _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n// Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { BN_ZERO } from '@polkadot/util';\nimport { of } from '@polkadot/x-rxjs';\nimport { map, switchMap } from '@polkadot/x-rxjs/operators';\nimport { deriveCache, memo } from \"../util/index.js\";\nimport { filterEras } from \"./util.js\";\nvar CACHE_KEY = 'eraPoints';\n\nfunction mapValidators(_ref) {\n  var individual = _ref.individual;\n  return _toConsumableArray(individual.entries()).filter(function (_ref2) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n        points = _ref3[1];\n\n    return points.gt(BN_ZERO);\n  }).reduce(function (result, _ref4) {\n    var _ref5 = _slicedToArray(_ref4, 2),\n        validatorId = _ref5[0],\n        points = _ref5[1];\n\n    result[validatorId.toString()] = points;\n    return result;\n  }, {});\n}\n\nfunction mapPoints(eras, points) {\n  return eras.map(function (era, index) {\n    return {\n      era: era,\n      eraPoints: points[index].total,\n      validators: mapValidators(points[index])\n    };\n  });\n}\n\nexport function _erasPoints(instanceId, api) {\n  return memo(instanceId, function (eras, withActive) {\n    if (!eras.length) {\n      return of([]);\n    }\n\n    var cached = withActive ? [] : eras.map(function (era) {\n      return deriveCache.get(\"\".concat(CACHE_KEY, \"-\").concat(era.toString()));\n    }).filter(function (value) {\n      return !!value;\n    });\n    var remaining = filterEras(eras, cached);\n    return !remaining.length ? of(cached) : api.query.staking.erasRewardPoints.multi(remaining).pipe(map(function (points) {\n      var query = mapPoints(remaining, points);\n      !withActive && query.forEach(function (q) {\n        return deriveCache.set(\"\".concat(CACHE_KEY, \"-\").concat(q.era.toString()), q);\n      });\n      return eras.map(function (era) {\n        return cached.find(function (cached) {\n          return era.eq(cached.era);\n        }) || query.find(function (query) {\n          return era.eq(query.era);\n        });\n      });\n    }));\n  });\n}\nexport function erasPoints(instanceId, api) {\n  return memo(instanceId, function () {\n    var withActive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return api.derive.staking.erasHistoric(withActive).pipe(switchMap(function (eras) {\n      return api.derive.staking._erasPoints(eras, withActive);\n    }));\n  });\n}","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n// Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { isFunction } from '@polkadot/util';\nimport { combineLatest, of } from '@polkadot/x-rxjs';\nimport { catchError, map, switchMap } from '@polkadot/x-rxjs/operators';\nimport { memo } from \"../util/index.js\";\n\nfunction parse(api, _ref) {\n  var _ref2 = _slicedToArray(_ref, 3),\n      hashes = _ref2[0],\n      proposals = _ref2[1],\n      votes = _ref2[2];\n\n  return proposals.map(function (proposalOpt, index) {\n    return proposalOpt && proposalOpt.isSome ? {\n      hash: api.registry.createType('Hash', hashes[index]),\n      proposal: proposalOpt.unwrap(),\n      votes: votes[index].unwrapOr(null)\n    } : null;\n  }).filter(function (proposal) {\n    return !!proposal;\n  });\n}\n\nfunction _proposalsFrom(instanceId, api) {\n  var section = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'council';\n  return memo(instanceId, function (hashes) {\n    var _api$query$section;\n\n    return (isFunction((_api$query$section = api.query[section]) === null || _api$query$section === void 0 ? void 0 : _api$query$section.proposals) && hashes.length ? combineLatest([of(hashes), combineLatest(hashes.map(function (hash) {\n      return (// this should simply be api.query[section].proposalOf.multi<Option<Proposal>>(hashes),\n        // however we have had cases on Edgeware where the indices have moved around after an\n        // upgrade, which results in invalid on-chain data\n        api.query[section].proposalOf(hash).pipe(catchError(function () {\n          return of(null);\n        }))\n      );\n    })), api.query[section].voting.multi(hashes)]) : of([[], [], []])).pipe(map(function (result) {\n      return parse(api, result);\n    }));\n  });\n}\n\nexport function proposals(instanceId, api) {\n  var section = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'council';\n\n  var proposalsFrom = _proposalsFrom(instanceId, api, section);\n\n  return memo(instanceId, function () {\n    var _api$query$section2;\n\n    return isFunction((_api$query$section2 = api.query[section]) === null || _api$query$section2 === void 0 ? void 0 : _api$query$section2.proposals) ? api.query[section].proposals().pipe(switchMap(proposalsFrom)) : of([]);\n  });\n}\nexport function proposal(instanceId, api) {\n  var section = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'council';\n\n  var proposalsFrom = _proposalsFrom(instanceId, api, section);\n\n  return memo(instanceId, function (hash) {\n    var _api$query$section3;\n\n    return isFunction((_api$query$section3 = api.query[section]) === null || _api$query$section3 === void 0 ? void 0 : _api$query$section3.proposals) ? proposalsFrom([hash]).pipe(map(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 1),\n          proposal = _ref4[0];\n\n      return proposal;\n    })) : of(null);\n  });\n}","map":null,"metadata":{},"sourceType":"module"}
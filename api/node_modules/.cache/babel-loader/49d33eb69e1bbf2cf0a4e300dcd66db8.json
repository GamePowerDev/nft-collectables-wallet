{"ast":null,"code":"import _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { BN_BILLION, BN_ZERO } from '@polkadot/util';\nimport { combineLatest, of } from '@polkadot/x-rxjs';\nimport { map, switchMap } from '@polkadot/x-rxjs/operators';\nimport { memo } from \"../util/index.js\";\n\nfunction parseRewards(api, stashId, _ref, exposures) {\n  var _ref2 = _slicedToArray(_ref, 3),\n      erasPoints = _ref2[0],\n      erasPrefs = _ref2[1],\n      erasRewards = _ref2[2];\n\n  return exposures.map(function (_ref3) {\n    var era = _ref3.era,\n        isEmpty = _ref3.isEmpty,\n        isValidator = _ref3.isValidator,\n        nominating = _ref3.nominating,\n        eraValidators = _ref3.validators;\n\n    var _ref4 = erasPoints.find(function (p) {\n      return p.era.eq(era);\n    }) || {\n      eraPoints: BN_ZERO,\n      validators: {}\n    },\n        eraPoints = _ref4.eraPoints,\n        allValPoints = _ref4.validators;\n\n    var _ref5 = erasRewards.find(function (r) {\n      return r.era.eq(era);\n    }) || {\n      eraReward: api.registry.createType('Balance')\n    },\n        eraReward = _ref5.eraReward;\n\n    var _ref6 = erasPrefs.find(function (p) {\n      return p.era.eq(era);\n    }) || {\n      validators: {}\n    },\n        allValPrefs = _ref6.validators;\n\n    var validators = {};\n    var stakerId = stashId.toString();\n    Object.entries(eraValidators).forEach(function (_ref7) {\n      var _ref8 = _slicedToArray(_ref7, 2),\n          validatorId = _ref8[0],\n          exposure = _ref8[1];\n\n      var _allValPrefs$validato;\n\n      var valPoints = allValPoints[validatorId] || BN_ZERO;\n      var valComm = ((_allValPrefs$validato = allValPrefs[validatorId]) === null || _allValPrefs$validato === void 0 ? void 0 : _allValPrefs$validato.commission.unwrap()) || BN_ZERO;\n      var expTotal = exposure.total.unwrap();\n      var avail = BN_ZERO;\n      var value;\n\n      if (!(expTotal.isZero() || valPoints.isZero() || eraPoints.isZero())) {\n        avail = eraReward.mul(valPoints).div(eraPoints);\n        var valCut = valComm.mul(avail).div(BN_BILLION);\n        var staked;\n\n        if (validatorId === stakerId) {\n          staked = exposure.own.unwrap();\n        } else {\n          var stakerExp = exposure.others.find(function (_ref9) {\n            var who = _ref9.who;\n            return who.eq(stakerId);\n          });\n          staked = stakerExp ? stakerExp.value.unwrap() : BN_ZERO;\n        }\n\n        value = avail.sub(valCut).imul(staked).div(expTotal).iadd(validatorId === stakerId ? valCut : BN_ZERO);\n      }\n\n      validators[validatorId] = {\n        total: api.registry.createType('Balance', avail),\n        value: api.registry.createType('Balance', value)\n      };\n    });\n    return {\n      era: era,\n      eraReward: eraReward,\n      isEmpty: isEmpty,\n      isValidator: isValidator,\n      nominating: nominating,\n      validators: validators\n    };\n  });\n}\n\nfunction allUniqValidators(rewards) {\n  return rewards.reduce(function (_ref10, rewards) {\n    var _ref11 = _slicedToArray(_ref10, 2),\n        all = _ref11[0],\n        perStash = _ref11[1];\n\n    var uniq = [];\n    perStash.push(uniq);\n    rewards.forEach(function (_ref12) {\n      var validators = _ref12.validators;\n      return Object.keys(validators).forEach(function (validatorId) {\n        if (!uniq.includes(validatorId)) {\n          uniq.push(validatorId);\n\n          if (!all.includes(validatorId)) {\n            all.push(validatorId);\n          }\n        }\n      });\n    });\n    return [all, perStash];\n  }, [[], []]);\n}\n\nfunction removeClaimed(validators, queryValidators, reward) {\n  var rm = [];\n  Object.keys(reward.validators).forEach(function (validatorId) {\n    var index = validators.indexOf(validatorId);\n\n    if (index !== -1) {\n      var valLedger = queryValidators[index].stakingLedger;\n\n      if (valLedger !== null && valLedger !== void 0 && valLedger.claimedRewards.some(function (era) {\n        return reward.era.eq(era);\n      })) {\n        rm.push(validatorId);\n      }\n    }\n  });\n  rm.forEach(function (validatorId) {\n    delete reward.validators[validatorId];\n  });\n}\n\nfunction filterRewards(eras, valInfo, _ref13) {\n  var rewards = _ref13.rewards,\n      stakingLedger = _ref13.stakingLedger;\n  var filter = eras.filter(function (era) {\n    return !stakingLedger.claimedRewards.some(function (e) {\n      return e.eq(era);\n    });\n  });\n  var validators = valInfo.map(function (_ref14) {\n    var _ref15 = _slicedToArray(_ref14, 1),\n        v = _ref15[0];\n\n    return v;\n  });\n  var queryValidators = valInfo.map(function (_ref16) {\n    var _ref17 = _slicedToArray(_ref16, 2),\n        q = _ref17[1];\n\n    return q;\n  });\n  return rewards.filter(function (_ref18) {\n    var isEmpty = _ref18.isEmpty;\n    return !isEmpty;\n  }).filter(function (reward) {\n    if (!filter.some(function (filter) {\n      return reward.era.eq(filter);\n    })) {\n      return false;\n    }\n\n    reward.isStakerPayout = true;\n    removeClaimed(validators, queryValidators, reward);\n    return true;\n  }).filter(function (_ref19) {\n    var validators = _ref19.validators;\n    return Object.keys(validators).length !== 0;\n  }).map(function (reward) {\n    return _objectSpread(_objectSpread({}, reward), {}, {\n      nominators: reward.nominating.filter(function (n) {\n        return reward.validators[n.validatorId];\n      })\n    });\n  });\n}\n\nexport function _stakerRewardsEras(instanceId, api) {\n  return memo(instanceId, function (eras, withActive) {\n    return combineLatest([api.derive.staking._erasPoints(eras, withActive), api.derive.staking._erasPrefs(eras, withActive), api.derive.staking._erasRewards(eras, withActive)]);\n  });\n}\nexport function _stakerRewards(instanceId, api) {\n  return memo(instanceId, function (accountIds, eras, withActive) {\n    return combineLatest([api.derive.staking.queryMulti(accountIds, {\n      withLedger: true\n    }), api.derive.staking._stakerExposures(accountIds, eras, withActive), api.derive.staking._stakerRewardsEras(eras, withActive)]).pipe(switchMap(function (_ref20) {\n      var _ref21 = _slicedToArray(_ref20, 3),\n          queries = _ref21[0],\n          exposures = _ref21[1],\n          erasResult = _ref21[2];\n\n      var allRewards = queries.map(function (_ref22, index) {\n        var stakingLedger = _ref22.stakingLedger,\n            stashId = _ref22.stashId;\n        return !stashId || !stakingLedger ? [] : parseRewards(api, stashId, erasResult, exposures[index]);\n      });\n\n      if (withActive) {\n        return of(allRewards);\n      }\n\n      var _allUniqValidators = allUniqValidators(allRewards),\n          _allUniqValidators2 = _slicedToArray(_allUniqValidators, 2),\n          allValidators = _allUniqValidators2[0],\n          stashValidators = _allUniqValidators2[1];\n\n      return api.derive.staking.queryMulti(allValidators, {\n        withLedger: true\n      }).pipe(map(function (queriedVals) {\n        return queries.map(function (_ref23, index) {\n          var stakingLedger = _ref23.stakingLedger;\n          var rewards = allRewards[index];\n          var ownValidators = stashValidators[index].map(function (validatorId) {\n            return [validatorId, queriedVals.find(function (q) {\n              return q.accountId.eq(validatorId);\n            })];\n          });\n          return filterRewards(eras, ownValidators, {\n            rewards: rewards,\n            stakingLedger: stakingLedger\n          });\n        });\n      }));\n    }));\n  });\n}\nexport function stakerRewards(instanceId, api) {\n  return memo(instanceId, function (accountId) {\n    var withActive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return api.derive.staking.erasHistoric(withActive).pipe(switchMap(function (eras) {\n      return api.derive.staking._stakerRewards([accountId], eras, withActive);\n    }), map(function (_ref24) {\n      var _ref25 = _slicedToArray(_ref24, 1),\n          first = _ref25[0];\n\n      return first;\n    }));\n  });\n}\nexport function stakerRewardsMultiEras(instanceId, api) {\n  return memo(instanceId, function (accountIds, eras) {\n    return accountIds.length && eras.length ? api.derive.staking._stakerRewards(accountIds, eras, false) : of([]);\n  });\n}\nexport function stakerRewardsMulti(instanceId, api) {\n  return memo(instanceId, function (accountIds) {\n    var withActive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return api.derive.staking.erasHistoric(withActive).pipe(switchMap(function (eras) {\n      return api.derive.staking.stakerRewardsMultiEras(accountIds, eras);\n    }));\n  });\n}","map":null,"metadata":{},"sourceType":"module"}
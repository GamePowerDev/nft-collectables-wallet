{"ast":null,"code":"import _regeneratorRuntime from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n// Copyright 2019-2021 @polkadot/wasm-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { assert, stringToU8a, u8aToString } from '@polkadot/util';\nvar wasm = null;\nvar cachegetInt32 = null;\nvar cachegetUint8 = null;\nexport function initWasm(_x, _x2, _x3) {\n  return _initWasm.apply(this, arguments);\n} // FIXME We really would love to clean this up and have a sign like (wasm, ...params) => T\n// Alas, TypeScript foo is not that great today, so we sadly have an extra closure here\n\nfunction _initWasm() {\n  _initWasm = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(wasmBytes, asmFn, wbg) {\n    var source;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            assert(typeof WebAssembly !== 'undefined' && wasmBytes && wasmBytes.length, 'WebAssembly is not available in your environment');\n            _context.next = 4;\n            return WebAssembly.instantiate(wasmBytes, {\n              wbg: wbg\n            });\n\n          case 4:\n            source = _context.sent;\n            wasm = source.instance.exports;\n            _context.next = 11;\n            break;\n\n          case 8:\n            _context.prev = 8;\n            _context.t0 = _context[\"catch\"](0);\n\n            // if we have a valid supplied asm.js, return that\n            if (asmFn) {\n              wasm = asmFn(wbg);\n            } else {\n              console.error('FATAL: Unable to initialize @polkadot/wasm-crypto');\n              console.error(_context.t0);\n              wasm = null;\n            }\n\n          case 11:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[0, 8]]);\n  }));\n  return _initWasm.apply(this, arguments);\n}\n\nexport function withWasm(fn) {\n  return function () {\n    assert(wasm, 'The WASM interface has not been initialized. Ensure that you wait for the initialization Promise with waitReady() from @polkadot/wasm-crypto (or cryptoWaitReady() from @polkadot/util-crypto) before attempting to use WASM-only interfaces.');\n    return fn(wasm).apply(void 0, arguments);\n  };\n}\nexport function getWasm() {\n  return wasm;\n}\nexport function getInt32() {\n  if (cachegetInt32 === null || cachegetInt32.buffer !== wasm.memory.buffer) {\n    cachegetInt32 = new Int32Array(wasm.memory.buffer);\n  }\n\n  return cachegetInt32;\n}\nexport function getUint8() {\n  if (cachegetUint8 === null || cachegetUint8.buffer !== wasm.memory.buffer) {\n    cachegetUint8 = new Uint8Array(wasm.memory.buffer);\n  }\n\n  return cachegetUint8;\n}\nexport function getU8a(ptr, len) {\n  return getUint8().subarray(ptr / 1, ptr / 1 + len);\n}\nexport function getString(ptr, len) {\n  return u8aToString(getU8a(ptr, len));\n}\nexport function allocU8a(arg) {\n  var ptr = wasm.__wbindgen_malloc(arg.length * 1);\n\n  getUint8().set(arg, ptr / 1);\n  return [ptr, arg.length];\n}\nexport function allocString(arg) {\n  return allocU8a(stringToU8a(arg));\n}\nexport function resultU8a() {\n  var r0 = getInt32()[8 / 4 + 0];\n  var r1 = getInt32()[8 / 4 + 1];\n  var ret = getU8a(r0, r1).slice();\n\n  wasm.__wbindgen_free(r0, r1 * 1);\n\n  return ret;\n}\nexport function resultString() {\n  return u8aToString(resultU8a());\n}","map":null,"metadata":{},"sourceType":"module"}
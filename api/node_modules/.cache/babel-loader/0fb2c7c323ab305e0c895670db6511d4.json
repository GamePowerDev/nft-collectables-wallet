{"ast":null,"code":"import _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { assert, isNumber } from '@polkadot/util';\nimport { sanitize } from \"./sanitize.js\";\nimport { TypeDefInfo } from \"./types.js\";\nimport { typeSplit } from \"./typeSplit.js\";\nvar MAX_NESTED = 64;\n\nfunction isRustEnum(details) {\n  var values = Object.values(details);\n\n  if (values.some(function (v) {\n    return isNumber(v);\n  })) {\n    assert(values.every(function (v) {\n      return isNumber(v) && v >= 0 && v <= 255;\n    }), 'Invalid number-indexed enum definition');\n    return false;\n  }\n\n  return true;\n} // decode an enum of either of the following forms\n//  { _enum: ['A', 'B', 'C'] }\n//  { _enum: { A: AccountId, B: Balance, C: u32 } }\n//  { _enum: { A: 1, B: 2 } }\n\n\nfunction _decodeEnum(value, details, count) {\n  value.info = TypeDefInfo.Enum; // not as pretty, but remain compatible with oo7 for both struct and Array types\n\n  if (Array.isArray(details)) {\n    value.sub = details.map(function (name, index) {\n      return {\n        index: index,\n        info: TypeDefInfo.Plain,\n        name: name,\n        type: 'Null'\n      };\n    });\n  } else if (isRustEnum(details)) {\n    value.sub = Object.entries(details).map(function (_ref, index) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          name = _ref2[0],\n          type = _ref2[1];\n\n      return _objectSpread(_objectSpread({}, getTypeDef(type || 'Null', {\n        name: name\n      }, count)), {}, {\n        index: index\n      });\n    });\n  } else {\n    value.sub = Object.entries(details).map(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 2),\n          name = _ref4[0],\n          index = _ref4[1];\n\n      return {\n        index: index,\n        info: TypeDefInfo.Plain,\n        name: name,\n        type: 'Null'\n      };\n    });\n  }\n\n  return value;\n} // decode a set of the form\n//   { _set: { A: 0b0001, B: 0b0010, C: 0b0100 } }\n\n\nfunction _decodeSet(value, details) {\n  value.info = TypeDefInfo.Set;\n  value.length = details._bitLength;\n  value.sub = Object.entries(details).filter(function (_ref5) {\n    var _ref6 = _slicedToArray(_ref5, 1),\n        name = _ref6[0];\n\n    return !name.startsWith('_');\n  }).map(function (_ref7) {\n    var _ref8 = _slicedToArray(_ref7, 2),\n        name = _ref8[0],\n        index = _ref8[1];\n\n    return {\n      index: index,\n      info: TypeDefInfo.Plain,\n      name: name,\n      type: name\n    };\n  });\n  return value;\n} // decode a struct, set or enum\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeStruct(value, type, _, count) {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  var parsed = JSON.parse(type);\n  var keys = Object.keys(parsed);\n\n  if (keys.length === 1 && keys[0] === '_enum') {\n    return _decodeEnum(value, parsed[keys[0]], count);\n  } else if (keys.length === 1 && keys[0] === '_set') {\n    return _decodeSet(value, parsed[keys[0]]);\n  }\n\n  value.alias = parsed._alias ? new Map(Object.entries(parsed._alias)) : undefined;\n  value.sub = keys.filter(function (name) {\n    return !['_alias'].includes(name);\n  }).map(function (name) {\n    return (// eslint-disable-next-line @typescript-eslint/no-use-before-define\n      getTypeDef(parsed[name], {\n        name: name\n      }, count)\n    );\n  });\n  return value;\n} // decode a fixed vector, e.g. [u8;32]\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeFixedVec(value, type, _, count) {\n  var _type$substr$split = type.substr(1, type.length - 2).split(';'),\n      _type$substr$split2 = _slicedToArray(_type$substr$split, 3),\n      vecType = _type$substr$split2[0],\n      strLength = _type$substr$split2[1],\n      displayName = _type$substr$split2[2];\n\n  var length = parseInt(strLength.trim(), 10); // as a first round, only u8 via u8aFixed, we can add more support\n\n  assert(length <= 256, \"\".concat(type, \": Only support for [Type; <length>], where length <= 256\"));\n  value.displayName = displayName;\n  value.length = length; // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n  value.sub = getTypeDef(vecType, {}, count);\n  return value;\n} // decode a tuple\n\n\nfunction _decodeTuple(value, _, subType, count) {\n  value.sub = subType.length === 0 ? [] // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  : typeSplit(subType).map(function (inner) {\n    return getTypeDef(inner, {}, count);\n  });\n  return value;\n} // decode a Int/UInt<bitLength[, name]>\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeAnyInt(value, type, _, clazz) {\n  var _type$substr$split3 = type.substr(clazz.length + 1, type.length - clazz.length - 1 - 1).split(','),\n      _type$substr$split4 = _slicedToArray(_type$substr$split3, 2),\n      strLength = _type$substr$split4[0],\n      displayName = _type$substr$split4[1];\n\n  var length = parseInt(strLength.trim(), 10); // as a first round, only u8 via u8aFixed, we can add more support\n\n  assert(length <= 8192 && length % 8 === 0, \"\".concat(type, \": Only support for \").concat(clazz, \"<bitLength>, where length <= 8192 and a power of 8, found \").concat(length));\n  value.displayName = displayName;\n  value.length = length;\n  return value;\n}\n\nfunction _decodeInt(value, type, subType) {\n  return _decodeAnyInt(value, type, subType, 'Int');\n}\n\nfunction _decodeUInt(value, type, subType) {\n  return _decodeAnyInt(value, type, subType, 'UInt');\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeDoNotConstruct(value, type, _) {\n  var NAME_LENGTH = 'DoNotConstruct'.length;\n  value.displayName = type.substr(NAME_LENGTH + 1, type.length - NAME_LENGTH - 1 - 1);\n  return value;\n}\n\nfunction hasWrapper(type, _ref9) {\n  var _ref10 = _slicedToArray(_ref9, 2),\n      start = _ref10[0],\n      end = _ref10[1];\n\n  return type.substr(0, start.length) === start && type.substr(-1 * end.length) === end;\n}\n\nvar nestedExtraction = [['[', ']', TypeDefInfo.VecFixed, _decodeFixedVec], ['{', '}', TypeDefInfo.Struct, _decodeStruct], ['(', ')', TypeDefInfo.Tuple, _decodeTuple], // the inner for these are the same as tuple, multiple values\n['BTreeMap<', '>', TypeDefInfo.BTreeMap, _decodeTuple], ['HashMap<', '>', TypeDefInfo.HashMap, _decodeTuple], ['Int<', '>', TypeDefInfo.Int, _decodeInt], ['Result<', '>', TypeDefInfo.Result, _decodeTuple], ['UInt<', '>', TypeDefInfo.UInt, _decodeUInt], ['DoNotConstruct<', '>', TypeDefInfo.DoNotConstruct, _decodeDoNotConstruct]];\nvar wrappedExtraction = [['BTreeSet<', '>', TypeDefInfo.BTreeSet], ['Compact<', '>', TypeDefInfo.Compact], ['Linkage<', '>', TypeDefInfo.Linkage], ['Option<', '>', TypeDefInfo.Option], ['Vec<', '>', TypeDefInfo.Vec]];\n\nfunction extractSubType(type, _ref11) {\n  var _ref12 = _slicedToArray(_ref11, 2),\n      start = _ref12[0],\n      end = _ref12[1];\n\n  return type.substr(start.length, type.length - start.length - end.length);\n} // eslint-disable-next-line @typescript-eslint/ban-types\n\n\nexport function getTypeDef(_type) {\n  var _ref13 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      displayName = _ref13.displayName,\n      name = _ref13.name;\n\n  var count = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  // create the type via Type, allowing types to be sanitized\n  var type = sanitize(_type);\n  var value = {\n    displayName: displayName,\n    info: TypeDefInfo.Plain,\n    name: name,\n    type: type\n  };\n  assert(++count !== MAX_NESTED, 'getTypeDef: Maximum nested limit reached');\n  var nested = nestedExtraction.find(function (nested) {\n    return hasWrapper(type, nested);\n  });\n\n  if (nested) {\n    value.info = nested[2];\n    return nested[3](value, type, extractSubType(type, nested), count);\n  }\n\n  var wrapped = wrappedExtraction.find(function (wrapped) {\n    return hasWrapper(type, wrapped);\n  });\n\n  if (wrapped) {\n    value.info = wrapped[2];\n    value.sub = getTypeDef(extractSubType(type, wrapped), {}, count);\n  }\n\n  return value;\n}","map":null,"metadata":{},"sourceType":"module"}
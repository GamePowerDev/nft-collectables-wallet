{"ast":null,"code":"import _classCallCheck from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { assert, isU8a, u8aConcat, u8aToHex } from '@polkadot/util';\nimport { Enum } from \"../../codec/Enum.js\";\nimport { Struct } from \"../../codec/Struct.js\";\nimport { EMPTY_U8A, IMMORTAL_ERA } from \"../constants.js\";\nimport { GenericExtrinsicPayloadV4 } from \"./ExtrinsicPayload.js\";\nvar FAKE_NONE = new Uint8Array();\nvar FAKE_SOME = new Uint8Array([1]);\n\nfunction toAddress(registry, address) {\n  return registry.createType('Address', isU8a(address) ? u8aToHex(address) : address);\n}\n/**\n * @name GenericExtrinsicSignatureV4\n * @description\n * A container for the [[Signature]] associated with a specific [[Extrinsic]]\n */\n\n\nvar _fakePrefix = _classPrivateFieldLooseKey(\"fakePrefix\");\n\nexport var GenericExtrinsicSignatureV4 = /*#__PURE__*/function (_Struct) {\n  _inherits(GenericExtrinsicSignatureV4, _Struct);\n\n  var _super = _createSuper(GenericExtrinsicSignatureV4);\n\n  function GenericExtrinsicSignatureV4(registry, value) {\n    var _this;\n\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        isSigned = _ref.isSigned;\n\n    _classCallCheck(this, GenericExtrinsicSignatureV4);\n\n    _this = _super.call(this, registry, _objectSpread({\n      signer: 'Address',\n      // eslint-disable-next-line sort-keys\n      signature: 'ExtrinsicSignature'\n    }, registry.getSignedExtensionTypes()), GenericExtrinsicSignatureV4.decodeExtrinsicSignature(value, isSigned));\n    Object.defineProperty(_assertThisInitialized(_this), _fakePrefix, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _fakePrefix)[_fakePrefix] = registry.createType('ExtrinsicSignature') instanceof Enum ? FAKE_SOME : FAKE_NONE;\n    return _this;\n  }\n  /** @internal */\n\n\n  _createClass(GenericExtrinsicSignatureV4, [{\n    key: \"encodedLength\",\n    get:\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    function get() {\n      return this.isSigned ? _get(_getPrototypeOf(GenericExtrinsicSignatureV4.prototype), \"encodedLength\", this) : 0;\n    }\n    /**\n     * @description `true` if the signature is valid\n     */\n\n  }, {\n    key: \"isSigned\",\n    get: function get() {\n      return !this.signature.isEmpty;\n    }\n    /**\n     * @description The [[ExtrinsicEra]] (mortal or immortal) this signature applies to\n     */\n\n  }, {\n    key: \"era\",\n    get: function get() {\n      return this.get('era');\n    }\n    /**\n     * @description The [[Index]] for the signature\n     */\n\n  }, {\n    key: \"nonce\",\n    get: function get() {\n      return this.get('nonce');\n    }\n    /**\n     * @description The actual [[EcdsaSignature]], [[Ed25519Signature]] or [[Sr25519Signature]]\n     */\n\n  }, {\n    key: \"signature\",\n    get: function get() {\n      // the second case here is when we don't have an enum signature, treat as raw\n      return this.multiSignature.value || this.multiSignature;\n    }\n    /**\n     * @description The raw [[ExtrinsicSignature]]\n     */\n\n  }, {\n    key: \"multiSignature\",\n    get: function get() {\n      return this.get('signature');\n    }\n    /**\n     * @description The [[Address]] that signed\n     */\n\n  }, {\n    key: \"signer\",\n    get: function get() {\n      return this.get('signer');\n    }\n    /**\n     * @description The [[Balance]] tip\n     */\n\n  }, {\n    key: \"tip\",\n    get: function get() {\n      return this.get('tip');\n    }\n  }, {\n    key: \"_injectSignature\",\n    value: function _injectSignature(signer, signature, _ref2) {\n      var era = _ref2.era,\n          nonce = _ref2.nonce,\n          tip = _ref2.tip;\n      this.set('era', era);\n      this.set('nonce', nonce);\n      this.set('signer', signer);\n      this.set('signature', signature);\n      this.set('tip', tip);\n      return this;\n    }\n    /**\n     * @description Adds a raw signature\n     */\n\n  }, {\n    key: \"addSignature\",\n    value: function addSignature(signer, signature, payload) {\n      return this._injectSignature(toAddress(this.registry, signer), this.registry.createType('ExtrinsicSignature', signature), new GenericExtrinsicPayloadV4(this.registry, payload));\n    }\n    /**\n     * @description Creates a payload from the supplied options\n     */\n\n  }, {\n    key: \"createPayload\",\n    value: function createPayload(method, _ref3) {\n      var blockHash = _ref3.blockHash,\n          era = _ref3.era,\n          genesisHash = _ref3.genesisHash,\n          nonce = _ref3.nonce,\n          _ref3$runtimeVersion = _ref3.runtimeVersion,\n          specVersion = _ref3$runtimeVersion.specVersion,\n          transactionVersion = _ref3$runtimeVersion.transactionVersion,\n          tip = _ref3.tip;\n      return new GenericExtrinsicPayloadV4(this.registry, {\n        blockHash: blockHash,\n        era: era || IMMORTAL_ERA,\n        genesisHash: genesisHash,\n        method: method.toHex(),\n        nonce: nonce,\n        specVersion: specVersion,\n        tip: tip || 0,\n        transactionVersion: transactionVersion || 0\n      });\n    }\n    /**\n     * @description Generate a payload and applies the signature from a keypair\n     */\n\n  }, {\n    key: \"sign\",\n    value: function sign(method, account, options) {\n      assert(account && account.addressRaw, \"Expected a valid keypair for signing, found \".concat(JSON.stringify(account)));\n      var signer = toAddress(this.registry, account.addressRaw);\n      var payload = this.createPayload(method, options);\n      var signature = this.registry.createType('ExtrinsicSignature', payload.sign(account));\n      return this._injectSignature(signer, signature, payload);\n    }\n    /**\n     * @description Generate a payload and applies a fake signature\n     */\n\n  }, {\n    key: \"signFake\",\n    value: function signFake(method, address, options) {\n      assert(address, \"Expected a valid address for signing, found \".concat(JSON.stringify(address)));\n      var signer = toAddress(this.registry, address);\n      var payload = this.createPayload(method, options);\n      var signature = this.registry.createType('ExtrinsicSignature', u8aConcat(_classPrivateFieldLooseBase(this, _fakePrefix)[_fakePrefix], new Uint8Array(64).fill(0x42)));\n      return this._injectSignature(signer, signature, payload);\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n\n  }, {\n    key: \"toU8a\",\n    value: function toU8a(isBare) {\n      return this.isSigned ? _get(_getPrototypeOf(GenericExtrinsicSignatureV4.prototype), \"toU8a\", this).call(this, isBare) : EMPTY_U8A;\n    }\n  }], [{\n    key: \"decodeExtrinsicSignature\",\n    value: function decodeExtrinsicSignature(value) {\n      var isSigned = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (!value) {\n        return EMPTY_U8A;\n      } else if (value instanceof GenericExtrinsicSignatureV4) {\n        return value;\n      }\n\n      return isSigned ? value : EMPTY_U8A;\n    }\n  }]);\n\n  return GenericExtrinsicSignatureV4;\n}(Struct);","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _defineProperty2 from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nvar _encoders;\n\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { assert, isNumber, isUndefined } from '@polkadot/util';\nimport { TypeDefInfo } from \"./types.js\";\n\nvar stringIdentity = function stringIdentity(value) {\n  return value.toString();\n};\n\nvar INFO_WRAP = ['BTreeMap', 'BTreeSet', 'Compact', 'HashMap', 'Option', 'Result', 'Vec'];\nexport function paramsNotation(outer, inner) {\n  var transform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stringIdentity;\n  return \"\".concat(outer).concat(inner ? \"<\".concat((Array.isArray(inner) ? inner : [inner]).map(transform).join(', '), \">\") : '');\n}\n\nfunction encodeWithParams(typeDef, outer) {\n  var info = typeDef.info,\n      sub = typeDef.sub;\n\n  switch (info) {\n    case TypeDefInfo.BTreeMap:\n    case TypeDefInfo.BTreeSet:\n    case TypeDefInfo.Compact:\n    case TypeDefInfo.HashMap:\n    case TypeDefInfo.Linkage:\n    case TypeDefInfo.Option:\n    case TypeDefInfo.Result:\n    case TypeDefInfo.Vec:\n      return paramsNotation(outer, sub, function (param) {\n        return encodeTypeDef(param);\n      });\n  }\n\n  throw new Error(\"Unable to encode \".concat(JSON.stringify(typeDef), \" with params\"));\n}\n\nfunction encodeDoNotConstruct(_ref) {\n  var displayName = _ref.displayName;\n  return \"DoNotConstruct<\".concat(displayName || 'Unknown', \">\");\n}\n\nfunction encodeSubTypes(sub, asEnum) {\n  var names = sub.map(function (_ref2) {\n    var name = _ref2.name;\n    return name;\n  });\n  assert(names.every(function (n) {\n    return !!n;\n  }), \"Subtypes does not have consistent names, \".concat(names.join(', ')));\n  var inner = sub.reduce(function (result, type) {\n    return _objectSpread(_objectSpread({}, result), {}, _defineProperty2({}, type.name, encodeTypeDef(type)));\n  }, {});\n  return JSON.stringify(asEnum ? {\n    _enum: inner\n  } : inner);\n}\n\nfunction encodeEnum(typeDef) {\n  assert(typeDef.sub && Array.isArray(typeDef.sub), 'Unable to encode Enum type');\n  var sub = typeDef.sub; // c-like enums have all Null entries\n  // TODO We need to take the disciminant into account and auto-add empty entries\n\n  return sub.every(function (_ref3) {\n    var type = _ref3.type;\n    return type === 'Null';\n  }) ? JSON.stringify({\n    _enum: sub.map(function (_ref4, index) {\n      var name = _ref4.name;\n      return \"\".concat(name || \"Empty\".concat(index));\n    })\n  }) : encodeSubTypes(sub, true);\n}\n\nfunction encodeStruct(typeDef) {\n  assert(typeDef.sub && Array.isArray(typeDef.sub), 'Unable to encode Struct type');\n  return encodeSubTypes(typeDef.sub);\n}\n\nfunction encodeTuple(typeDef) {\n  assert(typeDef.sub && Array.isArray(typeDef.sub), 'Unable to encode Tuple type');\n  return \"(\".concat(typeDef.sub.map(function (type) {\n    return encodeTypeDef(type);\n  }).join(', '), \")\");\n}\n\nfunction encodeUInt(_ref5, type) {\n  var length = _ref5.length;\n  assert(isNumber(length), 'Unable to encode VecFixed type');\n  return \"\".concat(type, \"<\").concat(length, \">\");\n}\n\nfunction encodeVecFixed(_ref6) {\n  var length = _ref6.length,\n      sub = _ref6.sub;\n  assert(isNumber(length) && !isUndefined(sub) && !Array.isArray(sub), 'Unable to encode VecFixed type');\n  return \"[\".concat(sub.type, \";\").concat(length, \"]\");\n} // We setup a record here to ensure we have comprehensive coverage (any item not covered will result\n// in a compile-time error with the missing index)\n\n\nvar encoders = (_encoders = {}, _defineProperty2(_encoders, TypeDefInfo.BTreeMap, function (typeDef) {\n  return encodeWithParams(typeDef, 'BTreeMap');\n}), _defineProperty2(_encoders, TypeDefInfo.BTreeSet, function (typeDef) {\n  return encodeWithParams(typeDef, 'BTreeSet');\n}), _defineProperty2(_encoders, TypeDefInfo.Compact, function (typeDef) {\n  return encodeWithParams(typeDef, 'Compact');\n}), _defineProperty2(_encoders, TypeDefInfo.DoNotConstruct, function (typeDef) {\n  return encodeDoNotConstruct(typeDef);\n}), _defineProperty2(_encoders, TypeDefInfo.Enum, function (typeDef) {\n  return encodeEnum(typeDef);\n}), _defineProperty2(_encoders, TypeDefInfo.HashMap, function (typeDef) {\n  return encodeWithParams(typeDef, 'HashMap');\n}), _defineProperty2(_encoders, TypeDefInfo.Int, function (typeDef) {\n  return encodeUInt(typeDef, 'Int');\n}), _defineProperty2(_encoders, TypeDefInfo.Linkage, function (typeDef) {\n  return encodeWithParams(typeDef, 'Linkage');\n}), _defineProperty2(_encoders, TypeDefInfo.Null, function (typeDef) {\n  return 'Null';\n}), _defineProperty2(_encoders, TypeDefInfo.Option, function (typeDef) {\n  return encodeWithParams(typeDef, 'Option');\n}), _defineProperty2(_encoders, TypeDefInfo.Plain, function (typeDef) {\n  return typeDef.displayName || typeDef.type;\n}), _defineProperty2(_encoders, TypeDefInfo.Result, function (typeDef) {\n  return encodeWithParams(typeDef, 'Result');\n}), _defineProperty2(_encoders, TypeDefInfo.Set, function (typeDef) {\n  return typeDef.type;\n}), _defineProperty2(_encoders, TypeDefInfo.Struct, function (typeDef) {\n  return encodeStruct(typeDef);\n}), _defineProperty2(_encoders, TypeDefInfo.Tuple, function (typeDef) {\n  return encodeTuple(typeDef);\n}), _defineProperty2(_encoders, TypeDefInfo.UInt, function (typeDef) {\n  return encodeUInt(typeDef, 'UInt');\n}), _defineProperty2(_encoders, TypeDefInfo.Vec, function (typeDef) {\n  return encodeWithParams(typeDef, 'Vec');\n}), _defineProperty2(_encoders, TypeDefInfo.VecFixed, function (typeDef) {\n  return encodeVecFixed(typeDef);\n}), _encoders);\n\nfunction encodeType(typeDef) {\n  var encoder = encoders[typeDef.info];\n  assert(encoder, \"Cannot encode type: \".concat(JSON.stringify(typeDef)));\n  return encoder(typeDef);\n}\n\nexport function encodeTypeDef(typeDef) {\n  assert(!isUndefined(typeDef.info), \"Invalid type definition with no instance info, \".concat(JSON.stringify(typeDef))); // In the case of contracts we do have the unfortunate situation where the displayName would\n  // refer to \"Option\" when it is an option. For these, string it out, only using when actually\n  // not a top-level element to be used\n\n  if (typeDef.displayName && !INFO_WRAP.some(function (i) {\n    return typeDef.displayName === i;\n  })) {\n    return typeDef.displayName;\n  }\n\n  return encodeType(typeDef);\n}\nexport function withTypeString(typeDef) {\n  return _objectSpread(_objectSpread({}, typeDef), {}, {\n    type: encodeType(typeDef)\n  });\n}","map":null,"metadata":{},"sourceType":"module"}
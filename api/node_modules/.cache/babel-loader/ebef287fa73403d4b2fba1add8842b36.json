{"ast":null,"code":"import _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n// Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { combineLatest, of } from '@polkadot/x-rxjs';\nimport { map, switchMap } from '@polkadot/x-rxjs/operators';\nimport { memo } from \"../util/index.js\";\n\nfunction parseDetails(stashId, controllerIdOpt, nominatorsOpt, rewardDestination, validatorPrefs, exposure, stakingLedgerOpt) {\n  return {\n    accountId: stashId,\n    controllerId: controllerIdOpt && controllerIdOpt.unwrapOr(null),\n    exposure: exposure,\n    nominators: nominatorsOpt.isSome ? nominatorsOpt.unwrap().targets : [],\n    rewardDestination: rewardDestination,\n    stakingLedger: stakingLedgerOpt.unwrapOrDefault(),\n    stashId: stashId,\n    validatorPrefs: validatorPrefs\n  };\n}\n\nfunction getLedgers(api, optIds, _ref) {\n  var _ref$withLedger = _ref.withLedger,\n      withLedger = _ref$withLedger === void 0 ? false : _ref$withLedger;\n  var ids = optIds.filter(function (opt) {\n    return withLedger && !!opt && opt.isSome;\n  }).map(function (opt) {\n    return opt.unwrap();\n  });\n  var emptyLed = api.registry.createType('Option<StakingLedger>');\n  return (ids.length ? api.query.staking.ledger.multi(ids) : of([])).pipe(map(function (optLedgers) {\n    var offset = -1;\n    return optIds.map(function (opt) {\n      return opt && opt.isSome ? optLedgers[++offset] || emptyLed : emptyLed;\n    });\n  }));\n}\n\nfunction getStashInfo(api, stashIds, activeEra, _ref2) {\n  var withController = _ref2.withController,\n      withDestination = _ref2.withDestination,\n      withExposure = _ref2.withExposure,\n      withLedger = _ref2.withLedger,\n      withNominations = _ref2.withNominations,\n      withPrefs = _ref2.withPrefs;\n  var emptyNoms = api.registry.createType('Option<Nominations>');\n  var emptyRewa = api.registry.createType('RewardDestination');\n  var emptyExpo = api.registry.createType('Exposure');\n  var emptyPrefs = api.registry.createType('ValidatorPrefs');\n  return combineLatest([withController || withLedger ? api.query.staking.bonded.multi(stashIds) : of(stashIds.map(function () {\n    return null;\n  })), withNominations ? api.query.staking.nominators.multi(stashIds) : of(stashIds.map(function () {\n    return emptyNoms;\n  })), withDestination ? api.query.staking.payee.multi(stashIds) : of(stashIds.map(function () {\n    return emptyRewa;\n  })), withPrefs ? api.query.staking.validators.multi(stashIds) : of(stashIds.map(function () {\n    return emptyPrefs;\n  })), withExposure ? api.query.staking.erasStakers.multi(stashIds.map(function (stashId) {\n    return [activeEra, stashId];\n  })) : of(stashIds.map(function () {\n    return emptyExpo;\n  }))]);\n}\n\nfunction getBatch(api, activeEra, stashIds, flags) {\n  return getStashInfo(api, stashIds, activeEra, flags).pipe(switchMap(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 5),\n        controllerIdOpt = _ref4[0],\n        nominatorsOpt = _ref4[1],\n        rewardDestination = _ref4[2],\n        validatorPrefs = _ref4[3],\n        exposure = _ref4[4];\n\n    return getLedgers(api, controllerIdOpt, flags).pipe(map(function (stakingLedgerOpts) {\n      return stashIds.map(function (stashId, index) {\n        return parseDetails(stashId, controllerIdOpt[index], nominatorsOpt[index], rewardDestination[index], validatorPrefs[index], exposure[index], stakingLedgerOpts[index]);\n      });\n    }));\n  }));\n} //\n\n/**\n * @description From a stash, retrieve the controllerId and all relevant details\n */\n\n\nexport function query(instanceId, api) {\n  return memo(instanceId, function (accountId, flags) {\n    return api.derive.staking.queryMulti([accountId], flags).pipe(map(function (_ref5) {\n      var _ref6 = _slicedToArray(_ref5, 1),\n          first = _ref6[0];\n\n      return first;\n    }));\n  });\n}\nexport function queryMulti(instanceId, api) {\n  return memo(instanceId, function (accountIds, flags) {\n    return accountIds.length ? api.derive.session.indexes().pipe(switchMap(function (_ref7) {\n      var activeEra = _ref7.activeEra;\n      var stashIds = accountIds.map(function (accountId) {\n        return api.registry.createType('AccountId', accountId);\n      });\n      return getBatch(api, activeEra, stashIds, flags);\n    })) : of([]);\n  });\n}","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _construct from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/construct\";\nimport _toConsumableArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { logger } from '@polkadot/util';\nimport { createClass } from \"./createClass.js\";\nvar l = logger('registry'); // TODO: Fix and re-enable\n// With isPedantic, actually check that the encoding matches that supplied. This\n// is much slower, but verifies that we have the correct types defined\n// function checkInstance<T extends Codec = Codec, K extends string = string> (value: Uint8Array, created: FromReg<T, K>): void {\n//   // the underlying type created.toRawType()\n//   const rawType = created.toRawType();\n//   // ignore bytes completely - this is probably a FIXME, since these are somewhat\n//   // breaking for at least online queries - not quite sure wtf is going wrong here\n//   if (rawType === 'Bytes') {\n//     return;\n//   }\n//   // the hex values for what we have\n//   const inHex = u8aToHex(value);\n//   const crHex = created.toHex();\n//   // Check equality, based on some different approaches (as decoded)\n//   const isEqual = inHex === crHex || // raw hex values, quick path\n//     inHex === created.toHex(true) || // wrapped options\n//     u8aToHex(value.reverse()) === crHex; // reverse (for numbers, which are BE)\n//   // if the hex doesn't match and the value for both is non-empty, complain... bitterly\n//   if (!isEqual && (u8aHasValue(value) || u8aHasValue(created.toU8a(true)))) {\n//     l.warn(`${rawType}:: Input doesn't match output, received ${u8aToHex(value)}, created ${crHex}`);\n//   }\n// }\n// Initializes a type with a value. This also checks for fallbacks and in the cases\n// where isPedantic is specified (storage decoding), also check the format/structure\n\nfunction initType(registry, Type) {\n  var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n  var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n      blockHash = _ref.blockHash;\n\n  var created = _construct(Type, [registry].concat(_toConsumableArray(params)));\n\n  if (blockHash) {\n    created.createdAtHash = createType(registry, 'Hash', blockHash);\n  } // if (isPedantic && isU8a(value)) {\n  //   checkInstance(value, created);\n  // }\n\n\n  return created;\n} // An unsafe version of the `createType` below. It's unsafe because the `type`\n// argument here can be any string, which, when it cannot parse, will yield a\n// runtime error.\n\n\nexport function createTypeUnsafe(registry, type) {\n  var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  try {\n    // Circle back to isPedantic when it handles all cases 100% - as of now,\n    // it provides false warning which is more hinderance than help\n    return initType(registry, createClass(registry, type), params, options);\n  } catch (error) {\n    !options.withoutLog && l.error(error);\n    throw new Error(\"createType(\".concat(type, \"):: \").concat(error.message));\n  }\n}\n/**\n * Create an instance of a `type` with a given `params`.\n * @param type - A recognizable string representing the type to create an\n * instance from\n * @param params - The value to instantiate the type with\n */\n\nexport function createType(registry, type) {\n  for (var _len = arguments.length, params = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    params[_key - 2] = arguments[_key];\n  }\n\n  return createTypeUnsafe(registry, type, params);\n}","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { combineLatest, of } from '@polkadot/x-rxjs';\nimport { map, switchMap } from '@polkadot/x-rxjs/operators';\nimport { memo } from \"../util/index.js\";\nimport { didUpdateToBool } from \"./util.js\";\n\nfunction parse(_ref) {\n  var _ref2 = _slicedToArray(_ref, 5),\n      ids = _ref2[0],\n      didUpdate = _ref2[1],\n      infos = _ref2[2],\n      pendingSwaps = _ref2[3],\n      relayDispatchQueueSizes = _ref2[4];\n\n  return ids.map(function (id, index) {\n    return {\n      didUpdate: didUpdateToBool(didUpdate, id),\n      id: id,\n      info: _objectSpread({\n        id: id\n      }, infos[index].unwrapOr(null)),\n      pendingSwapId: pendingSwaps[index].unwrapOr(null),\n      relayDispatchQueueSize: relayDispatchQueueSizes[index][0].toNumber()\n    };\n  });\n}\n\nexport function overview(instanceId, api) {\n  return memo(instanceId, function () {\n    var _api$query$registrar;\n\n    return (_api$query$registrar = api.query.registrar) !== null && _api$query$registrar !== void 0 && _api$query$registrar.parachains && api.query.parachains ? api.query.registrar.parachains().pipe(switchMap(function (paraIds) {\n      return combineLatest([of(paraIds), api.query.parachains.didUpdate(), api.query.registrar.paras.multi(paraIds), api.query.registrar.pendingSwap.multi(paraIds), api.query.parachains.relayDispatchQueueSize.multi(paraIds)]);\n    }), map(parse)) : of([]);\n  });\n}","map":null,"metadata":{},"sourceType":"module"}
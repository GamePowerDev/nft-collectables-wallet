{"ast":null,"code":"import _toConsumableArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { isHex, isU8a, u8aConcat, u8aToU8a } from '@polkadot/util';\nimport { AbstractArray } from \"./AbstractArray.js\";\nimport { decodeU8a, mapToTypeMap, typeToConstructor } from \"./utils/index.js\";\n/** @internal */\n\nfunction decodeTuple(registry, _Types, value) {\n  if (isU8a(value) || isHex(value)) {\n    return decodeU8a(registry, u8aToU8a(value), _Types);\n  }\n\n  var Types = Array.isArray(_Types) ? _Types : Object.values(_Types);\n  return Types.map(function (Type, index) {\n    try {\n      var entry = value === null || value === void 0 ? void 0 : value[index];\n\n      if (entry instanceof Type) {\n        return entry;\n      }\n\n      return new Type(registry, entry);\n    } catch (error) {\n      throw new Error(\"Tuple: failed on \".concat(index, \":: \").concat(error.message));\n    }\n  });\n}\n/**\n * @name Tuple\n * @description\n * A Tuple defines an anonymous fixed-length array, where each element has its\n * own type. It extends the base JS `Array` object.\n */\n\n\nexport var Tuple = /*#__PURE__*/function (_AbstractArray) {\n  _inherits(Tuple, _AbstractArray);\n\n  var _super = _createSuper(Tuple);\n\n  function Tuple(registry, Types, value) {\n    var _this;\n\n    _classCallCheck(this, Tuple);\n\n    var Clazzes = Array.isArray(Types) ? Types.map(function (type) {\n      return typeToConstructor(registry, type);\n    }) : mapToTypeMap(registry, Types);\n    _this = _super.call.apply(_super, [this, registry].concat(_toConsumableArray(decodeTuple(registry, Clazzes, value))));\n    _this._Types = void 0;\n    _this._Types = Clazzes;\n    return _this;\n  }\n\n  _createClass(Tuple, [{\n    key: \"encodedLength\",\n    get:\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    function get() {\n      return this.reduce(function (length, entry) {\n        length += entry.encodedLength;\n        return length;\n      }, 0);\n    }\n    /**\n     * @description The types definition of the tuple\n     */\n\n  }, {\n    key: \"Types\",\n    get: function get() {\n      var _this2 = this;\n\n      return Array.isArray(this._Types) ? this._Types.map(function (Type) {\n        return new Type(_this2.registry).toRawType();\n      }) : Object.keys(this._Types);\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n\n  }, {\n    key: \"toRawType\",\n    value: function toRawType() {\n      var _this3 = this;\n\n      var types = (Array.isArray(this._Types) ? this._Types : Object.values(this._Types)).map(function (Type) {\n        return _this3.registry.getClassName(Type) || new Type(_this3.registry).toRawType();\n      });\n      return \"(\".concat(types.join(','), \")\");\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      // Overwrite the default toString representation of Array.\n      return JSON.stringify(this.toJSON());\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n\n  }, {\n    key: \"toU8a\",\n    value: function toU8a(isBare) {\n      return u8aConcat.apply(void 0, _toConsumableArray(this.map(function (entry) {\n        return entry.toU8a(isBare);\n      })));\n    }\n  }], [{\n    key: \"with\",\n    value: function _with(Types) {\n      return /*#__PURE__*/function (_Tuple) {\n        _inherits(_class, _Tuple);\n\n        var _super2 = _createSuper(_class);\n\n        function _class(registry, value) {\n          _classCallCheck(this, _class);\n\n          return _super2.call(this, registry, Types, value);\n        }\n\n        return _class;\n      }(Tuple);\n    }\n  }]);\n\n  return Tuple;\n}(AbstractArray);","map":null,"metadata":{},"sourceType":"module"}
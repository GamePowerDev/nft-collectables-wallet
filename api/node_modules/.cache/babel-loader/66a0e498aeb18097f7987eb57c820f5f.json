{"ast":null,"code":"import _regeneratorRuntime from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _asyncToGenerator from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/api authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { Metadata } from '@polkadot/metadata';\nimport { TypeRegistry } from '@polkadot/types/create';\nimport { getSpecAlias, getSpecExtensions, getSpecHasher, getSpecRpc, getSpecTypes, getUpgradeVersion } from '@polkadot/types-known';\nimport { assert, BN_ZERO, logger, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\nimport { of } from '@polkadot/x-rxjs';\nimport { map, switchMap } from '@polkadot/x-rxjs/operators';\nimport { detectedCapabilities } from \"./capabilities.js\";\nimport { Decorate } from \"./Decorate.js\";\nvar KEEPALIVE_INTERVAL = 10000;\nvar DEFAULT_BLOCKNUMBER = {\n  unwrap: function unwrap() {\n    return BN_ZERO;\n  }\n};\nvar l = logger('api/init');\n\nvar _healthTimer = _classPrivateFieldLooseKey(\"healthTimer\");\n\nvar _registries = _classPrivateFieldLooseKey(\"registries\");\n\nvar _updateSub = _classPrivateFieldLooseKey(\"updateSub\");\n\nvar _onProviderConnect = _classPrivateFieldLooseKey(\"onProviderConnect\");\n\nvar _onProviderDisconnect = _classPrivateFieldLooseKey(\"onProviderDisconnect\");\n\nvar _onProviderError = _classPrivateFieldLooseKey(\"onProviderError\");\n\nexport var Init = /*#__PURE__*/function (_Decorate) {\n  _inherits(Init, _Decorate);\n\n  var _super = _createSuper(Init);\n\n  function Init(options, type, decorateMethod) {\n    var _this;\n\n    _classCallCheck(this, Init);\n\n    _this = _super.call(this, options, type, decorateMethod); // all injected types added to the registry for overrides\n\n    Object.defineProperty(_assertThisInitialized(_this), _healthTimer, {\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _registries, {\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _updateSub, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _onProviderConnect, {\n      writable: true,\n      value: function () {\n        var _value = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n          var _yield$Promise$all, _yield$Promise$all2, hasMeta, cryptoReady, error;\n\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _this.emit('connected');\n\n                  _this._isConnected.next(true);\n\n                  _context.prev = 2;\n                  _context.next = 5;\n                  return Promise.all([_this._loadMeta(), _this._options.initWasm === false ? Promise.resolve(true) : cryptoWaitReady()]);\n\n                case 5:\n                  _yield$Promise$all = _context.sent;\n                  _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n                  hasMeta = _yield$Promise$all2[0];\n                  cryptoReady = _yield$Promise$all2[1];\n\n                  if (hasMeta && !_this._isReady && cryptoReady) {\n                    _this._isReady = true;\n\n                    _this.emit('ready', _assertThisInitialized(_this));\n                  }\n\n                  _classPrivateFieldLooseBase(_assertThisInitialized(_this), _healthTimer)[_healthTimer] = setInterval(function () {\n                    _this._rpcCore.system.health().toPromise().catch(function (error) {\n                      return l.warn(\"Health keepalive check failed: \".concat(error.message));\n                    });\n                  }, KEEPALIVE_INTERVAL);\n                  _context.next = 19;\n                  break;\n\n                case 13:\n                  _context.prev = 13;\n                  _context.t0 = _context[\"catch\"](2);\n                  error = new Error(\"FATAL: Unable to initialize the API: \".concat(_context.t0.message));\n                  l.error(error);\n                  l.error(_context.t0);\n\n                  _this.emit('error', error);\n\n                case 19:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, null, [[2, 13]]);\n        }));\n\n        function value() {\n          return _value.apply(this, arguments);\n        }\n\n        return value;\n      }()\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _onProviderDisconnect, {\n      writable: true,\n      value: function value() {\n        _this.emit('disconnected');\n\n        _this._isConnected.next(false);\n\n        if (_classPrivateFieldLooseBase(_assertThisInitialized(_this), _healthTimer)[_healthTimer]) {\n          clearInterval(_classPrivateFieldLooseBase(_assertThisInitialized(_this), _healthTimer)[_healthTimer]);\n          _classPrivateFieldLooseBase(_assertThisInitialized(_this), _healthTimer)[_healthTimer] = null;\n        }\n      }\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _onProviderError, {\n      writable: true,\n      value: function value(error) {\n        _this.emit('error', error);\n      }\n    });\n\n    _this.registry.setKnownTypes(options); // We only register the types (global) if this is not a cloned instance.\n    // Do right up-front, so we get in the user types before we are actually\n    // doing anything on-chain, this ensures we have the overrides in-place\n\n\n    if (!options.source) {\n      _this.registerTypes(options.types);\n    } else {\n      _classPrivateFieldLooseBase(_assertThisInitialized(_this), _registries)[_registries] = _classPrivateFieldLooseBase(options.source, _registries)[_registries];\n    }\n\n    _this._rpc = _this._decorateRpc(_this._rpcCore, _this._decorateMethod);\n    _this._rx.rpc = _this._decorateRpc(_this._rpcCore, _this._rxDecorateMethod);\n\n    if (_this.supportMulti) {\n      _this._queryMulti = _this._decorateMulti(_this._decorateMethod);\n      _this._rx.queryMulti = _this._decorateMulti(_this._rxDecorateMethod);\n    }\n\n    _this._rx.signer = options.signer;\n\n    _this._rpcCore.setRegistrySwap(function (hash) {\n      return _this.getBlockRegistry(hash);\n    });\n\n    if (_this.hasSubscriptions) {\n      _this._rpcCore.provider.on('disconnected', _classPrivateFieldLooseBase(_assertThisInitialized(_this), _onProviderDisconnect)[_onProviderDisconnect]);\n\n      _this._rpcCore.provider.on('error', _classPrivateFieldLooseBase(_assertThisInitialized(_this), _onProviderError)[_onProviderError]);\n\n      _this._rpcCore.provider.on('connected', _classPrivateFieldLooseBase(_assertThisInitialized(_this), _onProviderConnect)[_onProviderConnect]);\n    } else {\n      l.warn('Api will be available in a limited mode since the provider does not support subscriptions');\n    } // If the provider was instantiated earlier, and has already emitted a\n    // 'connected' event, then the `on('connected')` won't fire anymore. To\n    // cater for this case, we call manually `this._onProviderConnect`.\n\n\n    if (_this._rpcCore.provider.isConnected) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      _classPrivateFieldLooseBase(_assertThisInitialized(_this), _onProviderConnect)[_onProviderConnect]();\n    }\n\n    return _this;\n  }\n  /**\n   * @description Decorates a registry based on the runtime version\n   */\n\n\n  _createClass(Init, [{\n    key: \"_initRegistry\",\n    value: function _initRegistry(registry, chain, version, metadata, chainProps) {\n      registry.setChainProperties(chainProps || this.registry.getChainProperties());\n      registry.setKnownTypes(this._options);\n      registry.register(getSpecTypes(registry, chain, version.specName, version.specVersion));\n      registry.setHasher(getSpecHasher(registry, chain, version.specName)); // for bundled types, pull through the aliases defined\n\n      if (registry.knownTypes.typesBundle) {\n        registry.knownTypes.typesAlias = getSpecAlias(registry, chain, version.specName);\n      }\n\n      registry.setMetadata(metadata, undefined, _objectSpread(_objectSpread({}, getSpecExtensions(registry, chain, version.specName)), this._options.signedExtensions || {}));\n      return registry;\n    }\n    /**\n     * @description Sets up a registry based on the block hash defined\n     */\n\n  }, {\n    key: \"getBlockRegistry\",\n    value: function () {\n      var _getBlockRegistry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(blockHash) {\n        var lastBlockHash, existingViaHash, header, _getUpgradeVersion, _getUpgradeVersion2, firstVersion, lastVersion, version, existingViaVersion, metadata, registry, result;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                // shortcut in the case where we have an immediate-same request\n                lastBlockHash = u8aToU8a(blockHash);\n                existingViaHash = _classPrivateFieldLooseBase(this, _registries)[_registries].find(function (r) {\n                  return r.lastBlockHash && u8aEq(lastBlockHash, r.lastBlockHash);\n                });\n\n                if (!existingViaHash) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", existingViaHash);\n\n              case 4:\n                // ensure we have everything required\n                assert(this._genesisHash && this._runtimeVersion, 'Cannot retrieve data on an uninitialized chain'); // We have to assume that on the RPC layer the calls used here does not call back into\n                // the registry swap, so getHeader & getRuntimeVersion should not be historic\n\n                if (!this._genesisHash.eq(blockHash)) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                _context2.t0 = {\n                  number: DEFAULT_BLOCKNUMBER,\n                  parentHash: this._genesisHash\n                };\n                _context2.next = 12;\n                break;\n\n              case 9:\n                _context2.next = 11;\n                return this._rpcCore.chain.getHeader(blockHash).toPromise();\n\n              case 11:\n                _context2.t0 = _context2.sent;\n\n              case 12:\n                header = _context2.t0;\n                assert((header === null || header === void 0 ? void 0 : header.parentHash) && !header.parentHash.isEmpty, 'Unable to retrieve header and parent from supplied hash'); // get the runtime version, either on-chain or via an known upgrade history\n\n                _getUpgradeVersion = getUpgradeVersion(this._genesisHash, header.number.unwrap()), _getUpgradeVersion2 = _slicedToArray(_getUpgradeVersion, 2), firstVersion = _getUpgradeVersion2[0], lastVersion = _getUpgradeVersion2[1];\n\n                if (!(firstVersion && (lastVersion || firstVersion.specVersion.eq(this._runtimeVersion.specVersion)))) {\n                  _context2.next = 19;\n                  break;\n                }\n\n                _context2.t1 = {\n                  specName: this._runtimeVersion.specName,\n                  specVersion: firstVersion.specVersion\n                };\n                _context2.next = 22;\n                break;\n\n              case 19:\n                _context2.next = 21;\n                return this._rpcCore.state.getRuntimeVersion(header.parentHash).toPromise();\n\n              case 21:\n                _context2.t1 = _context2.sent;\n\n              case 22:\n                version = _context2.t1;\n                // check for pre-existing registries\n                existingViaVersion = _classPrivateFieldLooseBase(this, _registries)[_registries].find(function (r) {\n                  return r.specVersion.eq(version.specVersion);\n                });\n\n                if (!existingViaVersion) {\n                  _context2.next = 27;\n                  break;\n                }\n\n                existingViaVersion.lastBlockHash = lastBlockHash;\n                return _context2.abrupt(\"return\", existingViaVersion);\n\n              case 27:\n                _context2.next = 29;\n                return this._rpcCore.state.getMetadata(header.parentHash).toPromise();\n\n              case 29:\n                metadata = _context2.sent;\n                registry = this._initRegistry(new TypeRegistry(blockHash), this._runtimeChain, version, metadata); // For now, since this is new we ignore the capability lookups (this could be useful once proven)\n                // this._detectCapabilities(registry, blockHash);\n                // add our new registry\n\n                result = {\n                  isDefault: false,\n                  lastBlockHash: lastBlockHash,\n                  metadata: metadata,\n                  metadataConsts: null,\n                  registry: registry,\n                  specVersion: version.specVersion\n                };\n\n                _classPrivateFieldLooseBase(this, _registries)[_registries].push(result);\n\n                return _context2.abrupt(\"return\", result);\n\n              case 34:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getBlockRegistry(_x) {\n        return _getBlockRegistry.apply(this, arguments);\n      }\n\n      return getBlockRegistry;\n    }()\n  }, {\n    key: \"_loadMeta\",\n    value: function () {\n      var _loadMeta2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _this$_options$source, _ref, _ref2;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!this._isReady) {\n                  _context3.next = 4;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", true);\n\n              case 4:\n                if (_classPrivateFieldLooseBase(this, _updateSub)[_updateSub]) {\n                  _classPrivateFieldLooseBase(this, _updateSub)[_updateSub].unsubscribe();\n                }\n\n              case 5:\n                if (!((_this$_options$source = this._options.source) !== null && _this$_options$source !== void 0 && _this$_options$source._isReady)) {\n                  _context3.next = 11;\n                  break;\n                }\n\n                _context3.next = 8;\n                return this._metaFromSource(this._options.source);\n\n              case 8:\n                _context3.t0 = _context3.sent;\n                _context3.next = 14;\n                break;\n\n              case 11:\n                _context3.next = 13;\n                return this._metaFromChain(this._options.metadata);\n\n              case 13:\n                _context3.t0 = _context3.sent;\n\n              case 14:\n                _ref = _context3.t0;\n                _ref2 = _slicedToArray(_ref, 2);\n                this._genesisHash = _ref2[0];\n                this._runtimeMetadata = _ref2[1];\n                return _context3.abrupt(\"return\", this._initFromMeta(this._runtimeMetadata));\n\n              case 19:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _loadMeta() {\n        return _loadMeta2.apply(this, arguments);\n      }\n\n      return _loadMeta;\n    }() // eslint-disable-next-line @typescript-eslint/require-await\n\n  }, {\n    key: \"_metaFromSource\",\n    value: function () {\n      var _metaFromSource2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(source) {\n        var methods;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                this._extrinsicType = source.extrinsicVersion;\n                this._runtimeChain = source.runtimeChain;\n                this._runtimeVersion = source.runtimeVersion;\n                methods = []; // manually build a list of all available methods in this RPC, we are\n                // going to filter on it to align the cloned RPC without making a call\n\n                Object.keys(source.rpc).forEach(function (section) {\n                  Object.keys(source.rpc[section]).forEach(function (method) {\n                    methods.push(\"\".concat(section, \"_\").concat(method));\n                  });\n                });\n\n                this._filterRpcMethods(methods);\n\n                return _context4.abrupt(\"return\", [source.genesisHash, source.runtimeMetadata]);\n\n              case 7:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _metaFromSource(_x2) {\n        return _metaFromSource2.apply(this, arguments);\n      }\n\n      return _metaFromSource;\n    }()\n  }, {\n    key: \"_detectCapabilities\",\n    value: function _detectCapabilities(registry, blockHash) {\n      var _this2 = this;\n\n      detectedCapabilities(this._rx, blockHash).toPromise().then(function (types) {\n        if (Object.keys(types).length) {\n          (registry || _this2.registry).register(types);\n\n          l.debug(\"Capabilities detected\".concat(blockHash ? \" (\".concat(u8aToHex(u8aToU8a(blockHash)), \")\") : '', \": \").concat(JSON.stringify(types)));\n        }\n      }).catch(l.error);\n    } // subscribe to metadata updates, inject the types on changes\n\n  }, {\n    key: \"_subscribeUpdates\",\n    value: function _subscribeUpdates() {\n      var _this3 = this;\n\n      if (_classPrivateFieldLooseBase(this, _updateSub)[_updateSub] || !this.hasSubscriptions) {\n        return;\n      }\n\n      _classPrivateFieldLooseBase(this, _updateSub)[_updateSub] = this._rpcCore.state.subscribeRuntimeVersion().pipe(switchMap(function (version) {\n        var _this$_runtimeVersion;\n\n        return (// only retrieve the metadata when the on-chain version has been changed\n          (_this$_runtimeVersion = _this3._runtimeVersion) !== null && _this$_runtimeVersion !== void 0 && _this$_runtimeVersion.specVersion.eq(version.specVersion) ? of(false) : _this3._rpcCore.state.getMetadata().pipe(map(function (metadata) {\n            l.log(\"Runtime version updated to spec=\".concat(version.specVersion.toString(), \", tx=\").concat(version.transactionVersion.toString()));\n            _this3._runtimeMetadata = metadata;\n            _this3._runtimeVersion = version;\n            _this3._rx.runtimeVersion = version; // update the default registry version\n\n            var thisRegistry = _classPrivateFieldLooseBase(_this3, _registries)[_registries].find(function (_ref3) {\n              var isDefault = _ref3.isDefault;\n              return isDefault;\n            });\n\n            assert(thisRegistry, 'Initialization error, cannot find the default registry'); // setup the data as per the current versions\n\n            thisRegistry.metadata = metadata;\n            thisRegistry.metadataConsts = null;\n            thisRegistry.specVersion = version.specVersion; // clear the registry types to ensure that we override correctly\n\n            _this3._initRegistry(thisRegistry.registry.init(), _this3._runtimeChain, version, metadata);\n\n            _this3.injectMetadata(metadata, false, thisRegistry.registry);\n\n            _this3._detectCapabilities(thisRegistry.registry);\n\n            return true;\n          }))\n        );\n      })).subscribe();\n    }\n  }, {\n    key: \"_metaFromChain\",\n    value: function () {\n      var _metaFromChain2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(optMetadata) {\n        var _yield$Promise$all3, _yield$Promise$all4, genesisHash, runtimeVersion, chain, chainProps, rpcMethods, chainMetadata, metadataKey, metadata;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return Promise.all([this._rpcCore.chain.getBlockHash(0).toPromise(), this._rpcCore.state.getRuntimeVersion().toPromise(), this._rpcCore.system.chain().toPromise(), this._rpcCore.system.properties().toPromise(), this._rpcCore.rpc.methods().toPromise(), optMetadata ? Promise.resolve(null) : this._rpcCore.state.getMetadata().toPromise()]);\n\n              case 2:\n                _yield$Promise$all3 = _context5.sent;\n                _yield$Promise$all4 = _slicedToArray(_yield$Promise$all3, 6);\n                genesisHash = _yield$Promise$all4[0];\n                runtimeVersion = _yield$Promise$all4[1];\n                chain = _yield$Promise$all4[2];\n                chainProps = _yield$Promise$all4[3];\n                rpcMethods = _yield$Promise$all4[4];\n                chainMetadata = _yield$Promise$all4[5];\n                // set our chain version & genesisHash as returned\n                this._runtimeChain = chain;\n                this._runtimeVersion = runtimeVersion;\n                this._rx.runtimeVersion = runtimeVersion; // retrieve metadata, either from chain  or as pass-in via options\n\n                metadataKey = \"\".concat(genesisHash.toHex() || '0x', \"-\").concat(runtimeVersion.specVersion.toString());\n                _context5.t0 = chainMetadata;\n\n                if (_context5.t0) {\n                  _context5.next = 24;\n                  break;\n                }\n\n                if (!(optMetadata && optMetadata[metadataKey])) {\n                  _context5.next = 20;\n                  break;\n                }\n\n                _context5.t1 = new Metadata(this.registry, optMetadata[metadataKey]);\n                _context5.next = 23;\n                break;\n\n              case 20:\n                _context5.next = 22;\n                return this._rpcCore.state.getMetadata().toPromise();\n\n              case 22:\n                _context5.t1 = _context5.sent;\n\n              case 23:\n                _context5.t0 = _context5.t1;\n\n              case 24:\n                metadata = _context5.t0;\n\n                // initializes the registry & RPC\n                this._initRegistry(this.registry, chain, runtimeVersion, metadata, chainProps);\n\n                this._filterRpc(rpcMethods, getSpecRpc(this.registry, chain, runtimeVersion.specName));\n\n                this._subscribeUpdates(); // setup the initial registry, when we have none\n\n\n                if (!_classPrivateFieldLooseBase(this, _registries)[_registries].length) {\n                  _classPrivateFieldLooseBase(this, _registries)[_registries].push({\n                    isDefault: true,\n                    lastBlockHash: null,\n                    metadata: metadata,\n                    metadataConsts: null,\n                    registry: this.registry,\n                    specVersion: runtimeVersion.specVersion\n                  });\n                } // get unique types & validate\n\n\n                metadata.getUniqTypes(false);\n                return _context5.abrupt(\"return\", [genesisHash, metadata]);\n\n              case 31:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function _metaFromChain(_x3) {\n        return _metaFromChain2.apply(this, arguments);\n      }\n\n      return _metaFromChain;\n    }()\n  }, {\n    key: \"_initFromMeta\",\n    value: function _initFromMeta(metadata) {\n      this._extrinsicType = metadata.asLatest.extrinsic.version.toNumber();\n      this._rx.extrinsicType = this._extrinsicType;\n      this._rx.genesisHash = this._genesisHash;\n      this._rx.runtimeVersion = this._runtimeVersion; // must be set here\n      // inject metadata and adjust the types as detected\n\n      this.injectMetadata(metadata, true);\n\n      this._detectCapabilities(); // derive is last, since it uses the decorated rx\n\n\n      this._rx.derive = this._decorateDeriveRx(this._rxDecorateMethod);\n      this._derive = this._decorateDerive(this._decorateMethod);\n      return true;\n    }\n  }]);\n\n  return Init;\n}(Decorate);","map":null,"metadata":{},"sourceType":"module"}
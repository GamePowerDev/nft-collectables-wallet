{"ast":null,"code":"import _toConsumableArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _wrapNativeSuper from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper\";\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { compactToU8a, u8aConcat, u8aToHex } from '@polkadot/util';\nimport { compareArray } from \"./utils/index.js\";\n/**\n * @name AbstractArray\n * @description\n * This manages codec arrays. It is an extension to Array, providing\n * specific encoding/decoding on top of the base type.\n * @noInheritDoc\n */\n\nexport var AbstractArray = /*#__PURE__*/function (_Array) {\n  _inherits(AbstractArray, _Array);\n\n  var _super = _createSuper(AbstractArray);\n\n  function AbstractArray(registry) {\n    var _this;\n\n    _classCallCheck(this, AbstractArray);\n\n    for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      values[_key - 1] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(values));\n    _this.registry = void 0;\n    _this.createdAtHash = void 0;\n    _this.registry = registry;\n    return _this;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  _createClass(AbstractArray, [{\n    key: \"encodedLength\",\n    get: function get() {\n      return this.reduce(function (total, raw) {\n        return total + raw.encodedLength;\n      }, compactToU8a(this.length).length);\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n\n  }, {\n    key: \"hash\",\n    get: function get() {\n      return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description Checks if the value is an empty value\n     */\n\n  }, {\n    key: \"isEmpty\",\n    get: function get() {\n      return this.length === 0;\n    }\n    /**\n     * @description The length of the value\n     */\n\n  }, {\n    key: \"length\",\n    get: function get() {\n      // only included here since we ignore inherited docs\n      return _get(_getPrototypeOf(AbstractArray.prototype), \"length\", this);\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return compareArray(this, other);\n    }\n    /**\n     * @description Converts the Object to an standard JavaScript Array\n     */\n\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      return Array.from(this);\n    }\n    /**\n     * @description Returns a hex string representation of the value\n     */\n\n  }, {\n    key: \"toHex\",\n    value: function toHex() {\n      return u8aToHex(this.toU8a());\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n\n  }, {\n    key: \"toHuman\",\n    value: function toHuman(isExtended) {\n      return this.map(function (entry) {\n        return entry.toHuman(isExtended);\n      });\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.map(function (entry) {\n        return entry.toJSON();\n      });\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n\n    /**\n     * @description Returns the string representation of the value\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      // Overwrite the default toString representation of Array.\n      var data = this.map(function (entry) {\n        return entry.toString();\n      });\n      return \"[\".concat(data.join(', '), \"]\");\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n\n  }, {\n    key: \"toU8a\",\n    value: function toU8a(isBare) {\n      var encoded = this.map(function (entry) {\n        return entry.toU8a(isBare);\n      });\n      return isBare ? u8aConcat.apply(void 0, _toConsumableArray(encoded)) : u8aConcat.apply(void 0, [compactToU8a(this.length)].concat(_toConsumableArray(encoded)));\n    } // Below are methods that we override. When we do a `new Vec(...).map()`,\n    // we want it to return an Array. We only override the methods that return a\n    // new instance.\n\n    /**\n     * @description Concatenates two arrays\n     */\n\n  }, {\n    key: \"concat\",\n    value: function concat(other) {\n      return this.toArray().concat(other instanceof AbstractArray ? other.toArray() : other);\n    }\n    /**\n     * @description Filters the array with the callback\n     */\n\n  }, {\n    key: \"filter\",\n    value: function filter(callbackfn, thisArg) {\n      return this.toArray().filter(callbackfn, thisArg);\n    }\n    /**\n     * @description Maps the array with the callback\n     */\n\n  }, {\n    key: \"map\",\n    value: function map(callbackfn, thisArg) {\n      return this.toArray().map(callbackfn, thisArg);\n    }\n    /**\n     * @description Checks if the array includes a specific value\n     */\n\n  }, {\n    key: \"includes\",\n    value: function includes(check) {\n      return this.some(function (value) {\n        return value.eq(check);\n      });\n    }\n    /**\n     * @description Returns a slice of an array\n     */\n\n  }, {\n    key: \"slice\",\n    value: function slice(start, end) {\n      return this.toArray().slice(start, end);\n    }\n  }]);\n\n  return AbstractArray;\n}( /*#__PURE__*/_wrapNativeSuper(Array));","map":null,"metadata":{},"sourceType":"module"}
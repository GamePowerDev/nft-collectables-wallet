{"ast":null,"code":"import _toConsumableArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, compactFromU8a, compactToU8a, isString, u8aConcat, u8aToU8a } from '@polkadot/util';\nimport { Raw } from \"../codec/Raw.js\";\n/** @internal */\n\nfunction decodeBitVecU8a(value) {\n  if (!value || !value.length) {\n    return new Uint8Array();\n  } // handle all other Uint8Array inputs, these do have a length prefix which is the number of bits encoded\n\n\n  var _compactFromU8a = compactFromU8a(value),\n      _compactFromU8a2 = _slicedToArray(_compactFromU8a, 2),\n      offset = _compactFromU8a2[0],\n      length = _compactFromU8a2[1];\n\n  var total = offset + Math.ceil(length.toNumber() / 8);\n  assert(total <= value.length, \"BitVec: required length less than remainder, expected at least \".concat(total, \", found \").concat(value.length));\n  return value.subarray(offset, total);\n}\n/** @internal */\n\n\nfunction decodeBitVec(value) {\n  if (Array.isArray(value) || isString(value)) {\n    return u8aToU8a(value);\n  }\n\n  return decodeBitVecU8a(value);\n}\n/**\n * @name BitVec\n * @description\n * A BitVec that represents an array of bits. The bits are however stored encoded. The difference between this\n * and a normal Bytes would be that the length prefix indicates the number of bits encoded, not the bytes\n */\n\n\nexport var BitVec = /*#__PURE__*/function (_Raw) {\n  _inherits(BitVec, _Raw);\n\n  var _super = _createSuper(BitVec);\n\n  function BitVec(registry, value) {\n    _classCallCheck(this, BitVec);\n\n    return _super.call(this, registry, decodeBitVec(value));\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  _createClass(BitVec, [{\n    key: \"encodedLength\",\n    get: function get() {\n      return this.length + compactToU8a(this.bitLength()).length;\n    }\n  }, {\n    key: \"toHuman\",\n    value: function toHuman() {\n      return \"0b\".concat(_toConsumableArray(this.toU8a(true)).map(function (d) {\n        return \"00000000\".concat(d.toString(2)).slice(-8);\n      }).join('_'));\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n\n  }, {\n    key: \"toRawType\",\n    value: function toRawType() {\n      return 'BitVec';\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n\n  }, {\n    key: \"toU8a\",\n    value: function toU8a(isBare) {\n      var bitVec = _get(_getPrototypeOf(BitVec.prototype), \"toU8a\", this).call(this);\n\n      return isBare ? bitVec : u8aConcat(compactToU8a(this.bitLength()), bitVec);\n    }\n  }]);\n\n  return BitVec;\n}(Raw);","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _createClass2 from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _inherits from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable @typescript-eslint/no-var-requires */\n// we are attempting to avoid circular refs, hence the Metadata path import\n\n\nimport { decorateConstants, decorateExtrinsics } from '@polkadot/metadata/decorate';\nimport { Metadata } from '@polkadot/metadata/Metadata';\nimport { assert, assertReturn, BN_ZERO, formatBalance, isFunction, isString, isU8a, logger, stringCamelCase, u8aToHex } from '@polkadot/util';\nimport { blake2AsU8a } from '@polkadot/util-crypto';\nimport { Json } from \"../codec/Json.js\";\nimport { Raw } from \"../codec/Raw.js\";\nimport { defaultExtensions, expandExtensionTypes, findUnknownExtensions } from \"../extrinsic/signedExtensions/index.js\";\nimport { GenericEventData } from \"../generic/Event.js\";\nimport * as baseTypes from \"../index.types.js\";\nimport * as definitions from \"../interfaces/definitions.js\";\nimport { DoNotConstruct } from \"../primitive/DoNotConstruct.js\";\nimport { createClass as _createClass, getTypeClass } from \"./createClass.js\";\nimport { createType as _createType } from \"./createType.js\";\nimport { getTypeDef } from \"./getTypeDef.js\";\nvar l = logger('registry'); // create error mapping from metadata\n\nfunction injectErrors(_, metadata, metadataErrors) {\n  var modules = metadata.asLatest.modules; // decorate the errors\n\n  modules.forEach(function (section, _sectionIndex) {\n    var sectionIndex = metadata.version >= 12 ? section.index.toNumber() : _sectionIndex;\n    var sectionName = stringCamelCase(section.name);\n    section.errors.forEach(function (_ref, index) {\n      var documentation = _ref.documentation,\n          name = _ref.name;\n      var eventIndex = new Uint8Array([sectionIndex, index]);\n      metadataErrors[u8aToHex(eventIndex)] = {\n        documentation: documentation.map(function (d) {\n          return d.toString();\n        }),\n        index: index,\n        method: name.toString(),\n        name: name.toString(),\n        section: sectionName\n      };\n    });\n  });\n} // create event classes from metadata\n\n\nfunction injectEvents(registry, metadata, metadataEvents) {\n  var modules = metadata.asLatest.modules; // decorate the events\n\n  modules.filter(function (_ref2) {\n    var events = _ref2.events;\n    return events.isSome;\n  }).forEach(function (section, _sectionIndex) {\n    var sectionIndex = metadata.version >= 12 ? section.index.toNumber() : _sectionIndex;\n    var sectionName = stringCamelCase(section.name);\n    section.events.unwrap().forEach(function (meta, methodIndex) {\n      var methodName = meta.name.toString();\n      var eventIndex = new Uint8Array([sectionIndex, methodIndex]); // eslint-disable-next-line @typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access\n\n      var typeDef = meta.args.map(function (arg) {\n        return getTypeDef(arg);\n      });\n      var Types = [];\n\n      try {\n        Types = typeDef.map(function (typeDef) {\n          return getTypeClass(registry, typeDef);\n        });\n      } catch (error) {\n        l.error(error);\n      }\n\n      metadataEvents[u8aToHex(eventIndex)] = /*#__PURE__*/function (_GenericEventData) {\n        _inherits(_class, _GenericEventData);\n\n        var _super = _createSuper(_class);\n\n        function _class(registry, value) {\n          _classCallCheck(this, _class);\n\n          return _super.call(this, registry, value, Types, typeDef, meta, sectionName, methodName);\n        }\n\n        return _class;\n      }(GenericEventData);\n    });\n  });\n} // create extrinsic mapping from metadata\n\n\nfunction injectExtrinsics(registry, metadata, metadataCalls) {\n  var extrinsics = decorateExtrinsics(registry, metadata.asLatest, metadata.version); // decorate the extrinsics\n\n  Object.values(extrinsics).forEach(function (methods) {\n    return Object.values(methods).forEach(function (method) {\n      metadataCalls[u8aToHex(method.callIndex)] = method;\n    });\n  });\n} // extract additional properties from the metadata\n\n\nfunction extractProperties(registry, metadata) {\n  var _constants$system;\n\n  var original = registry.getChainProperties();\n  var constants = decorateConstants(registry, metadata.asLatest);\n  var ss58Format = (_constants$system = constants.system) === null || _constants$system === void 0 ? void 0 : _constants$system.ss58Prefix;\n\n  if (!ss58Format) {\n    return original;\n  }\n\n  var _ref3 = original || {},\n      tokenDecimals = _ref3.tokenDecimals,\n      tokenSymbol = _ref3.tokenSymbol;\n\n  return registry.createType('ChainProperties', {\n    ss58Format: ss58Format,\n    tokenDecimals: tokenDecimals,\n    tokenSymbol: tokenSymbol\n  });\n}\n\nvar _classes = _classPrivateFieldLooseKey(\"classes\");\n\nvar _definitions = _classPrivateFieldLooseKey(\"definitions\");\n\nvar _metadataCalls = _classPrivateFieldLooseKey(\"metadataCalls\");\n\nvar _metadataErrors = _classPrivateFieldLooseKey(\"metadataErrors\");\n\nvar _metadataEvents = _classPrivateFieldLooseKey(\"metadataEvents\");\n\nvar _unknownTypes = _classPrivateFieldLooseKey(\"unknownTypes\");\n\nvar _chainProperties = _classPrivateFieldLooseKey(\"chainProperties\");\n\nvar _hasher = _classPrivateFieldLooseKey(\"hasher\");\n\nvar _knownDefaults = _classPrivateFieldLooseKey(\"knownDefaults\");\n\nvar _knownDefinitions = _classPrivateFieldLooseKey(\"knownDefinitions\");\n\nvar _knownTypes = _classPrivateFieldLooseKey(\"knownTypes\");\n\nvar _signedExtensions = _classPrivateFieldLooseKey(\"signedExtensions\");\n\nvar _userExtensions = _classPrivateFieldLooseKey(\"userExtensions\");\n\nexport var TypeRegistry = /*#__PURE__*/function () {\n  function TypeRegistry(createdAtHash) {\n    _classCallCheck(this, TypeRegistry);\n\n    Object.defineProperty(this, _classes, {\n      writable: true,\n      value: new Map()\n    });\n    Object.defineProperty(this, _definitions, {\n      writable: true,\n      value: new Map()\n    });\n    Object.defineProperty(this, _metadataCalls, {\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, _metadataErrors, {\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, _metadataEvents, {\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, _unknownTypes, {\n      writable: true,\n      value: new Map()\n    });\n    Object.defineProperty(this, _chainProperties, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _hasher, {\n      writable: true,\n      value: blake2AsU8a\n    });\n    Object.defineProperty(this, _knownDefaults, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _knownDefinitions, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _knownTypes, {\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, _signedExtensions, {\n      writable: true,\n      value: defaultExtensions\n    });\n    Object.defineProperty(this, _userExtensions, {\n      writable: true,\n      value: void 0\n    });\n    this.createdAtHash = void 0;\n    _classPrivateFieldLooseBase(this, _knownDefaults)[_knownDefaults] = _objectSpread({\n      Json: Json,\n      Metadata: Metadata,\n      Raw: Raw\n    }, baseTypes);\n    _classPrivateFieldLooseBase(this, _knownDefinitions)[_knownDefinitions] = definitions;\n    this.init();\n\n    if (createdAtHash) {\n      this.createdAtHash = this.createType('Hash', createdAtHash);\n    }\n  }\n\n  _createClass2(TypeRegistry, [{\n    key: \"init\",\n    value: function init() {\n      var _this = this;\n\n      // start clean\n      _classPrivateFieldLooseBase(this, _classes)[_classes] = new Map();\n      _classPrivateFieldLooseBase(this, _definitions)[_definitions] = new Map();\n      _classPrivateFieldLooseBase(this, _unknownTypes)[_unknownTypes] = new Map();\n      _classPrivateFieldLooseBase(this, _knownTypes)[_knownTypes] = {}; // register know, first classes then on-demand-created definitions\n\n      this.register(_classPrivateFieldLooseBase(this, _knownDefaults)[_knownDefaults]);\n      Object.values(_classPrivateFieldLooseBase(this, _knownDefinitions)[_knownDefinitions]).forEach(function (_ref4) {\n        var types = _ref4.types;\n        return _this.register(types);\n      });\n      return this;\n    }\n  }, {\n    key: \"chainDecimals\",\n    get: function get() {\n      var _classPrivateFieldLoo;\n\n      if ((_classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties]) !== null && _classPrivateFieldLoo !== void 0 && _classPrivateFieldLoo.tokenDecimals.isSome) {\n        var allDecimals = _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties].tokenDecimals.unwrap();\n\n        if (allDecimals.length) {\n          return allDecimals.map(function (b) {\n            return b.toNumber();\n          });\n        }\n      }\n\n      return [12];\n    }\n  }, {\n    key: \"chainSS58\",\n    get: function get() {\n      var _classPrivateFieldLoo2;\n\n      return (_classPrivateFieldLoo2 = _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties]) !== null && _classPrivateFieldLoo2 !== void 0 && _classPrivateFieldLoo2.ss58Format.isSome ? _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties].ss58Format.unwrap().toNumber() : undefined;\n    }\n  }, {\n    key: \"chainTokens\",\n    get: function get() {\n      var _classPrivateFieldLoo3;\n\n      if ((_classPrivateFieldLoo3 = _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties]) !== null && _classPrivateFieldLoo3 !== void 0 && _classPrivateFieldLoo3.tokenSymbol.isSome) {\n        var allTokens = _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties].tokenSymbol.unwrap();\n\n        if (allTokens.length) {\n          return allTokens.map(function (s) {\n            return s.toString();\n          });\n        }\n      }\n\n      return [formatBalance.getDefaults().unit];\n    }\n  }, {\n    key: \"knownTypes\",\n    get: function get() {\n      return _classPrivateFieldLooseBase(this, _knownTypes)[_knownTypes];\n    }\n  }, {\n    key: \"unknownTypes\",\n    get: function get() {\n      return _toConsumableArray(_classPrivateFieldLooseBase(this, _unknownTypes)[_unknownTypes].keys());\n    }\n  }, {\n    key: \"signedExtensions\",\n    get: function get() {\n      return _classPrivateFieldLooseBase(this, _signedExtensions)[_signedExtensions];\n    }\n    /**\n     * @describe Creates an instance of the class\n     */\n\n  }, {\n    key: \"createClass\",\n    value: function createClass(type) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      return _createClass(this, type);\n    }\n    /**\n     * @description Creates an instance of a type as registered\n     */\n\n  }, {\n    key: \"createType\",\n    value: function createType(type) {\n      for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        params[_key - 1] = arguments[_key];\n      }\n\n      return _createType.apply(void 0, [this, type].concat(params));\n    } // find a specific call\n\n  }, {\n    key: \"findMetaCall\",\n    value: function findMetaCall(callIndex) {\n      var hexIndex = u8aToHex(callIndex);\n      return assertReturn(_classPrivateFieldLooseBase(this, _metadataCalls)[_metadataCalls][hexIndex], \"findMetaCall: Unable to find Call with index \".concat(hexIndex, \"/[\").concat(callIndex.toString(), \"]\"));\n    } // finds an error\n\n  }, {\n    key: \"findMetaError\",\n    value: function findMetaError(errorIndex) {\n      var hexIndex = u8aToHex(isU8a(errorIndex) ? errorIndex : new Uint8Array([errorIndex.index.toNumber(), errorIndex.error.toNumber()]));\n      return assertReturn(_classPrivateFieldLooseBase(this, _metadataErrors)[_metadataErrors][hexIndex], \"findMetaError: Unable to find Error with index \".concat(hexIndex, \"/[\").concat(errorIndex.toString(), \"]\"));\n    }\n  }, {\n    key: \"findMetaEvent\",\n    value: function findMetaEvent(eventIndex) {\n      var hexIndex = u8aToHex(eventIndex);\n      return assertReturn(_classPrivateFieldLooseBase(this, _metadataEvents)[_metadataEvents][hexIndex], \"findMetaEvent: Unable to find Event with index \".concat(hexIndex, \"/[\").concat(eventIndex.toString(), \"]\"));\n    }\n  }, {\n    key: \"get\",\n    value: function get(name, withUnknown) {\n      var Type = _classPrivateFieldLooseBase(this, _classes)[_classes].get(name); // we have not already created the type, attempt it\n\n\n      if (!Type) {\n        var definition = _classPrivateFieldLooseBase(this, _definitions)[_definitions].get(name);\n\n        var BaseType; // we have a definition, so create the class now (lazily)\n\n        if (definition) {\n          BaseType = _createClass(this, definition);\n        } else if (withUnknown) {\n          l.warn(\"Unable to resolve type \".concat(name, \", it will fail on construction\"));\n\n          _classPrivateFieldLooseBase(this, _unknownTypes)[_unknownTypes].set(name, true);\n\n          BaseType = DoNotConstruct.with(name);\n        }\n\n        if (BaseType) {\n          // NOTE If we didn't extend here, we would have strange artifacts. An example is\n          // Balance, with this, new Balance() instanceof u128 is true, but Balance !== u128\n          // Additionally, we now pass through the registry, which is a link to ourselves\n          Type = /*#__PURE__*/function (_BaseType) {\n            _inherits(Type, _BaseType);\n\n            var _super2 = _createSuper(Type);\n\n            function Type() {\n              _classCallCheck(this, Type);\n\n              return _super2.apply(this, arguments);\n            }\n\n            return Type;\n          }(BaseType);\n\n          _classPrivateFieldLooseBase(this, _classes)[_classes].set(name, Type);\n        }\n      }\n\n      return Type;\n    }\n  }, {\n    key: \"getChainProperties\",\n    value: function getChainProperties() {\n      return _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties];\n    }\n  }, {\n    key: \"getClassName\",\n    value: function getClassName(clazz) {\n      var entry = _toConsumableArray(_classPrivateFieldLooseBase(this, _classes)[_classes].entries()).find(function (_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n            test = _ref6[1];\n\n        return test === clazz;\n      });\n\n      return entry ? entry[0] : undefined;\n    }\n  }, {\n    key: \"getDefinition\",\n    value: function getDefinition(typeName) {\n      return _classPrivateFieldLooseBase(this, _definitions)[_definitions].get(typeName);\n    }\n  }, {\n    key: \"getModuleInstances\",\n    value: function getModuleInstances(specName, moduleName) {\n      var _classPrivateFieldLoo4, _classPrivateFieldLoo5, _classPrivateFieldLoo6, _classPrivateFieldLoo7, _classPrivateFieldLoo8;\n\n      return (_classPrivateFieldLoo4 = _classPrivateFieldLooseBase(this, _knownTypes)[_knownTypes]) === null || _classPrivateFieldLoo4 === void 0 ? void 0 : (_classPrivateFieldLoo5 = _classPrivateFieldLoo4.typesBundle) === null || _classPrivateFieldLoo5 === void 0 ? void 0 : (_classPrivateFieldLoo6 = _classPrivateFieldLoo5.spec) === null || _classPrivateFieldLoo6 === void 0 ? void 0 : (_classPrivateFieldLoo7 = _classPrivateFieldLoo6[specName]) === null || _classPrivateFieldLoo7 === void 0 ? void 0 : (_classPrivateFieldLoo8 = _classPrivateFieldLoo7.instances) === null || _classPrivateFieldLoo8 === void 0 ? void 0 : _classPrivateFieldLoo8[moduleName];\n    }\n  }, {\n    key: \"getOrThrow\",\n    value: function getOrThrow(name, msg) {\n      return assertReturn(this.get(name), msg || \"type \".concat(name, \" not found\"));\n    }\n  }, {\n    key: \"getOrUnknown\",\n    value: function getOrUnknown(name) {\n      return this.get(name, true);\n    }\n  }, {\n    key: \"getSignedExtensionExtra\",\n    value: function getSignedExtensionExtra() {\n      return expandExtensionTypes(_classPrivateFieldLooseBase(this, _signedExtensions)[_signedExtensions], 'payload', _classPrivateFieldLooseBase(this, _userExtensions)[_userExtensions]);\n    }\n  }, {\n    key: \"getSignedExtensionTypes\",\n    value: function getSignedExtensionTypes() {\n      return expandExtensionTypes(_classPrivateFieldLooseBase(this, _signedExtensions)[_signedExtensions], 'extrinsic', _classPrivateFieldLooseBase(this, _userExtensions)[_userExtensions]);\n    }\n  }, {\n    key: \"hasClass\",\n    value: function hasClass(name) {\n      return _classPrivateFieldLooseBase(this, _classes)[_classes].has(name);\n    }\n  }, {\n    key: \"hasDef\",\n    value: function hasDef(name) {\n      return _classPrivateFieldLooseBase(this, _definitions)[_definitions].has(name);\n    }\n  }, {\n    key: \"hasType\",\n    value: function hasType(name) {\n      return !_classPrivateFieldLooseBase(this, _unknownTypes)[_unknownTypes].get(name) && (this.hasClass(name) || this.hasDef(name));\n    }\n  }, {\n    key: \"hash\",\n    value: function hash(data) {\n      return this.createType('CodecHash', _classPrivateFieldLooseBase(this, _hasher)[_hasher](data));\n    } // eslint-disable-next-line no-dupe-class-members\n\n  }, {\n    key: \"register\",\n    value: function register(arg1, arg2) {\n      // NOTE Constructors appear as functions here\n      if (isFunction(arg1)) {\n        _classPrivateFieldLooseBase(this, _classes)[_classes].set(arg1.name, arg1);\n      } else if (isString(arg1)) {\n        assert(isFunction(arg2), \"Expected class definition passed to '\".concat(arg1, \"' registration\"));\n        assert(arg1 !== arg2.toString(), \"Unable to register circular \".concat(arg1, \" === \").concat(arg1));\n\n        _classPrivateFieldLooseBase(this, _classes)[_classes].set(arg1, arg2);\n      } else {\n        this._registerObject(arg1);\n      }\n    }\n  }, {\n    key: \"_registerObject\",\n    value: function _registerObject(obj) {\n      var _this2 = this;\n\n      Object.entries(obj).forEach(function (_ref7) {\n        var _ref8 = _slicedToArray(_ref7, 2),\n            name = _ref8[0],\n            type = _ref8[1];\n\n        if (isFunction(type)) {\n          // This _looks_ a bit funny, but `typeof Clazz === 'function'\n          _classPrivateFieldLooseBase(_this2, _classes)[_classes].set(name, type);\n        } else {\n          var def = isString(type) ? type : JSON.stringify(type);\n          assert(name !== def, \"Unable to register circular \".concat(name, \" === \").concat(def)); // we already have this type, remove the classes registered for it\n\n          if (_classPrivateFieldLooseBase(_this2, _classes)[_classes].has(name)) {\n            _classPrivateFieldLooseBase(_this2, _classes)[_classes].delete(name);\n          }\n\n          _classPrivateFieldLooseBase(_this2, _definitions)[_definitions].set(name, def);\n        }\n      });\n    } // sets the chain properties\n\n  }, {\n    key: \"setChainProperties\",\n    value: function setChainProperties(properties) {\n      if (properties) {\n        _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties] = properties;\n      }\n    }\n  }, {\n    key: \"setHasher\",\n    value: function setHasher(hasher) {\n      _classPrivateFieldLooseBase(this, _hasher)[_hasher] = hasher || blake2AsU8a;\n    }\n  }, {\n    key: \"setKnownTypes\",\n    value: function setKnownTypes(knownTypes) {\n      _classPrivateFieldLooseBase(this, _knownTypes)[_knownTypes] = knownTypes;\n    } // sets the metadata\n\n  }, {\n    key: \"setMetadata\",\n    value: function setMetadata(metadata, signedExtensions, userExtensions) {\n      injectExtrinsics(this, metadata, _classPrivateFieldLooseBase(this, _metadataCalls)[_metadataCalls]);\n      injectErrors(this, metadata, _classPrivateFieldLooseBase(this, _metadataErrors)[_metadataErrors]);\n      injectEvents(this, metadata, _classPrivateFieldLooseBase(this, _metadataEvents)[_metadataEvents]); // setup the available extensions\n\n      this.setSignedExtensions(signedExtensions || (metadata.asLatest.extrinsic.version.gt(BN_ZERO) ? metadata.asLatest.extrinsic.signedExtensions.map(function (key) {\n        return key.toString();\n      }) : defaultExtensions), userExtensions); // setup the chain properties with format overrides\n\n      this.setChainProperties(extractProperties(this, metadata));\n    } // sets the available signed extensions\n\n  }, {\n    key: \"setSignedExtensions\",\n    value: function setSignedExtensions() {\n      var signedExtensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultExtensions;\n      var userExtensions = arguments.length > 1 ? arguments[1] : undefined;\n      _classPrivateFieldLooseBase(this, _signedExtensions)[_signedExtensions] = signedExtensions;\n      _classPrivateFieldLooseBase(this, _userExtensions)[_userExtensions] = userExtensions;\n      var unknown = findUnknownExtensions(_classPrivateFieldLooseBase(this, _signedExtensions)[_signedExtensions], _classPrivateFieldLooseBase(this, _userExtensions)[_userExtensions]);\n\n      if (unknown.length) {\n        l.warn(\"Unknown signed extensions \".concat(unknown.join(', '), \" found, treating them as no-effect\"));\n      }\n    }\n  }]);\n\n  return TypeRegistry;\n}();","map":null,"metadata":{},"sourceType":"module"}
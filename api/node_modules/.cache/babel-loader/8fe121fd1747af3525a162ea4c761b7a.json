{"ast":null,"code":"import _inherits from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\"; // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\nimport { assert, isNull, isU8a, isUndefined, u8aToHex } from '@polkadot/util';\nimport { Null } from \"../primitive/Null.js\";\nimport { typeToConstructor } from \"./utils/index.js\";\n/** @internal */\n\nfunction decodeOptionU8a(registry, Type, value) {\n  return !value.length || value[0] === 0 ? new Null(registry) : new Type(registry, value.subarray(1));\n}\n/** @internal */\n\n\nfunction decodeOption(registry, typeName, value) {\n  if (isNull(value) || isUndefined(value) || value instanceof Null) {\n    return new Null(registry);\n  }\n\n  var Type = typeToConstructor(registry, typeName); // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n  if (value instanceof Option) {\n    return decodeOption(registry, Type, value.value);\n  } else if (value instanceof Type) {\n    // don't re-create, use as it (which also caters for derived types)\n    return value;\n  } else if (isU8a(value)) {\n    // the isU8a check happens last in the if-tree - since the wrapped value\n    // may be an instance of it, so Type and Option checks go in first\n    return decodeOptionU8a(registry, Type, value);\n  }\n\n  return new Type(registry, value);\n}\n/**\n * @name Option\n * @description\n * An Option is an optional field. Basically the first byte indicates that there is\n * is value to follow. If the byte is `1` there is an actual value. So the Option\n * implements that - decodes, checks for optionality and wraps the required structure\n * with a value if/as required/found.\n */\n\n\nvar _Type = _classPrivateFieldLooseKey(\"Type\");\n\nvar _raw = _classPrivateFieldLooseKey(\"raw\");\n\nexport var Option = /*#__PURE__*/function () {\n  function Option(registry, typeName, value) {\n    _classCallCheck(this, Option);\n\n    this.registry = void 0;\n    this.createdAtHash = void 0;\n    Object.defineProperty(this, _Type, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _raw, {\n      writable: true,\n      value: void 0\n    });\n    this.registry = registry;\n    _classPrivateFieldLooseBase(this, _Type)[_Type] = typeToConstructor(registry, typeName);\n    _classPrivateFieldLooseBase(this, _raw)[_raw] = decodeOption(registry, typeName, value);\n  }\n\n  _createClass(Option, [{\n    key: \"encodedLength\",\n    get:\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    function get() {\n      // boolean byte (has value, doesn't have) along with wrapped length\n      return 1 + _classPrivateFieldLooseBase(this, _raw)[_raw].encodedLength;\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n\n  }, {\n    key: \"hash\",\n    get: function get() {\n      return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description Checks if the Option has no value\n     */\n\n  }, {\n    key: \"isEmpty\",\n    get: function get() {\n      return this.isNone;\n    }\n    /**\n     * @description Checks if the Option has no value\n     */\n\n  }, {\n    key: \"isNone\",\n    get: function get() {\n      return _classPrivateFieldLooseBase(this, _raw)[_raw] instanceof Null;\n    }\n    /**\n     * @description Checks if the Option has a value\n     */\n\n  }, {\n    key: \"isSome\",\n    get: function get() {\n      return !this.isNone;\n    }\n    /**\n     * @description The actual value for the Option\n     */\n\n  }, {\n    key: \"value\",\n    get: function get() {\n      return _classPrivateFieldLooseBase(this, _raw)[_raw];\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      if (other instanceof Option) {\n        return this.isSome === other.isSome && this.value.eq(other.value);\n      }\n\n      return this.value.eq(other);\n    }\n    /**\n     * @description Returns a hex string representation of the value\n     */\n\n  }, {\n    key: \"toHex\",\n    value: function toHex() {\n      // This attempts to align with the JSON encoding - actually in this case\n      // the isSome value is correct, however the `isNone` may be problematic\n      return this.isNone ? '0x' : u8aToHex(this.toU8a().subarray(1));\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n\n  }, {\n    key: \"toHuman\",\n    value: function toHuman(isExtended) {\n      return _classPrivateFieldLooseBase(this, _raw)[_raw].toHuman(isExtended);\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return _classPrivateFieldLooseBase(this, _raw)[_raw].toJSON();\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n\n  }, {\n    key: \"toRawType\",\n    value: function toRawType(isBare) {\n      var wrapped = this.registry.getClassName(_classPrivateFieldLooseBase(this, _Type)[_Type]) || new (_classPrivateFieldLooseBase(this, _Type)[_Type])(this.registry).toRawType();\n      return isBare ? wrapped : \"Option<\".concat(wrapped, \">\");\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return _classPrivateFieldLooseBase(this, _raw)[_raw].toString();\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n\n  }, {\n    key: \"toU8a\",\n    value: function toU8a(isBare) {\n      if (isBare) {\n        return _classPrivateFieldLooseBase(this, _raw)[_raw].toU8a(true);\n      }\n\n      var u8a = new Uint8Array(this.encodedLength);\n\n      if (this.isSome) {\n        u8a.set([1]);\n        u8a.set(_classPrivateFieldLooseBase(this, _raw)[_raw].toU8a(), 1);\n      }\n\n      return u8a;\n    }\n    /**\n     * @description Returns the value that the Option represents (if available), throws if null\n     */\n\n  }, {\n    key: \"unwrap\",\n    value: function unwrap() {\n      assert(this.isSome, 'Option: unwrapping a None value');\n      return _classPrivateFieldLooseBase(this, _raw)[_raw];\n    }\n    /**\n     * @description Returns the value that the Option represents (if available) or defaultValue if none\n     * @param defaultValue The value to return if the option isNone\n     */\n\n  }, {\n    key: \"unwrapOr\",\n    value: function unwrapOr(defaultValue) {\n      return this.isSome ? this.unwrap() : defaultValue;\n    }\n    /**\n     * @description Returns the value that the Option represents (if available) or defaultValue if none\n     * @param defaultValue The value to return if the option isNone\n     */\n\n  }, {\n    key: \"unwrapOrDefault\",\n    value: function unwrapOrDefault() {\n      return this.isSome ? this.unwrap() : new (_classPrivateFieldLooseBase(this, _Type)[_Type])(this.registry);\n    }\n  }], [{\n    key: \"with\",\n    value: function _with(Type) {\n      return /*#__PURE__*/function (_Option) {\n        _inherits(_class, _Option);\n\n        var _super = _createSuper(_class);\n\n        function _class(registry, value) {\n          _classCallCheck(this, _class);\n\n          return _super.call(this, registry, Type, value);\n        }\n\n        return _class;\n      }(Option);\n    }\n  }]);\n\n  return Option;\n}();","map":null,"metadata":{},"sourceType":"module"}
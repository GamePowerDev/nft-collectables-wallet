{"ast":null,"code":"import _get from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _classCallCheck from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { isString, u8aToU8a } from '@polkadot/util';\nimport { Raw } from \"./Raw.js\";\n/** @internal */\n\nfunction decodeU8aFixed(value, bitLength) {\n  if (Array.isArray(value) || isString(value)) {\n    return decodeU8aFixed(u8aToU8a(value), bitLength);\n  } // ensure that we have an actual u8a with the full length as specified by\n  // the bitLength input (padded with zeros as required)\n\n\n  var byteLength = bitLength / 8;\n  var sub = value.subarray(0, byteLength);\n\n  if (sub.length === byteLength) {\n    return sub;\n  }\n\n  var u8a = new Uint8Array(byteLength);\n  u8a.set(sub, 0);\n  return u8a;\n}\n/**\n * @name U8aFixed\n * @description\n * A U8a that manages a a sequence of bytes up to the specified bitLength. Not meant\n * to be used directly, rather is should be subclassed with the specific lengths.\n */\n\n\nexport var U8aFixed = /*#__PURE__*/function (_Raw) {\n  _inherits(U8aFixed, _Raw);\n\n  var _super = _createSuper(U8aFixed);\n\n  function U8aFixed(registry) {\n    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Uint8Array();\n    var bitLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 256;\n\n    _classCallCheck(this, U8aFixed);\n\n    return _super.call(this, registry, decodeU8aFixed(value, bitLength));\n  }\n\n  _createClass(U8aFixed, [{\n    key: \"toRawType\",\n    value:\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    function toRawType() {\n      return \"[u8;\".concat(this.length, \"]\");\n    }\n  }], [{\n    key: \"with\",\n    value: function _with(bitLength, typeName) {\n      return /*#__PURE__*/function (_U8aFixed) {\n        _inherits(_class, _U8aFixed);\n\n        var _super2 = _createSuper(_class);\n\n        function _class(registry, value) {\n          _classCallCheck(this, _class);\n\n          return _super2.call(this, registry, value, bitLength);\n        }\n\n        _createClass(_class, [{\n          key: \"toRawType\",\n          value: function toRawType() {\n            return typeName || _get(_getPrototypeOf(_class.prototype), \"toRawType\", this).call(this);\n          }\n        }]);\n\n        return _class;\n      }(U8aFixed);\n    }\n  }]);\n\n  return U8aFixed;\n}(Raw);","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _toConsumableArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n// Copyright 2017-2021 @polkadot/api authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { logger } from '@polkadot/util';\nvar l = logger('api/augment');\n\nfunction logLength(type, values) {\n  var and = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  return values.length ? \" \".concat(values.length, \" \").concat(type).concat(and.length ? ' and' : '') : '';\n}\n\nfunction logValues(type, values) {\n  return values.length ? \"\\n\\t\".concat(type.padStart(7), \": \").concat(values.sort().join(', ')) : '';\n} // log details to console\n\n\nfunction warn(prefix, type, _ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n      added = _ref2[0],\n      removed = _ref2[1];\n\n  if (added.length || removed.length) {\n    l.warn(\"api.\".concat(prefix, \": Found\").concat(logLength('added', added, removed)).concat(logLength('removed', removed), \" \").concat(type, \":\").concat(logValues('added', added)).concat(logValues('removed', removed)));\n  }\n}\n\nfunction extractKeys(src, dst) {\n  return [Object.keys(src), Object.keys(dst)];\n}\n\nfunction findSectionExcludes(a, b) {\n  return a.filter(function (section) {\n    return !b.includes(section);\n  });\n}\n\nfunction extractSections(src, dst) {\n  var _extractKeys = extractKeys(src, dst),\n      _extractKeys2 = _slicedToArray(_extractKeys, 2),\n      srcSections = _extractKeys2[0],\n      dstSections = _extractKeys2[1];\n\n  return [findSectionExcludes(srcSections, dstSections), findSectionExcludes(dstSections, srcSections)];\n}\n\nfunction findMethodExcludes(src, dst) {\n  var srcSections = Object.keys(src);\n  var dstSections = Object.keys(dst);\n  return dstSections.filter(function (section) {\n    return srcSections.includes(section);\n  }).reduce(function (rmMethods, section) {\n    var srcMethods = Object.keys(src[section]);\n    return rmMethods.concat.apply(rmMethods, _toConsumableArray(Object.keys(dst[section]).filter(function (method) {\n      return !srcMethods.includes(method);\n    }).map(function (method) {\n      return \"\".concat(section, \".\").concat(method);\n    })));\n  }, []);\n}\n\nfunction extractMethods(src, dst) {\n  return [findMethodExcludes(dst, src), findMethodExcludes(src, dst)];\n}\n/**\n * Takes a decorated api section (e.g. api.tx) and augment it with the details. It does not override what is\n * already available, but rather just adds new missing ites into the result object.\n * @internal\n */\n\n\nexport function augmentObject(prefix, src, dst) {\n  var fromEmpty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  if (fromEmpty) {\n    Object.keys(dst).forEach(function (key) {\n      delete dst[key];\n    });\n  }\n\n  if (prefix && Object.keys(dst).length) {\n    warn(prefix, 'modules', extractSections(src, dst));\n    warn(prefix, 'calls', extractMethods(src, dst));\n  }\n\n  return Object.keys(src).reduce(function (newSection, sectionName) {\n    var section = src[sectionName];\n    newSection[sectionName] = Object.keys(section).reduce(function (result, methodName) {\n      // TODO When it does match, check the actual details and warn when there are differences\n      if (!result[methodName]) {\n        result[methodName] = section[methodName];\n      }\n\n      return result;\n    }, dst[sectionName] || {});\n    return newSection;\n  }, dst);\n}","map":null,"metadata":{},"sourceType":"module"}
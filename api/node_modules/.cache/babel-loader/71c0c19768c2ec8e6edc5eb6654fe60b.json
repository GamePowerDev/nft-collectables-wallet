{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nvar ALLOWED_BOXES = ['BTreeMap', 'BTreeSet', 'Compact', 'DoNotConstruct', 'HashMap', 'Int', 'Linkage', 'Result', 'Option', 'UInt', 'Vec'];\nvar BOX_PRECEDING = ['<', '(', '[', '\"', ',', ' ']; // start of vec, tuple, fixed array, part of struct def or in tuple\n\nvar mappings = [// alias <T::InherentOfflineReport as InherentOfflineReport>::Inherent -> InherentOfflineReport\nalias(['<T::InherentOfflineReport as InherentOfflineReport>::Inherent'], 'InherentOfflineReport', false), alias(['VecDeque<'], 'Vec<', false), // <T::Balance as HasCompact>\ncleanupCompact(), // Remove all the trait prefixes\nremoveTraits(), // remove PairOf<T> -> (T, T)\nremovePairOf(), // remove boxing, `Box<Proposal>` -> `Proposal`\nremoveWrap('Box'), // remove generics, `MisbehaviorReport<Hash, BlockNumber>` -> `MisbehaviorReport`\nremoveGenerics(), // alias String -> Text (compat with jsonrpc methods)\nalias(['String'], 'Text'), // alias Vec<u8> -> Bytes\nalias(['Vec<u8>', '&\\\\[u8\\\\]'], 'Bytes'), // alias RawAddress -> Address\nalias(['RawAddress'], 'Address'), // lookups, mapped to Address/AccountId as appropriate in runtime\nalias(['Lookup::Source'], 'LookupSource'), alias(['Lookup::Target'], 'LookupTarget'), // HACK duplication between contracts & primitives, however contracts prefixed with exec\nalias(['exec::StorageKey'], 'ContractStorageKey'), // flattens tuples with one value, `(AccountId)` -> `AccountId`\nflattenSingleTuple(), // converts ::Type to Type, <T as Trait<I>>::Proposal -> Proposal\nremoveColons()]; // given a starting index, find the closing >\n\nexport function findClosing(value, start) {\n  var depth = 0;\n\n  for (var index = start; index < value.length; index++) {\n    if (value[index] === '>') {\n      if (!depth) {\n        return index;\n      }\n\n      depth--;\n    } else if (value[index] === '<') {\n      depth++;\n    }\n  }\n\n  throw new Error(\"Unable to find closing matching <> on '\".concat(value, \"' (start \").concat(start, \")\"));\n}\nexport function alias(src, dest) {\n  var withChecks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  return function (value) {\n    return src.reduce(function (value, src) {\n      return value.replace(new RegExp(\"(^\".concat(src, \"|\").concat(BOX_PRECEDING.map(function (box) {\n        return \"\\\\\".concat(box).concat(src);\n      }).join('|'), \")\"), 'g'), function (src) {\n        return withChecks && BOX_PRECEDING.includes(src[0]) ? \"\".concat(src[0]).concat(dest) : dest;\n      });\n    }, value);\n  };\n}\nexport function cleanupCompact() {\n  return function (value) {\n    for (var index = 0; index < value.length; index++) {\n      if (value[index] !== '<') {\n        continue;\n      }\n\n      var end = findClosing(value, index + 1) - 14;\n\n      if (value.substr(end, 14) === ' as HasCompact') {\n        value = \"Compact<\".concat(value.substr(index + 1, end - index - 1), \">\");\n      }\n    }\n\n    return value;\n  };\n}\nexport function flattenSingleTuple() {\n  return function (value) {\n    return value.replace(/\\(([^,]+)\\)/, '$1');\n  };\n}\nexport function removeColons() {\n  return function (value) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        allowNamespaces = _ref.allowNamespaces;\n\n    var index = 0;\n\n    while (index !== -1) {\n      index = value.indexOf('::');\n\n      if (index === 0) {\n        value = value.substr(2);\n      } else if (index !== -1) {\n        if (allowNamespaces) {\n          return value;\n        }\n\n        var start = index;\n\n        while (start !== -1 && !BOX_PRECEDING.includes(value[start])) {\n          start--;\n        }\n\n        value = \"\".concat(value.substr(0, start + 1)).concat(value.substr(index + 2));\n      }\n    }\n\n    return value;\n  };\n}\nexport function removeGenerics() {\n  return function (value) {\n    var _loop = function _loop(index) {\n      if (value[index] === '<') {\n        // check against the allowed wrappers, be it Vec<..>, Option<...> ...\n        var box = ALLOWED_BOXES.find(function (box) {\n          var start = index - box.length;\n          return start >= 0 && value.substr(start, box.length) === box && ( // make sure it is stand-alone, i.e. don't catch ElectionResult<...> as Result<...>\n          start === 0 || BOX_PRECEDING.includes(value[start - 1]));\n        }); // we have not found anything, unwrap generic innards\n\n        if (!box) {\n          var end = findClosing(value, index + 1);\n          value = \"\".concat(value.substr(0, index)).concat(value.substr(end + 1));\n        }\n      }\n    };\n\n    for (var index = 0; index < value.length; index++) {\n      _loop(index);\n    }\n\n    return value;\n  };\n} // remove the PairOf wrappers\n\nexport function removePairOf() {\n  return function (value) {\n    for (var index = 0; index < value.length; index++) {\n      if (value.substr(index, 7) === 'PairOf<') {\n        var start = index + 7;\n        var end = findClosing(value, start);\n        var type = value.substr(start, end - start);\n        value = \"\".concat(value.substr(0, index), \"(\").concat(type, \",\").concat(type, \")\").concat(value.substr(end + 1));\n      }\n    }\n\n    return value;\n  };\n} // remove the type traits\n\nexport function removeTraits() {\n  return function (value) {\n    return value // remove all whitespaces\n    .replace(/\\s/g, '') // anything `T::<type>` to end up as `<type>`\n    .replace(/(T|Self)::/g, '') // replace `<T as Trait>::` (whitespaces were removed above)\n    .replace(/<(T|Self)asTrait>::/g, '') // replace `<T as something::Trait>::` (whitespaces were removed above)\n    .replace(/<Tas[a-z]+::Trait>::/g, '') // replace <Lookup as StaticLookup>\n    .replace(/<LookupasStaticLookup>/g, 'Lookup') // replace `<...>::Type`\n    .replace(/::Type/g, '');\n  };\n} // remove wrapping values, i.e. Box<Proposal> -> Proposal\n\nexport function removeWrap(_check) {\n  var check = \"\".concat(_check, \"<\");\n  return function (value) {\n    var index = 0;\n\n    while (index !== -1) {\n      index = value.indexOf(check);\n\n      if (index !== -1) {\n        var start = index + check.length;\n        var end = findClosing(value, start);\n        value = \"\".concat(value.substr(0, index)).concat(value.substr(start, end - start)).concat(value.substr(end + 1));\n      }\n    }\n\n    return value;\n  };\n} // eslint-disable-next-line @typescript-eslint/ban-types\n\nexport function sanitize(value, options) {\n  return mappings.reduce(function (result, fn) {\n    return fn(result, options);\n  }, value.toString()).trim();\n}","map":null,"metadata":{},"sourceType":"module"}
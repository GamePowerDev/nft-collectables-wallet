{"ast":null,"code":"import _slicedToArray from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _regeneratorRuntime from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _get from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/michaelhuntington/Documents/GitHub/nft-collectibles-wallet/api/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/api authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable no-dupe-class-members */\n\n\nimport { assert, isBn, isFunction, isNumber, isString, isU8a } from '@polkadot/util';\nimport { of } from '@polkadot/x-rxjs';\nimport { catchError, first, map, mapTo, mergeMap, switchMap, tap } from '@polkadot/x-rxjs/operators';\nimport { filterEvents, isKeyringPair } from \"../util/index.js\";\nimport { SubmittableResult } from \"./Result.js\";\n\nvar identity = function identity(input) {\n  return input;\n};\n\nexport function createClass(_ref) {\n  var api = _ref.api,\n      apiType = _ref.apiType,\n      decorateMethod = _ref.decorateMethod;\n  // an instance of the base extrinsic for us to extend\n  var ExtrinsicBase = api.registry.createClass('Extrinsic');\n\n  var _ignoreStatusCb = _classPrivateFieldLooseKey(\"ignoreStatusCb\");\n\n  var _transformResult = _classPrivateFieldLooseKey(\"transformResult\");\n\n  var _makeEraOptions = _classPrivateFieldLooseKey(\"makeEraOptions\");\n\n  var _makeSignOptions = _classPrivateFieldLooseKey(\"makeSignOptions\");\n\n  var _makeSignAndSendOptions = _classPrivateFieldLooseKey(\"makeSignAndSendOptions\");\n\n  var _observeSign = _classPrivateFieldLooseKey(\"observeSign\");\n\n  var _observeStatus = _classPrivateFieldLooseKey(\"observeStatus\");\n\n  var _observeSend = _classPrivateFieldLooseKey(\"observeSend\");\n\n  var _observeSubscribe = _classPrivateFieldLooseKey(\"observeSubscribe\");\n\n  var _optionsOrNonce = _classPrivateFieldLooseKey(\"optionsOrNonce\");\n\n  var _signViaSigner = _classPrivateFieldLooseKey(\"signViaSigner\");\n\n  var _updateSigner = _classPrivateFieldLooseKey(\"updateSigner\");\n\n  var Submittable = /*#__PURE__*/function (_ExtrinsicBase) {\n    _inherits(Submittable, _ExtrinsicBase);\n\n    var _super = _createSuper(Submittable);\n\n    function Submittable(registry, extrinsic) {\n      var _thisSuper, _this;\n\n      _classCallCheck(this, Submittable);\n\n      _this = _super.call(this, registry, extrinsic, {\n        version: api.extrinsicType\n      });\n      Object.defineProperty(_assertThisInitialized(_this), _ignoreStatusCb, {\n        writable: true,\n        value: void 0\n      });\n      Object.defineProperty(_assertThisInitialized(_this), _transformResult, {\n        writable: true,\n        value: identity\n      });\n      Object.defineProperty(_assertThisInitialized(_this), _makeEraOptions, {\n        writable: true,\n        value: function value(options, _ref2) {\n          var header = _ref2.header,\n              mortalLength = _ref2.mortalLength,\n              nonce = _ref2.nonce;\n\n          if (!header) {\n            if (isNumber(options.era)) {\n              // since we have no header, it is immortal, remove any option overrides\n              // so we only supply the genesisHash and no era to the construction\n              delete options.era;\n              delete options.blockHash;\n            }\n\n            return _classPrivateFieldLooseBase(_assertThisInitialized(_this), _makeSignOptions)[_makeSignOptions](options, {\n              nonce: nonce\n            });\n          }\n\n          return _classPrivateFieldLooseBase(_assertThisInitialized(_this), _makeSignOptions)[_makeSignOptions](options, {\n            blockHash: header.hash,\n            era: _this.registry.createType('ExtrinsicEra', {\n              current: header.number,\n              period: options.era || mortalLength\n            }),\n            nonce: nonce\n          });\n        }\n      });\n      Object.defineProperty(_assertThisInitialized(_this), _makeSignOptions, {\n        writable: true,\n        value: function value(options, extras) {\n          return _objectSpread(_objectSpread(_objectSpread({\n            blockHash: api.genesisHash,\n            genesisHash: api.genesisHash\n          }, options), extras), {}, {\n            runtimeVersion: api.runtimeVersion,\n            signedExtensions: api.registry.signedExtensions,\n            version: api.extrinsicType\n          });\n        }\n      });\n      Object.defineProperty(_assertThisInitialized(_this), _makeSignAndSendOptions, {\n        writable: true,\n        value: function value(optionsOrStatus, statusCb) {\n          var options = {};\n\n          if (isFunction(optionsOrStatus)) {\n            statusCb = optionsOrStatus;\n          } else {\n            options = _objectSpread({}, optionsOrStatus);\n          }\n\n          return [options, statusCb];\n        }\n      });\n      Object.defineProperty(_assertThisInitialized(_this), _observeSign, {\n        writable: true,\n        value: function value(account, optionsOrNonce) {\n          var address = isKeyringPair(account) ? account.address : account.toString();\n\n          var options = _classPrivateFieldLooseBase(_assertThisInitialized(_this), _optionsOrNonce)[_optionsOrNonce](optionsOrNonce);\n\n          var updateId;\n          return api.derive.tx.signingInfo(address, options.nonce, options.era).pipe(first(), mergeMap( /*#__PURE__*/function () {\n            var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(signingInfo) {\n              var eraOptions;\n              return _regeneratorRuntime.wrap(function _callee$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      eraOptions = _classPrivateFieldLooseBase(_assertThisInitialized(_this), _makeEraOptions)[_makeEraOptions](options, signingInfo);\n\n                      if (!isKeyringPair(account)) {\n                        _context.next = 5;\n                        break;\n                      }\n\n                      _this.sign(account, eraOptions);\n\n                      _context.next = 8;\n                      break;\n\n                    case 5:\n                      _context.next = 7;\n                      return _classPrivateFieldLooseBase(_assertThisInitialized(_this), _signViaSigner)[_signViaSigner](address, eraOptions, signingInfo.header);\n\n                    case 7:\n                      updateId = _context.sent;\n\n                    case 8:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, _callee);\n            }));\n\n            return function (_x) {\n              return _ref3.apply(this, arguments);\n            };\n          }()), mapTo(updateId));\n        }\n      });\n      Object.defineProperty(_assertThisInitialized(_this), _observeStatus, {\n        writable: true,\n        value: function value(hash, status) {\n          if (!status.isFinalized && !status.isInBlock) {\n            return of(_classPrivateFieldLooseBase(_assertThisInitialized(_this), _transformResult)[_transformResult](new SubmittableResult({\n              status: status\n            })));\n          }\n\n          var blockHash = status.isInBlock ? status.asInBlock : status.asFinalized;\n          return api.derive.tx.events(blockHash).pipe(map(function (_ref4) {\n            var block = _ref4.block,\n                events = _ref4.events;\n            return _classPrivateFieldLooseBase(_assertThisInitialized(_this), _transformResult)[_transformResult](new SubmittableResult({\n              events: filterEvents(hash, block, events, status),\n              status: status\n            }));\n          }), catchError(function (internalError) {\n            return of(_classPrivateFieldLooseBase(_assertThisInitialized(_this), _transformResult)[_transformResult](new SubmittableResult({\n              internalError: internalError,\n              status: status\n            })));\n          }));\n        }\n      });\n      Object.defineProperty(_assertThisInitialized(_this), _observeSend, {\n        writable: true,\n        value: function value() {\n          var updateId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;\n          return api.rpc.author.submitExtrinsic(_assertThisInitialized(_this)).pipe(tap(function (hash) {\n            _classPrivateFieldLooseBase(_assertThisInitialized(_this), _updateSigner)[_updateSigner](updateId, hash);\n          }));\n        }\n      });\n      Object.defineProperty(_assertThisInitialized(_this), _observeSubscribe, {\n        writable: true,\n        value: function value() {\n          var updateId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;\n          var hash = _this.hash;\n          return api.rpc.author.submitAndWatchExtrinsic(_assertThisInitialized(_this)).pipe(switchMap(function (status) {\n            return _classPrivateFieldLooseBase(_assertThisInitialized(_this), _observeStatus)[_observeStatus](hash, status);\n          }), tap(function (status) {\n            _classPrivateFieldLooseBase(_assertThisInitialized(_this), _updateSigner)[_updateSigner](updateId, status);\n          }));\n        }\n      });\n      Object.defineProperty(_assertThisInitialized(_this), _optionsOrNonce, {\n        writable: true,\n        value: function value() {\n          var optionsOrNonce = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          return isBn(optionsOrNonce) || isNumber(optionsOrNonce) ? {\n            nonce: optionsOrNonce\n          } : optionsOrNonce;\n        }\n      });\n      Object.defineProperty(_assertThisInitialized(_this), _signViaSigner, {\n        writable: true,\n        value: function () {\n          var _value = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(address, options, header) {\n            var signer, payload, result;\n            return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n              while (1) {\n                switch (_context2.prev = _context2.next) {\n                  case 0:\n                    signer = options.signer || api.signer;\n                    assert(signer, 'No signer specified, either via api.setSigner or via sign options. You possibly need to pass through an explicit keypair for the origin so it can be used for signing.');\n                    payload = _this.registry.createType('SignerPayload', _objectSpread(_objectSpread({}, options), {}, {\n                      address: address,\n                      blockNumber: header ? header.number : 0,\n                      method: _this.method\n                    }));\n\n                    if (!signer.signPayload) {\n                      _context2.next = 9;\n                      break;\n                    }\n\n                    _context2.next = 6;\n                    return signer.signPayload(payload.toPayload());\n\n                  case 6:\n                    result = _context2.sent;\n                    _context2.next = 16;\n                    break;\n\n                  case 9:\n                    if (!signer.signRaw) {\n                      _context2.next = 15;\n                      break;\n                    }\n\n                    _context2.next = 12;\n                    return signer.signRaw(payload.toRaw());\n\n                  case 12:\n                    result = _context2.sent;\n                    _context2.next = 16;\n                    break;\n\n                  case 15:\n                    throw new Error('Invalid signer interface, it should implement either signPayload or signRaw (or both)');\n\n                  case 16:\n                    // Here we explicitly call `toPayload()` again instead of working with an object\n                    // (reference) as passed to the signer. This means that we are sure that the\n                    // payload data is not modified from our inputs, but the signer\n                    _get((_thisSuper = _assertThisInitialized(_this), _getPrototypeOf(Submittable.prototype)), \"addSignature\", _thisSuper).call(_thisSuper, address, result.signature, payload.toPayload());\n\n                    return _context2.abrupt(\"return\", result.id);\n\n                  case 18:\n                  case \"end\":\n                    return _context2.stop();\n                }\n              }\n            }, _callee2);\n          }));\n\n          function value(_x2, _x3, _x4) {\n            return _value.apply(this, arguments);\n          }\n\n          return value;\n        }()\n      });\n      Object.defineProperty(_assertThisInitialized(_this), _updateSigner, {\n        writable: true,\n        value: function value(updateId, status) {\n          if (updateId !== -1 && api.signer && api.signer.update) {\n            api.signer.update(updateId, status);\n          }\n        }\n      });\n      _classPrivateFieldLooseBase(_assertThisInitialized(_this), _ignoreStatusCb)[_ignoreStatusCb] = apiType === 'rxjs';\n      return _this;\n    } // dry run an extrinsic\n\n\n    _createClass(Submittable, [{\n      key: \"dryRun\",\n      value: function dryRun(account, optionsOrHash) {\n        var _this2 = this;\n\n        if (isString(optionsOrHash) || isU8a(optionsOrHash)) {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n          return decorateMethod(function () {\n            return api.rpc.system.dryRun(_this2.toHex(), optionsOrHash);\n          });\n        } // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call\n\n\n        return decorateMethod(function () {\n          return _classPrivateFieldLooseBase(_this2, _observeSign)[_observeSign](account, optionsOrHash).pipe(switchMap(function () {\n            return api.rpc.system.dryRun(_this2.toHex());\n          }));\n        })();\n      } // calculate the payment info for this transaction (if signed and submitted)\n\n    }, {\n      key: \"paymentInfo\",\n      value: function paymentInfo(account, optionsOrHash) {\n        var _this3 = this;\n\n        if (isString(optionsOrHash) || isU8a(optionsOrHash)) {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n          return decorateMethod(function () {\n            return api.rpc.payment.queryInfo(_this3.toHex(), optionsOrHash);\n          });\n        }\n\n        var _classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _makeSignAndSendOptions)[_makeSignAndSendOptions](optionsOrHash),\n            _classPrivateFieldLoo2 = _slicedToArray(_classPrivateFieldLoo, 1),\n            allOptions = _classPrivateFieldLoo2[0];\n\n        var address = isKeyringPair(account) ? account.address : account.toString(); // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call\n\n        return decorateMethod(function () {\n          return api.derive.tx.signingInfo(address, allOptions.nonce, allOptions.era).pipe(first(), switchMap(function (signingInfo) {\n            // setup our options (same way as in signAndSend)\n            var eraOptions = _classPrivateFieldLooseBase(_this3, _makeEraOptions)[_makeEraOptions](allOptions, signingInfo);\n\n            var signOptions = _classPrivateFieldLooseBase(_this3, _makeSignOptions)[_makeSignOptions](eraOptions, {});\n\n            _this3.signFake(address, signOptions);\n\n            return api.rpc.payment.queryInfo(_this3.toHex());\n          }));\n        })();\n      } // send with an immediate Hash result\n      // send implementation for both immediate Hash and statusCb variants\n\n    }, {\n      key: \"send\",\n      value: function send(statusCb) {\n        var isSubscription = api.hasSubscriptions && (_classPrivateFieldLooseBase(this, _ignoreStatusCb)[_ignoreStatusCb] || !!statusCb); // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call\n\n        return decorateMethod(isSubscription ? _classPrivateFieldLooseBase(this, _observeSubscribe)[_observeSubscribe] : _classPrivateFieldLooseBase(this, _observeSend)[_observeSend])(statusCb);\n      }\n      /**\n       * @description Sign a transaction, returning the this to allow chaining, i.e. .sign(...).send(). When options, e.g. nonce/blockHash are not specified, it will be inferred. To retrieve eg. nonce use `signAsync` (the preferred interface, this is provided for backwards compatibility)\n       * @deprecated\n       */\n\n    }, {\n      key: \"sign\",\n      value: function sign(account, optionsOrNonce) {\n        _get(_getPrototypeOf(Submittable.prototype), \"sign\", this).call(this, account, _classPrivateFieldLooseBase(this, _makeSignOptions)[_makeSignOptions](_classPrivateFieldLooseBase(this, _optionsOrNonce)[_optionsOrNonce](optionsOrNonce), {}));\n\n        return this;\n      }\n      /**\n       * @description Signs a transaction, returning `this` to allow chaining. E.g.: `sign(...).send()`. Like `.signAndSend` this will retrieve the nonce and blockHash to send the tx with.\n       */\n\n    }, {\n      key: \"signAsync\",\n      value: function signAsync(account, optionsOrNonce) {\n        var _this4 = this;\n\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call\n        return decorateMethod(function () {\n          return _classPrivateFieldLooseBase(_this4, _observeSign)[_observeSign](account, optionsOrNonce).pipe(mapTo(_this4));\n        })();\n      } // signAndSend with an immediate Hash result\n      // signAndSend implementation for all 3 cases above\n\n    }, {\n      key: \"signAndSend\",\n      value: function signAndSend(account, optionsOrStatus, optionalStatusCb) {\n        var _this5 = this;\n\n        var _classPrivateFieldLoo3 = _classPrivateFieldLooseBase(this, _makeSignAndSendOptions)[_makeSignAndSendOptions](optionsOrStatus, optionalStatusCb),\n            _classPrivateFieldLoo4 = _slicedToArray(_classPrivateFieldLoo3, 2),\n            options = _classPrivateFieldLoo4[0],\n            statusCb = _classPrivateFieldLoo4[1];\n\n        var isSubscription = api.hasSubscriptions && (_classPrivateFieldLooseBase(this, _ignoreStatusCb)[_ignoreStatusCb] || !!statusCb); // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call\n\n        return decorateMethod(function () {\n          return _classPrivateFieldLooseBase(_this5, _observeSign)[_observeSign](account, options).pipe(switchMap(function (updateId) {\n            return isSubscription ? _classPrivateFieldLooseBase(_this5, _observeSubscribe)[_observeSubscribe](updateId) : _classPrivateFieldLooseBase(_this5, _observeSend)[_observeSend](updateId);\n          }));\n        } // FIXME This is wrong, SubmittableResult is _not_ a codec\n        )(statusCb);\n      } // adds a transform to the result, applied before result is returned\n\n    }, {\n      key: \"withResultTransform\",\n      value: function withResultTransform(transform) {\n        _classPrivateFieldLooseBase(this, _transformResult)[_transformResult] = transform;\n        return this;\n      }\n    }]);\n\n    return Submittable;\n  }(ExtrinsicBase);\n\n  return Submittable;\n}","map":null,"metadata":{},"sourceType":"module"}